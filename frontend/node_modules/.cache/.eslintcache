[{"/Users/danny/Github/physics_engine_for_the_web/frontend/src/index.tsx":"1","/Users/danny/Github/physics_engine_for_the_web/frontend/src/App.tsx":"2","/Users/danny/Github/physics_engine_for_the_web/frontend/src/NavBar/NavBar.tsx":"3","/Users/danny/Github/physics_engine_for_the_web/frontend/src/physics_engine/physics_engine.ts":"4","/Users/danny/Github/physics_engine_for_the_web/frontend/src/physics_engine/Sphere.ts":"5","/Users/danny/Github/physics_engine_for_the_web/frontend/src/physics_engine/Box.ts":"6","/Users/danny/Github/physics_engine_for_the_web/frontend/src/physics_engine/math_library.ts":"7","/Users/danny/Github/physics_engine_for_the_web/frontend/src/physics_engine/Plane.ts":"8","/Users/danny/Github/physics_engine_for_the_web/frontend/src/Demos/Demo2.tsx":"9","/Users/danny/Github/physics_engine_for_the_web/frontend/src/Demos/Demo1.tsx":"10","/Users/danny/Github/physics_engine_for_the_web/frontend/src/Demos/Demo3.tsx":"11","/Users/danny/Github/physics_engine_for_the_web/frontend/src/About/About.tsx":"12"},{"size":579,"mtime":1656787118854,"results":"13","hashOfConfig":"14"},{"size":987,"mtime":1659559837319,"results":"15","hashOfConfig":"14"},{"size":830,"mtime":1659559769530,"results":"16","hashOfConfig":"14"},{"size":45606,"mtime":1659635971670,"results":"17","hashOfConfig":"14"},{"size":3807,"mtime":1658902003022,"results":"18","hashOfConfig":"14"},{"size":6710,"mtime":1658901978598,"results":"19","hashOfConfig":"14"},{"size":5487,"mtime":1658787480078,"results":"20","hashOfConfig":"14"},{"size":2681,"mtime":1658888802272,"results":"21","hashOfConfig":"14"},{"size":9984,"mtime":1659636002645,"results":"22","hashOfConfig":"14"},{"size":7677,"mtime":1659635135461,"results":"23","hashOfConfig":"14"},{"size":6359,"mtime":1659635189894,"results":"24","hashOfConfig":"14"},{"size":3327,"mtime":1659559714788,"results":"25","hashOfConfig":"14"},{"filePath":"26","messages":"27","suppressedMessages":"28","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"29"},"35l3dn",{"filePath":"30","messages":"31","suppressedMessages":"32","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"33"},{"filePath":"34","messages":"35","suppressedMessages":"36","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"37","messages":"38","suppressedMessages":"39","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"40"},{"filePath":"41","messages":"42","suppressedMessages":"43","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":1,"source":"44"},{"filePath":"45","messages":"46","suppressedMessages":"47","errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"48"},{"filePath":"49","messages":"50","suppressedMessages":"51","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"52","messages":"53","suppressedMessages":"54","errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"55"},{"filePath":"56","messages":"57","suppressedMessages":"58","errorCount":0,"fatalErrorCount":0,"warningCount":9,"fixableErrorCount":0,"fixableWarningCount":0,"source":"59"},{"filePath":"60","messages":"61","suppressedMessages":"62","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"63"},{"filePath":"64","messages":"65","suppressedMessages":"66","errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"67"},{"filePath":"68","messages":"69","suppressedMessages":"70","errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":1,"source":"71"},"/Users/danny/Github/physics_engine_for_the_web/frontend/src/index.tsx",[],[],[],"/Users/danny/Github/physics_engine_for_the_web/frontend/src/App.tsx",["72"],[],"import React from 'react';\nimport logo from './logo.svg';\nimport './App.css';\nimport { Routes, Route, Navigate } from \"react-router-dom\";\nimport NavBar from \"./NavBar/NavBar\";\nimport About from \"./About/About\";\nimport Demo1 from \"./Demos/Demo1\";\nimport Demo2 from \"./Demos/Demo2\";\nimport Demo3 from \"./Demos/Demo3\";\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <div className=\"site-title box\">\n        <h1>Physics Engine for the Web</h1>\n      </div>\n      <div className=\"horizontal-container\">\n        <NavBar />\n        <div id=\"main_page\">\n          <Routes>\n            <Route path=\"/about\" element={<About />}></Route>\n            <Route path=\"/demo1\" element={<Demo1 />}></Route>\n            <Route path=\"/demo2\" element={<Demo2 />}></Route>\n            <Route path=\"/demo3\" element={<Demo3 />}></Route>\n\n            <Route path=\"/\" element={<Navigate to=\"/about\" />}></Route>\n          </Routes>\n        </div>\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n","/Users/danny/Github/physics_engine_for_the_web/frontend/src/NavBar/NavBar.tsx",[],[],"/Users/danny/Github/physics_engine_for_the_web/frontend/src/physics_engine/physics_engine.ts",["73"],[],"import { Matrix3, Vector3 } from \"three\";\nimport * as THREE from \"three\";\nimport { Sphere } from \"./Sphere\";\nimport { Box } from \"./Box\";\nimport { Plane } from \"./Plane\";\n\nexport { Sphere } from \"./Sphere\";\nexport { Box } from \"./Box\";\nexport { Plane } from \"./Plane\";\n\nexport class World {\n    public objects: any[];\n    public coefficient_of_restitution: number = 0.8; // 0 is fully inelastic, 1 is fully elastic\n    public dt: number = 1/60; // time step in seconds\n\n    constructor() {\n        this.objects = [];\n    }\n\n    addObject(obj: any): void {\n        this.objects.push(obj);\n    }\n\n    getAllBoundingBoxIntersections() {\n        // for now just sort against x-axis. Slightly better is to update axis based on one with highest variance\n        // worst case is still O(n^2)\n    \n        function compareBoundingBoxes(a: any, b: any) {\n            const a_min = a.position.x - a.boundingBox.x/2;\n            const b_min = b.position.x - b.boundingBox.x/2;\n            return a_min - b_min;\n        }\n    \n        // sort objects along x-axis\n        const objectsCopy = [...this.objects];\n        objectsCopy.sort(compareBoundingBoxes);\n    \n        // sweep the array for collisions\n        const intersections = [];\n        for(let i = 0; i < objectsCopy.length - 1; i++) {\n            // test against all possible overlapping boxes following the current one.\n            for(let j = i + 1; j < objectsCopy.length; j++) {\n                // stop testing when AABBs are beyond the current AABB\n                const i_max = objectsCopy[i].position.x + objectsCopy[i].boundingBox.x/2;\n                const j_min = objectsCopy[j].position.x - objectsCopy[j].boundingBox.x/2;\n                if (j_min > i_max) {\n                    break;\n                }\n    \n                if (checkBoundingBoxIntersection(objectsCopy[i], objectsCopy[j])) {\n                    intersections.push({\n                        a: objectsCopy[i],\n                        b: objectsCopy[j]\n                    });\n                }\n            }\n        }\n        return intersections;\n    }\n\n    // applies the forceAccum, detects and resolves collisions, and finally updates the positions of all objects.\n    tick(duration: number): void {\n        for (let object of this.objects) {\n            if (object instanceof Plane) {\n                continue;\n            }\n\n            object.integrateForceAccum(duration);\n        }\n\n        const boundingBoxIntersections = this.getAllBoundingBoxIntersections();\n        const contacts = getAllContacts(boundingBoxIntersections);\n        \n        for (let contact of contacts) {\n            this.resolveCollision(contact);\n        }\n\n        for (let object of this.objects) {\n            if (object instanceof Plane) {\n                continue;\n            }\n\n            object.integrate(duration);\n        }\n    }\n\n    // integrates the forceAccum to update the velocity of each object\n    integrateForceAccumObjects(duration: number): void {\n        for(let object of this.objects) {\n            if (object instanceof Plane) {\n                continue;\n            }\n\n            object.integrateForceAccum(duration);\n        }\n    }\n\n    // integrates the velocities to update the position of each object\n    integrateObjects(duration: number): void {\n        for (let object of this.objects) {\n            if (object instanceof Plane) {\n                continue;\n            }\n\n            object.integrate(duration);\n        }\n    }\n\n    resolveCollision(contactData: any) {\n        const a = contactData.a;\n        const b = contactData.b;\n        const normal = contactData.contactNormal;\n        if (contactData.type === \"vertex-face\") {\n            console.log(\"resolving vertex-face contact\");\n            const vertex = contactData.contactPoint;\n            const r_a = vertex.clone().sub(a.position);\n            const r_b = vertex.clone().sub(b.position);\n            const vertexVelocity_a = a.velocity.clone().add(a.getAngularVelocity().cross(r_a));\n            const vertexVelocity_b = b.velocity.clone().add(b.getAngularVelocity().cross(r_b));\n            const relativeVelocity = normal.dot(vertexVelocity_a.clone().sub(vertexVelocity_b));\n            if (relativeVelocity < 0) {\n                console.log(\"colliding contact\");\n                \n                const I_inverse_a = a.getInertia().invert();\n                const I_inverse_b = b.getInertia().invert();\n    \n                const term1 = normal.dot(r_a.clone().cross(normal).applyMatrix3(I_inverse_a).cross(r_a));\n                const term2 = normal.dot(r_b.clone().cross(normal).applyMatrix3(I_inverse_b).cross(r_b));\n    \n                const j = -(1 + coefficient_of_restitution) * relativeVelocity / (a.inverseMass + b.inverseMass + term1 + term2);\n                console.log(\"relative Velocity: \", relativeVelocity);\n    \n                const impulse = normal.clone().multiplyScalar(j);\n                const impulse2 = normal.clone().multiplyScalar(-j);\n                a.applyImpulse(vertex, impulse);\n                b.applyImpulse(vertex, impulse2);\n            } else if (relativeVelocity === 0) {\n                console.log(\"resting contact\");\n            } else {\n                // ignore\n                console.log(\"leaving\");\n            }\n        } else if (contactData.type === \"edge-edge\") {\n            console.log(\"resolving edge-edge contact\");\n            console.log(\"edge_a\", contactData.edge_a);\n            console.log(\"edge_b\", contactData.edge_b);\n            console.log(\"contactNormal: \", contactData.contactNormal);\n    \n            const vertex = getClosestPointBetweenTwoEdges(contactData.edge_a, contactData.edge_b);\n            const r_a = vertex.clone().sub(a.position);\n            const r_b = vertex.clone().sub(b.position);\n            const vertexVelocity_a = a.velocity.clone().add(a.getAngularVelocity().cross(r_a));\n            const vertexVelocity_b = b.velocity.clone().add(b.getAngularVelocity().cross(r_b));\n            const relativeVelocity = normal.dot(vertexVelocity_a.clone().sub(vertexVelocity_b));\n            if (relativeVelocity < 0) {\n                console.log(\"colliding contact\");\n                \n                const I_inverse_a = a.getInertia().invert();\n                let I_inverse_b = b.getInertia().invert();\n    \n                const term1 = normal.dot(r_a.clone().cross(normal).applyMatrix3(I_inverse_a).cross(r_a));\n                const term2 = normal.dot(r_b.clone().cross(normal).applyMatrix3(I_inverse_b).cross(r_b));\n    \n                const j = -(1 + coefficient_of_restitution) * relativeVelocity / (a.inverseMass + b.inverseMass + term1 + term2);\n    \n                const impulse = normal.clone().multiplyScalar(j);\n                const impulse2 = normal.clone().multiplyScalar(-j);\n                a.applyImpulse(vertex, impulse);\n                b.applyImpulse(vertex, impulse2);\n            } else if (relativeVelocity === 0) {\n                console.log(\"resting contact\");\n            } else {\n                // ignore\n                console.log(\"leaving\");\n            }\n        } else {\n            console.error(\"contactData type not recognized.\");\n            console.log(\"contact data: \", contactData);\n        }\n    }\n\n    updateMeshes(): void {\n        for (let object of this.objects) {\n            if (object instanceof Plane) {\n                continue;\n            }\n\n            object.updateMesh();\n            object.updateBoundingBoxMesh();\n        }\n    }\n}\n\n/**\n * checks if the bounding box of two objects intersect\n * @param a the first object\n * @param b the other object\n */\nexport function checkBoundingBoxIntersection(a: any, b: any): boolean {\n    // create intervals\n    const a_x_min = a.position.x - a.boundingBox.x/2;\n    const a_x_max = a.position.x + a.boundingBox.x/2;\n    const a_y_min = a.position.y - a.boundingBox.y/2;\n    const a_y_max = a.position.y + a.boundingBox.y/2;\n    const a_z_min = a.position.z - a.boundingBox.z/2;\n    const a_z_max = a.position.z + a.boundingBox.z/2;\n    const b_x_min = b.position.x - b.boundingBox.x/2;\n    const b_x_max = b.position.x + b.boundingBox.x/2;\n    const b_y_min = b.position.y - b.boundingBox.y/2;\n    const b_y_max = b.position.y + b.boundingBox.y/2;\n    const b_z_min = b.position.z - b.boundingBox.z/2;\n    const b_z_max = b.position.z + b.boundingBox.z/2;\n\n    // intersecting if all intervals are intersecting\n    if ((a_x_min < b_x_max && b_x_min < a_x_max) &&\n        (a_y_min < b_y_max && b_y_min < a_y_max) &&\n        (a_z_min < b_z_max && b_z_min < a_z_max)) {\n        return true\n    }\n    return false;\n}\n\n// returns true if the two objects are intersecting\nexport function checkCollision(a: any, b: any): boolean {\n    if (a instanceof Box && b instanceof Box) {\n        return checkCollisionBoxes(a, b);\n    } else if (a instanceof Box && b instanceof Sphere) {\n        return checkCollisionBoxAndSphere(a, b);\n    } else if (a instanceof Box && b instanceof Plane) {\n        return checkCollisionBoxAndPlane(a, b);\n    } else if (a instanceof Sphere && b instanceof Box) {\n        return checkCollisionBoxAndSphere(b, a);\n    } else if (a instanceof Sphere && b instanceof Sphere) {\n        return checkCollisionSpheres(a, b);\n    } else if (a instanceof Sphere && b instanceof Plane) {\n        return checkCollisionSphereAndPlane(a, b);\n    } else if (a instanceof Plane && b instanceof Box) {\n        return checkCollisionBoxAndPlane(b, a);\n    } else if (a instanceof Plane && b instanceof Sphere) {\n        return checkCollisionSphereAndPlane(b, a);\n    } else {\n        console.error(\"checking collision between these types not implemented.\");\n    }\n}\n\nexport function checkCollisionBoxes(a: Box, b: Box): boolean {\n    // two convex objects don't collide iff there exists a separating plane between them\n\n    // search for separating plane.\n    // either its contain a face of one polyhedra or it contains an edge of one polyhedra and is parallel to the edge of the other polyhedra.\n\n    const a_coordinateAxes = getCoordinateAxes(a);\n    const b_coordinateAxes = getCoordinateAxes(b);\n\n    // check the 6 face axes\n    for (let faceAxis of a_coordinateAxes) {\n        if (separatingAxisPenetration(a, b, faceAxis) < 0) {\n            return false;\n        }\n    }\n    for (let faceAxis of b_coordinateAxes) {\n        if (separatingAxisPenetration(a, b, faceAxis) < 0) {\n            return false;\n        }\n    }\n\n    // check the 9 edge-edge axes\n    for (let a_axis of a_coordinateAxes) {\n        for (let b_axis of b_coordinateAxes) {\n            let m = a_axis.clone().cross(b_axis).normalize();\n            if (m.length() > 0) { // note to self: should use epsilon when checking for zero vector to  improve stability\n                if (separatingAxisPenetration(a, b, m) < 0) {\n                    return false;\n                }\n            } else {\n                // for now, ignore case where the corresponding edges are parallel.\n                continue;\n            }\n        }\n    }\n\n    return true;\n}\n\nexport function checkCollisionSpheres(a: Sphere, b: Sphere): boolean {\n    // two spheres intersect if the distance between their centers is not greater than the sum of their radii\n    const d = a.position.clone().sub(b.position).length();\n    return d <= a.radius + b.radius;\n}\n\nexport function checkCollisionSphereAndPlane(sphere: Sphere, plane: Plane) {\n    const relativePosition = sphere.position.clone().sub(plane.position);\n    const d = relativePosition.dot(plane.normal); // distance to center of sphere, negative if center is below plane.\n    return d <= sphere.radius;\n}\n\nexport function checkCollisionBoxAndSphere(box: Box, sphere: Sphere): boolean {\n    // convert sphere center to box coordinate space\n    const inverseRotation = box.rotation.clone();\n    let sphereCenter = sphere.position.clone().sub(box.position).applyQuaternion(inverseRotation);\n\n    // Clamp each coordinate to the box.\n    const closestPoint = sphereCenter.clone();\n    closestPoint.x = Math.max(Math.min(closestPoint.x, box.width/2), -box.width/2);\n    closestPoint.y = Math.max(Math.min(closestPoint.y, box.length/2), -box.length/2);\n    closestPoint.z = Math.max(Math.min(closestPoint.z, box.height/2), -box.height/2);\n\n    // check if they're in contact\n    const distance = sphereCenter.clone().sub(closestPoint).length();\n    return distance < sphere.radius;\n}\n\nexport function checkCollisionBoxAndPlane(box: Box, plane: Plane): boolean {\n    const vertices = getVertices(box);\n    for (let v of vertices) {\n        const relative_position = v.clone().sub(plane.position);\n        const d = relative_position.dot(plane.normal);\n        if (d < 0) {\n            return true;\n        }\n    }\n    return false;\n}\n\nexport function getAllContacts(boundingBoxIntersections: any[]) {\n    const contacts = [];\n    for(let i = 0; i < boundingBoxIntersections.length; i++) {\n        const a = boundingBoxIntersections[i].a;\n        const b = boundingBoxIntersections[i].b;\n\n        // check for collisions and color them\n        if (checkCollision(a, b)) {\n            const contact = getContactData(a, b);\n            contacts.push(contact);\n        }\n    }\n\n    return contacts;\n}\n\nexport function getContactData(a: any, b: any) {\n    if (a instanceof Box && b instanceof Box) {\n        return getContactDataBoxes(a, b);\n    } else if (a instanceof Box && b instanceof Sphere) {\n        return getContactDataBoxAndSphere(a, b);\n    } else if (a instanceof Box && b instanceof Plane) {\n        return getContactDataBoxAndPlane(a, b);\n    } else if (a instanceof Sphere && b instanceof Box) {\n        return getContactDataBoxAndSphere(b, a);\n    } else if (a instanceof Sphere && b instanceof Sphere) {\n        return getContactDataSpheres(a, b);\n    } else if (a instanceof Sphere && b instanceof Plane) {\n        return getContactDataSphereAndPlane(a, b);\n    } else if (a instanceof Plane && b instanceof Box) {\n        return getContactDataBoxAndPlane(b, a);\n    } else if (a instanceof Plane && b instanceof Sphere) {\n        return getContactDataSphereAndPlane(b, a);\n    } else {\n        console.error(\"getting contact data between these types not implemented.\");\n        return {\n            a: a,\n            b: b,\n            type: \"none\",\n            contactNormal: new Vector3(0, 0, 1),\n            penetration: 0,\n            contactPoint: new Vector3(0, 0, 0),\n            edge_a: { a: new Vector3(0, 0, 0), b: new Vector3(0, 0, 0) },\n            edge_b: { a: new Vector3(0, 0, 0), b: new Vector3(0, 0, 0) }\n        };\n    }\n}\n\n// note: all getContact functions assume the objects already intersect.\n\n// convention: contact data is of format {a, b, type, contactNormal, penetration, contactPoint, ...} where contactNormal points from b to a\n// get contact data for two colliding boxes, assuming collision\nfunction getContactDataBoxes(a: Box, b: Box) {\n    const vector_ab = b.position.clone().sub(a.position);\n    const a_coordinateAxes = getCoordinateAxes(a);\n    const b_coordinateAxes = getCoordinateAxes(b);\n    let smallestOverlap = Infinity;\n    let contact;\n\n    for (let a_axis of a_coordinateAxes) {\n        const overlap = separatingAxisPenetration(a, b, a_axis);\n        if (overlap < smallestOverlap) {\n            smallestOverlap = overlap;\n\n            // set contact\n            const axis = a_axis.clone();\n            if (vector_ab.dot(axis) < 0) { // orient axis to normal of the correct face.\n                axis.multiplyScalar(-1);\n            }\n            axis.normalize();\n            const vertex = getClosestVertex(a, b, axis);\n            contact = {\n                a: b,\n                b: a,\n                type: \"vertex-face\",\n                contactNormal: axis,\n                penetration: smallestOverlap,\n                contactPoint: vertex,\n                edge_a: { a: new Vector3(0, 0, 0), b: new Vector3(0, 0, 0) },\n                edge_b: { a: new Vector3(0, 0, 0), b: new Vector3(0, 0, 0) }\n            };\n        }\n    }\n    for (let b_axis of b_coordinateAxes) {\n        const overlap = separatingAxisPenetration(a, b, b_axis);\n        if (overlap < smallestOverlap) {\n            smallestOverlap = overlap;\n\n            // set contact\n            const axis = b_axis.clone();\n            if (vector_ab.clone().dot(axis) > 0) { // orient axis to normal of the correct face.\n                axis.multiplyScalar(-1);\n            }\n            axis.normalize();\n            const vertex = getClosestVertex(b, a, axis);\n            contact = {\n                a: a,\n                b: b, \n                type: \"vertex-face\",\n                contactNormal: axis,\n                penetration: smallestOverlap,\n                contactPoint: vertex,\n                edge_a: { a: new Vector3(0, 0, 0), b: new Vector3(0, 0, 0) },\n                edge_b: { a: new Vector3(0, 0, 0), b: new Vector3(0, 0, 0) }\n            };\n        }\n    }\n\n    for (let a_axis of a_coordinateAxes) {\n        for (let b_axis of b_coordinateAxes) {\n            let m = a_axis.clone().cross(b_axis).normalize();\n            if (m.length() > 0.005) { // check parallel edges\n                const overlap = separatingAxisPenetration(a, b, m);\n\n                if (overlap < smallestOverlap) {\n                    smallestOverlap = overlap;\n\n                    // set contact\n                    const axis = m.clone();\n                    if (vector_ab.clone().dot(axis) > 0) {\n                        axis.multiplyScalar(-1);\n                    }\n                    axis.normalize();\n                    const edge_a = getClosestEdge(b, a, a_axis, m);\n                    const edge_b = getClosestEdge(a, b, b_axis, m);\n                    contact = {\n                        a: a,\n                        b: b,\n                        type: \"edge-edge\",\n                        contactNormal: axis,\n                        penetration: smallestOverlap,\n                        contactPoint: getClosestPointBetweenTwoEdges(edge_a, edge_b),\n                        edge_a: edge_a,\n                        edge_b: edge_b\n                    };\n                }\n            } else {\n                // for now, ignore case where the corresponding edges are parallel.\n                continue;\n            }\n        }\n    }\n    \n    return contact;\n}\n\nfunction getContactDataBoxAndSphere(box: Box, sphere: Sphere) {\n    // convert sphere center to box coordinate space\n    const inverseRotation = box.rotation.clone();\n    let sphereCenter = sphere.position.clone().sub(box.position).applyQuaternion(inverseRotation);\n\n    // Clamp each coordinate to the box.\n    let closestPoint = sphereCenter.clone();\n    closestPoint.x = Math.max(Math.min(closestPoint.x, box.width/2), -box.width/2);\n    closestPoint.y = Math.max(Math.min(closestPoint.y, box.length/2), -box.length/2);\n    closestPoint.z = Math.max(Math.min(closestPoint.z, box.height/2), -box.height/2);\n\n    const distance = sphereCenter.clone().sub(closestPoint).length();\n    const penetration = sphere.radius - distance;\n\n    // convert back to world space\n    closestPoint.applyQuaternion(box.rotation).add(box.position);\n\n    const contactPoint = closestPoint;\n    const contactNormal = closestPoint.clone().sub(sphere.position.clone()).normalize();\n\n    const contact = {\n        a: box,\n        b: sphere,\n        type: \"vertex-face\",\n        contactNormal: contactNormal,\n        penetration: penetration,\n        contactPoint: contactPoint,\n        edge_a: { a: new Vector3(0, 0, 0), b: new Vector3(0, 0, 0) },\n        edge_b: { a: new Vector3(0, 0, 0), b: new Vector3(0, 0, 0) }\n    }\n    return contact;\n}\n\nfunction getContactDataSpheres(a: Sphere, b: Sphere) {\n    const v_ab = b.position.clone().sub(a.position);\n    const contactPoint = a.position.clone().add(v_ab.clone().multiplyScalar(a.radius).sub(v_ab.clone().multiplyScalar(b.radius)).multiplyScalar(0.5));\n    const penetration = a.radius - b.radius - v_ab.length()\n    const contactNormal = v_ab.clone().multiplyScalar(-1).normalize();\n    const contact = {\n        a: a,\n        b: b,\n        type: \"vertex-face\",\n        contactNormal: contactNormal,\n        penetration: penetration,\n        contactPoint: contactPoint,\n        edge_a: { a: new Vector3(0, 0, 0), b: new Vector3(0, 0, 0) },\n        edge_b: { a: new Vector3(0, 0, 0), b: new Vector3(0, 0, 0) }\n    }\n    return contact;\n}\n\nfunction getContactDataBoxAndPlane(box: Box, plane: Plane) {\n    const vertices = getVertices(box);\n    let contactPoint = vertices[0];\n    let penetration = 0;\n    \n    for (let v of vertices) {\n        const relative_position = v.clone().sub(plane.position);\n        const d = relative_position.dot(plane.normal);\n        if (d < penetration) {\n            contactPoint = v;\n            penetration = d;\n        }\n    }\n\n    const contact = {\n        a: box,\n        b: plane,\n        type: \"vertex-face\",\n        contactNormal: plane.normal.clone(),\n        penetration: penetration,\n        contactPoint: contactPoint,\n        edge_a: { a: new Vector3(0, 0, 0), b: new Vector3(0, 0, 0) },\n        edge_b: { a: new Vector3(0, 0, 0), b: new Vector3(0, 0, 0) }\n    };\n    return contact;\n}\n\nfunction getContactDataSphereAndPlane(sphere: Sphere, plane: Plane) {\n    const relativePosition = sphere.position.clone().sub(plane.position);\n    const d = relativePosition.dot(plane.normal); // distance to center of sphere, negative if center is below plane.\n    const penetration = sphere.radius - d;\n\n    const contactPoint = sphere.position.clone().addScaledVector(plane.normal, -sphere.radius);\n\n    const contact = {\n        a: sphere,\n        b: plane,\n        type: \"vertex-face\",\n        contactNormal: plane.normal.clone(),\n        penetration: penetration,\n        contactPoint: contactPoint,\n        edge_a: { a: new Vector3(0, 0, 0), b: new Vector3(0, 0, 0) },\n        edge_b: { a: new Vector3(0, 0, 0), b: new Vector3(0, 0, 0) }\n    };\n    return contact;\n}\n\nconst coefficient_of_restitution = 0.8;\nexport function resolveCollision(contactData: any) {\n    const a = contactData.a;\n    const b = contactData.b;\n    const normal = contactData.contactNormal;\n    if (contactData.type === \"vertex-face\") {\n        console.log(\"resolving vertex-face contact\");\n        const vertex = contactData.contactPoint;\n        const r_a = vertex.clone().sub(a.position);\n        const r_b = vertex.clone().sub(b.position);\n        const vertexVelocity_a = a.velocity.clone().add(a.getAngularVelocity().cross(r_a));\n        const vertexVelocity_b = b.velocity.clone().add(b.getAngularVelocity().cross(r_b));\n        const relativeVelocity = normal.dot(vertexVelocity_a.clone().sub(vertexVelocity_b));\n        if (relativeVelocity < 0) {\n            console.log(\"colliding contact\");\n            \n            const I_inverse_a = a.getInertia().invert();\n            const I_inverse_b = b.getInertia().invert();\n\n            const term1 = normal.dot(r_a.clone().cross(normal).applyMatrix3(I_inverse_a).cross(r_a));\n            const term2 = normal.dot(r_b.clone().cross(normal).applyMatrix3(I_inverse_b).cross(r_b));\n\n            const j = -(1 + coefficient_of_restitution) * relativeVelocity / (a.inverseMass + b.inverseMass + term1 + term2);\n            console.log(\"relative Velocity: \", relativeVelocity);\n\n            const impulse = normal.clone().multiplyScalar(j);\n            const impulse2 = normal.clone().multiplyScalar(-j);\n            a.applyImpulse(vertex, impulse);\n            b.applyImpulse(vertex, impulse2);\n        } else if (relativeVelocity === 0) {\n            console.log(\"resting contact\");\n        } else {\n            // ignore\n            console.log(\"leaving\");\n        }\n    } else if (contactData.type === \"edge-edge\") {\n        console.log(\"resolving edge-edge contact\");\n        console.log(\"edge_a\", contactData.edge_a);\n        console.log(\"edge_b\", contactData.edge_b);\n        console.log(\"contactNormal: \", contactData.contactNormal);\n\n        const vertex = getClosestPointBetweenTwoEdges(contactData.edge_a, contactData.edge_b);\n        const r_a = vertex.clone().sub(a.position);\n        const r_b = vertex.clone().sub(b.position);\n        const vertexVelocity_a = a.velocity.clone().add(a.getAngularVelocity().cross(r_a));\n        const vertexVelocity_b = b.velocity.clone().add(b.getAngularVelocity().cross(r_b));\n        const relativeVelocity = normal.dot(vertexVelocity_a.clone().sub(vertexVelocity_b));\n        if (relativeVelocity < 0) {\n            console.log(\"colliding contact\");\n            \n            const I_inverse_a = a.getInertia().invert();\n            let I_inverse_b = b.getInertia().invert();\n\n            const term1 = normal.dot(r_a.clone().cross(normal).applyMatrix3(I_inverse_a).cross(r_a));\n            const term2 = normal.dot(r_b.clone().cross(normal).applyMatrix3(I_inverse_b).cross(r_b));\n\n            const j = -(1 + coefficient_of_restitution) * relativeVelocity / (a.inverseMass + b.inverseMass + term1 + term2);\n\n            const impulse = normal.clone().multiplyScalar(j);\n            const impulse2 = normal.clone().multiplyScalar(-j);\n            a.applyImpulse(vertex, impulse);\n            b.applyImpulse(vertex, impulse2);\n        } else if (relativeVelocity === 0) {\n            console.log(\"resting contact\");\n        } else {\n            // ignore\n            console.log(\"leaving\");\n        }\n    } else {\n        console.error(\"contactData type not recognized.\");\n        console.log(\"contact data: \", contactData);\n    }\n}\n\n// returns closest edge of box b\n// edge should be parallel to input edgeVector\nfunction getClosestEdge(a: Box, b: Box, edgeVector: Vector3, separatingAxis: Vector3) {\n    const x = separatingAxis.x;\n    const y = separatingAxis.y;\n    const z = separatingAxis.z;\n    const projectionMatrix = new Matrix3();\n    projectionMatrix.set(\n        x*x, x*y, x*z,\n        x*y, y*y, y*z,\n        x*z, y*z, z*z\n    );\n\n    const a_center = a.position.clone().applyMatrix3(projectionMatrix);\n\n    const b_edges = getEdges(b);\n    const parallel_b_edges = [];\n    for (let b_edge of b_edges) {\n        const b_edgeVector = b_edge.b.clone().sub(b_edge.a);\n        if (b_edgeVector.clone().cross(edgeVector).length() < 0.005) {\n            parallel_b_edges.push(b_edge);\n        }\n    }\n\n    let closestEdge = parallel_b_edges[0];\n    let closestDistance = closestEdge.a.clone().sub(a_center).length();\n    for (let b_edge of parallel_b_edges) {\n        const d = b_edge.a.clone().sub(a_center).length();\n        if (d < closestDistance) {\n            closestDistance = d;\n            closestEdge = b_edge;\n        }\n    }\n\n    return closestEdge;\n}\n\n// returns closest vertex of box b to face of box a\nfunction getClosestVertex(a: Box, b: Box, lineVector: Vector3): Vector3 {\n    const a_vertices = getVertices(a);\n    const b_vertices = getVertices(b);\n\n    const x = lineVector.x;\n    const y = lineVector.y;\n    const z = lineVector.z;\n    const projectionMatrix = new Matrix3();\n    projectionMatrix.set(\n        x*x, x*y, x*z,\n        x*y, y*y, y*z,\n        x*z, y*z, z*z\n    );\n\n    const a_center = a.position.clone().applyMatrix3(projectionMatrix);\n\n    let a_radius = 0;\n\n    for (let a_v of a_vertices) {\n        const a_v_projection = a_v.clone().applyMatrix3(projectionMatrix);\n        const r = a_v_projection.clone().sub(a_center).length();\n        if (r > a_radius) {\n            a_radius = r;\n        }\n    }\n\n    const b_center = b.position.clone().applyMatrix3(projectionMatrix);\n    let vertex = b_vertices[0];\n    let smallestDistanceToA = b_center.clone().sub(a_center).length() - a_radius;\n\n    for (let b_v of b_vertices) {\n        const b_v_projection = b_v.clone().applyMatrix3(projectionMatrix);\n        const d = b_v_projection.clone().sub(a_center).length() - a_radius;\n        if (d < smallestDistanceToA) {\n            smallestDistanceToA = d;\n            vertex = b_v;\n        }\n    }\n\n    return vertex;\n}\n\nfunction separatingAxisPenetration(a: Box, b: Box, lineVector: Vector3): number {\n    const x = lineVector.x;\n    const y = lineVector.y;\n    const z = lineVector.z;\n    const projectionMatrix = new Matrix3();\n    projectionMatrix.set(\n        x*x, x*y, x*z,\n        x*y, y*y, y*z,\n        x*z, y*z, z*z\n    );\n\n    const a_center = a.position.clone().applyMatrix3(projectionMatrix);\n    const b_center = b.position.clone().applyMatrix3(projectionMatrix);\n    const d = b_center.clone().sub(a_center).length();\n\n    const a_vertices = getVertices(a);\n    const b_vertices = getVertices(b);\n\n    let r_a = 0, r_b = 0;\n    for (let a_v of a_vertices) {\n        const a_v_projection = a_v.applyMatrix3(projectionMatrix);\n        const r = a_center.clone().sub(a_v_projection).length()\n        if (r > r_a) {\n            r_a = r;\n        }\n    }\n    for (let b_v of b_vertices) {\n        const b_v_projection = b_v.applyMatrix3(projectionMatrix);\n        const r = b_center.clone().sub(b_v_projection).length()\n        if (r > r_b) {\n            r_b = r;\n        }\n    }\n\n    // returns the overlap. positive indicates overlap, negative indicates separation.\n    return r_a + r_b - d;\n}\n\nfunction getClosestPointBetweenTwoEdges(e1: any, e2: any) {\n    const p1 = e1.a;\n    const p2 = e1.b;\n    const p3 = e2.a;\n    const p4 = e2.b;\n\n    const v12 = p2.clone().sub(p1);\n    const v34 = p4.clone().sub(p3);\n    const v13 = p3.clone().sub(p1);\n\n    let s, t;\n\n    // terms\n    const R_1_squared = v12.dot(v12);\n    const R_2_squared = v34.dot(v34);\n    const D_4321 = v12.dot(v34);\n    const D_3121 = v12.dot(v13);\n    const D_4331 = v13.dot(v34);\n    const denominator = D_4321*D_4321 - R_1_squared*R_2_squared;\n\n    s = (D_4321*D_4331 - R_2_squared*D_3121) / denominator;\n    t = (R_1_squared*D_4331 - D_4321*D_3121) / denominator;\n\n    s = Math.max(Math.min(s, 1), 0);\n    t = Math.max(Math.min(t, 1), 0);\n\n    const point_a = e1.a.clone().add(v12.clone().multiplyScalar(s));\n    const point_b = e2.a.clone().add(v34.clone().multiplyScalar(t));\n\n    return point_a.clone().add(point_b).multiplyScalar(1/2);\n}\n\nfunction getCoordinateAxes(box: Box) {\n    const x = new Vector3(1, 0, 0), y = new Vector3(0, 1, 0), z = new Vector3(0, 0, 1);\n\n    const axes = [x, y, z];\n\n    for (let axis of axes) {\n        axis.applyQuaternion(box.rotation);\n    }\n    return axes;\n}\n\nfunction getVertices(box: Box) {\n    const x = box.position.x;\n    const y = box.position.y;\n    const z = box.position.z;\n    const v1 = new Vector3(x - box.width/2, y - box.length/2, z - box.height/2);\n    const v2 = new Vector3(x - box.width/2, y + box.length/2, z - box.height/2);\n    const v3 = new Vector3(x + box.width/2, y + box.length/2, z - box.height/2);\n    const v4 = new Vector3(x + box.width/2, y - box.length/2, z - box.height/2);\n    const v5 = new Vector3(x - box.width/2, y - box.length/2, z + box.height/2);\n    const v6 = new Vector3(x - box.width/2, y + box.length/2, z + box.height/2);\n    const v7 = new Vector3(x + box.width/2, y + box.length/2, z + box.height/2);\n    const v8 = new Vector3(x + box.width/2, y - box.length/2, z + box.height/2);\n    const vertices = [v1, v2, v3, v4, v5, v6, v7, v8];\n\n    // rotate vertices\n    for (let vertex of vertices) {\n        // convert to body space, apply rotation, convert back to world space\n        vertex.sub(box.position);\n        vertex.applyQuaternion(box.rotation);\n        vertex.add(box.position);\n    }\n\n    return vertices;\n}\n\nfunction getEdges(box: Box) {\n    const x = box.position.x;\n    const y = box.position.y;\n    const z = box.position.z;\n    const v1 = new Vector3(x - box.width/2, y - box.length/2, z - box.height/2);\n    const v2 = new Vector3(x - box.width/2, y + box.length/2, z - box.height/2);\n    const v3 = new Vector3(x + box.width/2, y + box.length/2, z - box.height/2);\n    const v4 = new Vector3(x + box.width/2, y - box.length/2, z - box.height/2);\n    const v5 = new Vector3(x - box.width/2, y - box.length/2, z + box.height/2);\n    const v6 = new Vector3(x - box.width/2, y + box.length/2, z + box.height/2);\n    const v7 = new Vector3(x + box.width/2, y + box.length/2, z + box.height/2);\n    const v8 = new Vector3(x + box.width/2, y - box.length/2, z + box.height/2);\n    const vertices = [v1, v2, v3, v4, v5, v6, v7, v8];\n\n    // rotate vertices\n    for (let vertex of vertices) {\n        // convert to body space, apply rotation, convert back to world space\n        vertex.sub(box.position);\n        vertex.applyQuaternion(box.rotation);\n        vertex.add(box.position);\n    }\n\n    const edges = [];\n    edges.push({a: v1, b: v2});\n    edges.push({a: v1, b: v4});\n    edges.push({a: v1, b: v5});\n    edges.push({a: v2, b: v3});\n    edges.push({a: v2, b: v6});\n    edges.push({a: v3, b: v4});\n    edges.push({a: v3, b: v7});\n    edges.push({a: v4, b: v8});\n    edges.push({a: v5, b: v6});\n    edges.push({a: v5, b: v8});\n    edges.push({a: v6, b: v7});\n    edges.push({a: v7, b: v8});\n\n    return edges;\n}\n\nexport function getAllBoundingBoxIntersections(objects: any[]) {\n    // for now just sort against x-axis. Slightly better is to update axis based on one with highest variance\n    // worst case is still O(n^2)\n\n    function compareBoundingBoxes(a: any, b: any) {\n        const a_min = a.position.x - a.boundingBox.x/2;\n        const b_min = b.position.x - b.boundingBox.x/2;\n        return a_min - b_min;\n    }\n\n    // sort objects along x-axis\n    const objectsCopy = [...objects];\n    objectsCopy.sort(compareBoundingBoxes);\n\n    // sweep the array for collisions\n    const intersections = [];\n    for(let i = 0; i < objectsCopy.length - 1; i++) {\n        // test against all possible overlapping boxes following the current one.\n        for(let j = i + 1; j < objectsCopy.length; j++) {\n            // stop testing when AABBs are beyond the current AABB\n            const i_max = objectsCopy[i].position.x + objectsCopy[i].boundingBox.x/2;\n            const j_min = objectsCopy[j].position.x - objectsCopy[j].boundingBox.x/2;\n            if (j_min > i_max) {\n                break;\n            }\n\n            if (checkBoundingBoxIntersection(objectsCopy[i], objectsCopy[j])) {\n                intersections.push({\n                    a: objectsCopy[i],\n                    b: objectsCopy[j]\n                });\n            }\n        }\n    }\n    return intersections;\n}\n\n/**\n * for symmetrical objects, valid separating axis iff sum the radii (half_widths) of the projected intervals is less than the distance between the centers\n * @param a \n * @param b \n * @param lineVector a unit vector describing the direction of the line\n * @returns true if the lineVector is a separating axis\n */\n/*export function testSeparatingAxis(a: Box, b: Box, lineVector: Vector3): boolean {\n    const x = lineVector.x;\n    const y = lineVector.y;\n    const z = lineVector.z;\n    const projectionMatrix = new Matrix3();\n    projectionMatrix.set(\n        x*x, x*y, x*z,\n        x*y, y*y, y*z,\n        x*z, y*z, z*z\n    );\n\n    const a_center = a.position.clone().applyMatrix3(projectionMatrix);\n    const b_center = b.position.clone().applyMatrix3(projectionMatrix);\n    const d = b_center.clone().sub(a_center).length();\n\n    const a_vertices = getVertices(a);\n    const b_vertices = getVertices(b);\n    \n    let r_a = 0, r_b = 0;\n    for (let a_v of a_vertices) {\n        const a_v_projection = a_v.applyMatrix3(projectionMatrix);\n        const r = a_center.clone().sub(a_v_projection).length()\n        if (r > r_a) {\n            r_a = r;\n        }\n    }\n    for (let b_v of b_vertices) {\n        const b_v_projection = b_v.applyMatrix3(projectionMatrix);\n        const r = b_center.clone().sub(b_v_projection).length()\n        if (r > r_b) {\n            r_b = r;\n        }\n    }\n    if (r_a + r_b < d) {\n        return true;\n    }\n\n    return false;\n}*/\n\n/*\nexport function checkCollisionBoxes(a: Box, b: Box): boolean {\n    // two convex objects don't collide iff there exists a separating plane between them\n\n    // search for separating plane.\n    // either its contain a face of one polyhedra or it contains an edge of one polyhedra and is parallel to the edge of the other polyhedra.\n    \n    const a_facePlanes = getFacePlanes(a);\n    for (let facePlane of a_facePlanes) {\n        if (testSeparatingAxis(a, b, facePlane.normal)) {\n            return false;\n        };\n    }\n    const b_facePlanes = getFacePlanes(b);\n    for (let facePlane of b_facePlanes) {\n        if (testSeparatingAxis(a, b, facePlane.normal)) {\n            return false;\n        }\n    }\n\n    const a_edges = getEdges(a);\n    const b_edges = getEdges(b);\n\n    for (let i = 0; i < a_edges.length; i++) {\n        for (let j = 0; j < b_edges.length; j++) {\n            const edge_i = a_edges[i].b.clone().sub(a_edges[i].a);\n            const edge_j = b_edges[j].b.clone().sub(b_edges[j].a);\n            let m = edge_i.clone().cross(edge_j);\n            if (m.length() !== 0) { // note to self: should use epsilon when checking for zero vector to improve stability\n                if (testSeparatingAxis(a, b, m)) {\n                    return false;\n                }\n            } else {\n                const edge_n = b_edges[j].b.clone().sub(a_edges[i].a);\n                m = edge_i.clone().cross(edge_n);\n                if (m.length() !== 0) {\n                    testSeparatingAxis(a, b, m);\n                } else {\n                    return true; // since edge_i and edge_2 are colinear\n                }\n            }\n        }\n    }\n\n    return true;\n}*/\n\n/*\nfunction getFaces(box: Box) {\n    const x = box.position.x;\n    const y = box.position.y;\n    const z = box.position.z;\n    const v1 = new Vector3(x - box.width/2, y - box.length/2, z - box.height/2);\n    const v2 = new Vector3(x - box.width/2, y + box.length/2, z - box.height/2);\n    const v3 = new Vector3(x + box.width/2, y + box.length/2, z - box.height/2);\n    const v4 = new Vector3(x + box.width/2, y - box.length/2, z - box.height/2);\n    const v5 = new Vector3(x - box.width/2, y - box.length/2, z + box.height/2);\n    const v6 = new Vector3(x - box.width/2, y + box.length/2, z + box.height/2);\n    const v7 = new Vector3(x + box.width/2, y + box.length/2, z + box.height/2);\n    const v8 = new Vector3(x + box.width/2, y - box.length/2, z + box.height/2);\n    const vertices = [v1, v2, v3, v4, v5, v6, v7, v8];\n\n    // rotate vertices\n    for (let vertex of vertices) {\n        // convert to body space, apply rotation, convert back to world space\n        vertex.sub(box.position);\n        vertex.applyQuaternion(box.rotation);\n        vertex.add(box.position);\n    }\n    \n    const f1 = { edges: [{a: v1, b: v2}, {a: v1, b: v4}, {a: v2, b: v3}, {a: v3, b: v4}] }; // bottom\n    const f2 = { edges: [{a: v5, b: v6}, {a: v5, b: v8}, {a: v6, b: v7}, {a: v7, b: v8}] }; // top\n    const f3 = { edges: [{a: v1, b: v2}, {a: v1, b: v5}, {a: v5, b: v6}, {a: v6, b: v2}] }; // left\n    const f4 = { edges: [{a: v4, b: v8}, {a: v4, b: v3}, {a: v8, b: v7}, {a: v7, b: v3}] }; // right\n    const f5 = { edges: [{a: v1, b: v4}, {a: v1, b: v5}, {a: v5, b: v8}, {a: v8, b: v4}] }; // front\n    const f6 = { edges: [{a: v2, b: v3}, {a: v2, b: v6}, {a: v6, b: v7}, {a: v7, b: v3}] }; // back\n    const faces = [f1, f2, f3, f4, f5, f6];\n    return faces;\n}*/\n\n/*\nexport function getAllBoundingBoxIntersections(boxes: Box[]) {\n    // create and sort intervals along x, y, and z\n    const x_intervals = [];\n    const y_intervals = [];\n    const z_intervals = [];\n    for(let box of boxes) {\n        const x_min = box.position.x - box.boundingBox.x/2;\n        const x_max = box.position.x + box.boundingBox.x/2;\n        x_intervals.push({ type: \"min\", value: x_min, object: box});\n        x_intervals.push({ type: \"max\", value: x_max, object: box});\n\n        \n        const y_min = box.position.y - box.boundingBox.y/2;\n        const y_max = box.position.y + box.boundingBox.y/2;\n        y_intervals.push({ type: \"min\", value: y_min, object: box});\n        y_intervals.push({ type: \"max\", value: y_max, object: box});\n\n        const z_min = box.position.z - box.boundingBox.z/2;\n        const z_max = box.position.z + box.boundingBox.z/2;\n        z_intervals.push({ type: \"min\", value: z_min, object: box});\n        z_intervals.push({ type: \"max\", value: z_max, object: box});\n    }\n    // note to self: switch to insertion sort and use normal merge sort only during the initialization frame\n    x_intervals.sort((a, b) => a.value - b.value);\n    //y_intervals.sort((a, b) => a.value - b.value);\n    //z_intervals.sort((a, b) => a.value - b.value);\n\n    // create a list of active intervals\n    const activeIntervals = [];\n}*/\n\n/*\nexport class World2 {\n    private objects: any[] = [];\n    private currentLoopInterval: any = null;\n\n    private characterForce: Vector3;\n\n    constructor() {\n        this.objects = [];\n\n        this.characterForce = new Vector3(0, 0, 0);\n    }\n\n    startLoop(): void {\n        const currentInstance = this;\n\n        // stop current loop if it exits\n        this.stopCurrentLoop();\n\n        let lastTimeCalled = performance.now();\n        let fps = 0;\n        let times: any[] = [];\n\n        function step() {\n            // calculate fps\n            const now = performance.now();\n            while (times.length > 0 && times[0] <= now - 1000) {\n                times.shift();\n            }\n            times.push(now);\n            fps = times.length;\n            // console.log(\"fps: \", fps);\n\n            for (let i = 0; i < currentInstance.objects.length; i++) {\n                currentInstance.objects[i].integrate(dt);\n            }\n        }\n\n        this.currentLoopInterval = setInterval(step, dt * 1000);\n    }\n\n    // Stops current loop if it exists.\n    stopCurrentLoop(): void {\n        if (this.currentLoopInterval) {\n            clearInterval(this.currentLoopInterval);\n        }\n    }\n\n    addObject(obj: any): void {\n        this.objects.push(obj);\n    }\n\n    getObjects(): any[] {\n        return this.objects;\n    }\n\n    updateCharacterForce(f: Vector3) {\n        this.characterForce = f;\n    }\n\n    detectCollisions(): void {\n\n    }\n\n    checkCollisionSpheres(s1: Sphere, s2: Sphere) {\n        const d = (s1.position.clone().sub(s2.position)).length(); // distance between centers\n\n        // collision if distance between spheres is smaller than sub of radiuses\n        if (d < (s1.radius + s2.radius)) {\n            return true;\n        }\n        return false;\n    }\n\n    resolveCollisionSpheres(s1: Sphere, s2: Sphere) {\n        // find unit vectors from s1 to s2 and s2 to s1\n        const u12 = (s2.position.clone().sub(s1.position)).normalize();\n        const u21 = u12.clone().multiplyScalar(-1);\n\n        // find components of v1 and v2 along and perpendicular to u\n        const v1_along_u12 = u12.clone().multiplyScalar(u12.dot(s1.velocity));\n        const v2_along_u21 = u21.clone().multiplyScalar(u21.dot(s2.velocity));\n\n        const v1_perp_u12 = s1.velocity.clone().sub(v1_along_u12);\n        const v2_perp_u21 = s2.velocity.clone().sub(v2_along_u21);\n\n        // calculate new velocities along u, assuming elastic collision\n        const m1 = 1/s1.inverseMass;\n        const m2 = 1/s2.inverseMass;\n        const v1_along_u_new = (v1_along_u12.clone().multiplyScalar((m1-m2)/(m1+m2))).addScaledVector(v2_along_u21, (2*m2)/(m1+m2));\n        const v2_along_u_new = (v1_along_u12.clone().multiplyScalar((2*m1)/(m1+m2))).addScaledVector(v2_along_u21, -(m1-m2)/(m1+m2));\n\n        // calculate and set new velocities\n        const v1_new = v1_along_u_new.clone().add(v1_perp_u12);\n        const v2_new = v2_along_u_new.clone().add(v2_perp_u21);\n\n        console.log(\"u: \", u12);\n        console.log(\"v1_new: \", v1_new);\n        console.log(\"v2_new\", v2_new);\n    }\n\n    clearCurrentLoop(): void {\n        clearInterval(this.currentLoopInterval);\n    }\n}*/\n\n/*\nfunction getFacePlanes(box: Box) {\n    const x = box.position.x;\n    const y = box.position.y;\n    const z = box.position.z;\n    const v1 = new Vector3(x - box.width/2, y - box.length/2, z - box.height/2);\n    const v2 = new Vector3(x - box.width/2, y + box.length/2, z - box.height/2);\n    const v3 = new Vector3(x + box.width/2, y + box.length/2, z - box.height/2);\n    const v4 = new Vector3(x + box.width/2, y - box.length/2, z - box.height/2);\n    const v5 = new Vector3(x - box.width/2, y - box.length/2, z + box.height/2);\n    const v6 = new Vector3(x - box.width/2, y + box.length/2, z + box.height/2);\n    const v7 = new Vector3(x + box.width/2, y + box.length/2, z + box.height/2);\n    const v8 = new Vector3(x + box.width/2, y - box.length/2, z + box.height/2);\n    const vertices = [v1, v2, v3, v4, v5, v6, v7, v8];\n\n    // rotate vertices\n    for (let vertex of vertices) {\n        // convert to body space, apply rotation, convert back to world space\n        vertex.sub(box.position);\n        vertex.applyQuaternion(box.rotation);\n        vertex.add(box.position);\n    }\n    const face1 = { normal: ((v2.clone().sub(v1)).cross(v4.clone().sub(v1))).normalize(), point: v1 } // bottom plane\n    const face2 = { normal: ((v8.clone().sub(v5)).cross(v6.clone().sub(v5))).normalize(), point: v5 } // top plane\n    const face3 = { normal: ((v5.clone().sub(v1)).cross(v2.clone().sub(v1))).normalize(), point: v1 } // left plane\n    const face4 = { normal: ((v3.clone().sub(v4)).cross(v8.clone().sub(v4))).normalize(), point: v4 } // top plane\n    const face5 = { normal: ((v4.clone().sub(v1)).cross(v5.clone().sub(v1))).normalize(), point: v1 } // front plane\n    const face6 = { normal: ((v2.clone().sub(v3)).cross(v7.clone().sub(v3))).normalize(), point: v3 } // back plane\n    const facePlanes = [face1, face2, face3, face4, face5, face6];\n    return facePlanes;\n}*/","/Users/danny/Github/physics_engine_for_the_web/frontend/src/physics_engine/Sphere.ts",["74","75"],[],"import * as THREE from \"three\";\nimport { LineSegments, Matrix3, Mesh, Vector3 } from \"three\";\n\nconst DAMPING = 0.999;\n\n// should add rotation at some point?\nexport class Sphere {\n    public inverseMass: number;\n\n    public radius: number;\n    \n    public position: Vector3;\n    public velocity: Vector3;\n\n    // holds the accumulated force to be applied to the next simulation iteration only.\n    public forceAccum: Vector3;\n\n    public boundingBox: Vector3; // width, length, and height of bounding box\n\n    // for graphics\n    public mesh: Mesh;\n    public boundingBoxMesh: LineSegments;\n\n    constructor(position: Vector3, radius: number) {\n        this.inverseMass = 1 / (4/3*Math.PI*Math.pow(radius, 3));\n        this.radius = radius;\n\n        this.position = position;\n        this.velocity = new Vector3(0, 0, 0);\n\n        this.forceAccum = new Vector3(0, 0, 0);\n\n        this.boundingBox = new Vector3(2*radius, 2*radius, 2*radius);\n\n        // for graphics\n        this.createMesh();\n        this.updateMesh();\n        this.createBoundingBoxMesh();\n        this.updateBoundingBoxMesh();\n    }\n\n    getInertia(): Matrix3 {\n        const term = 2/5 * (1/this.inverseMass) * this.radius * this.radius;\n        const inertia = new Matrix3;\n        inertia.set(\n            term, 0, 0,\n            0, term, 0,\n            0, 0, term\n        );\n        return inertia;\n    }\n\n    getAngularVelocity(): Vector3 {\n        const angularVelocity = new Vector3(0, 0, 0);\n        return angularVelocity;\n    }\n\n    // update velocity based on forceAccum and clear forceAccum\n    integrateForceAccum(duration: number): void {\n        // Don't integrate if mass is infinite or duration <= 0.\n        if (this.inverseMass <= 0 || duration <= 0) {\n            return;\n        }\n\n        this.velocity.addScaledVector(this.forceAccum, duration*this.inverseMass);\n        this.clearAccumulator();\n    }\n\n    integrate(duration: number): void {\n        // Don't integrate if mass is infinite or duration <= 0.\n        if (this.inverseMass <= 0 || duration <= 0)\n            return;\n\n        // update velocity based on force and then clear forces\n        // this.velocity.addScaledVector(this.forceAccum, duration*this.inverseMass);\n        // this.clearAccumulator();\n\n        // update the linear position.\n        this.position.addScaledVector(this.velocity, duration);\n\n        // impose drag.\n        // this.velocity.multiplyScalar(Math.pow(DAMPING, duration));\n\n        // update the velocity from the acceleration.\n        // this.velocity.addScaledVector(this.acceleration, duration);\n    }\n\n    applyImpulse(point: Vector3, impulse: Vector3) {\n        this.velocity.add(impulse.clone().multiplyScalar(this.inverseMass));\n    }\n\n    // Clears the forces applied to the particle.\n    clearAccumulator(): void {\n        this.forceAccum = new Vector3(0, 0, 0);\n    }\n\n    private createMesh(): void {\n        const sphereGeometry = new THREE.SphereGeometry(this.radius);\n        const material = new THREE.MeshPhongMaterial({ color: 0x00bcd6 });\n        this.mesh = new THREE.Mesh(sphereGeometry, material);\n    }\n\n    // updates mesh to current position and orientation\n    updateMesh(): void {\n        this.mesh.position.set(this.position.x, this.position.y, this.position.z);\n    }\n\n    private createBoundingBoxMesh(): void {\n        const boxGeometry = new THREE.BoxGeometry(this.boundingBox.x, this.boundingBox.y, this.boundingBox.z);\n        const wireframe = new THREE.WireframeGeometry(boxGeometry);\n        this.boundingBoxMesh = new THREE.LineSegments( wireframe );\n        this.boundingBoxMesh.material = new THREE.LineBasicMaterial({ color: 0xffffff });\n    }\n\n    updateBoundingBoxMesh(): void {\n        this.boundingBoxMesh.position.set(this.position.x, this.position.y, this.position.z);\n    }\n}","/Users/danny/Github/physics_engine_for_the_web/frontend/src/physics_engine/Box.ts",["76","77","78","79"],[],"import * as THREE from \"three\";\nimport { Vector3, Matrix3, Quaternion, Mesh, LineSegments } from \"three\";\nimport { getVectorCrossMatrix, addMatrices, convertQuaternionToMatrix, addQuaternions, scaleQuaternion, getEulerAngles, printEulerAngles } from \"./math_library\";\n\nexport class Box {\n    public inverseMass: number;\n\n    public width: number;\n    public length: number;\n    public height: number;\n\n    public inertia_body: Matrix3; // inertia tensor in body space\n\n    public position: Vector3;\n    public velocity: Vector3;\n    // public momentum: Vector3;\n\n    public rotation: Quaternion // the orientation\n    public angularMomentum: Vector3;\n\n    // holds the accumulated force to be applied to the next simulation iteration only.\n    public forceAccum: Vector3;\n\n    public boundingBox: Vector3 // width, length, and height of the bounding box\n\n    // for graphics\n    public mesh: Mesh;\n    public boundingBoxMesh: LineSegments;\n\n    constructor(position: Vector3, width: number, length: number, height: number) {\n        this.inverseMass = 1 / (width * length * height);\n\n        this.width = width;\n        this.length = length;\n        this.height = height;\n\n        this.inertia_body = new Matrix3();\n        this.setInertia();\n        \n        this.position = position;\n        this.velocity = new Vector3(0, 0, 0);\n        // this.momentum = (new Vector3(1, 0, 0)).multiplyScalar(1/this.inverseMass);\n\n        this.rotation = new Quaternion(0, 0, 0, 1);\n        this.angularMomentum = new Vector3(0, 0, 0).applyMatrix3(this.getInertia());\n\n        this.forceAccum = new Vector3(0, 0, 0);\n\n        this.setBoundingBox();\n\n        // for graphics\n        this.createMesh();\n        this.updateMesh();\n        this.createBoundingBoxMesh();\n        this.updateBoundingBoxMesh();\n    }\n\n    private setInertia(): void {\n        const mass = 1 / this.inverseMass;\n        const I_xx = (1/12) * mass * (this.length*this.length + this.height*this.height);\n        const I_yy = (1/12) * mass * (this.width*this.width + this.height*this.height);\n        const I_zz = (1/12) * mass * (this.width*this.width + this.length*this.length);\n\n        this.inertia_body.set(\n            I_xx, 0, 0,\n            0, I_yy, 0,\n            0, 0, I_zz\n        );\n    }\n\n    getInertia(): Matrix3 {\n        const rotationMatrix = convertQuaternionToMatrix(this.rotation);\n        const inertia = rotationMatrix.clone().multiply(this.inertia_body).multiply(rotationMatrix.clone().transpose());\n        return inertia;\n    }\n\n    getI_inverse(): Matrix3 {\n        const I_body_inverse = this.inertia_body.clone().invert();\n        const rotationMatrix = convertQuaternionToMatrix(this.rotation);\n        const I_inverse = rotationMatrix.clone().multiply(I_body_inverse).multiply(rotationMatrix.clone().transpose());\n        return I_inverse;\n    }\n\n    getAngularVelocity(): Vector3 {\n        const I_inverse = this.getInertia().invert();\n        const angularVelocity = this.angularMomentum.clone().applyMatrix3(I_inverse);\n        return angularVelocity;\n    }\n\n    // update velocity based on forceAccum and clear forceAccum\n    integrateForceAccum(duration: number): void {\n        // Don't integrate if mass is infinite or duration <= 0.\n        if (this.inverseMass <= 0 || duration <= 0) {\n            return;\n        }\n\n        this.velocity.addScaledVector(this.forceAccum, duration*this.inverseMass);\n        this.clearAccumulator();\n    }\n\n    integrate(duration: number): void {\n        // Don't integrate if mass is infinite or duration <= 0.\n        if (this.inverseMass <= 0 || duration <= 0) {\n            return;\n        }\n\n        // update velocity based on force and then clear forces\n        // this.velocity.addScaledVector(this.forceAccum, duration*this.inverseMass);\n        // this.clearAccumulator();\n\n        // update position\n        this.position.addScaledVector(this.velocity, duration);\n\n        // this.position.addScaledVector(this.momentum, this.inverseMass * duration);\n\n        // update rotation\n        const angularVelocity = this.getAngularVelocity();\n\n        // ddt_q = (1/2) * w(t) * q(t)\n        const ddt_Rotation = (new Quaternion(angularVelocity.x/2, angularVelocity.y/2, angularVelocity.z/2, 0)).multiply(this.rotation);\n        this.rotation = addQuaternions(this.rotation, scaleQuaternion(ddt_Rotation, duration));\n        this.rotation.normalize();\n    }\n\n    // Clears the forces applied to the particle.\n    clearAccumulator(): void {\n        this.forceAccum = new Vector3(0, 0, 0);\n    }\n\n    applyImpulse(point: Vector3, impulse: Vector3) {\n        // const linearComponent = this.position.clone().sub(point).normalize().dot(impulse);\n        // const linearImpulse = this.position.clone().sub(point).normalize().multiplyScalar(linearComponent);\n        // this.velocity.addScaledVector(linearImpulse, this.inverseMass);\n        this.velocity.addScaledVector(impulse, this.inverseMass);\n        \n\n\n        const r = point.clone().sub(this.position);\n        /*\n        const angularUnitVector = impulse.clone().cross(this.position.sub(point)).cross(r).normalize();\n        const angularImpulse = angularUnitVector.clone().multiplyScalar(impulse.dot(angularUnitVector));*/\n        // this.angularMomentum.add(r.clone().cross(angularImpulse));\n        this.angularMomentum.add(r.clone().cross(impulse));\n    }\n\n    // for now, set to big enough bounding box so that we don't need to update it.\n    private setBoundingBox(): void {\n        const radius = Math.sqrt((this.width/2)*(this.width/2) + (this.length/2)*(this.length/2) + (this.height/2)*(this.height/2));\n        this.boundingBox = new Vector3(radius * 2, radius * 2, radius * 2);\n    };\n\n    private createMesh(): void {\n        const boxGeometry = new THREE.BoxGeometry(this.width, this.length, this.height);\n        const material = new THREE.MeshPhongMaterial({ color: 0x00bcd6 });\n        this.mesh = new THREE.Mesh(boxGeometry, material);\n    }\n\n    // updates mesh to current position and orientation\n    updateMesh(): void {\n        this.mesh.position.set(this.position.x, this.position.y, this.position.z);\n        this.mesh.setRotationFromQuaternion(this.rotation);\n    }\n\n    private createBoundingBoxMesh(): void {\n        const boxGeometry = new THREE.BoxGeometry(this.boundingBox.x, this.boundingBox.y, this.boundingBox.z);\n        const wireframe = new THREE.WireframeGeometry(boxGeometry);\n        this.boundingBoxMesh = new THREE.LineSegments( wireframe );\n        this.boundingBoxMesh.material = new THREE.LineBasicMaterial({ color: 0xffffff });\n    }\n\n    updateBoundingBoxMesh(): void {\n        this.boundingBoxMesh.position.set(this.position.x, this.position.y, this.position.z);\n    }\n}","/Users/danny/Github/physics_engine_for_the_web/frontend/src/physics_engine/math_library.ts",[],[],"/Users/danny/Github/physics_engine_for_the_web/frontend/src/physics_engine/Plane.ts",["80","81","82"],[],"import { LineSegments, Matrix3, Mesh, Quaternion, Vector3 } from \"three\";\nimport * as THREE from \"three\";\nimport { convertMatrix3ToMatrix4, getQuaternionRotatingV1ToV2, yRotationMatrix3 } from \"./math_library\";\n\nexport class Plane {\n    public position: Vector3;\n    public normal: Vector3; // should be normalized\n\n    public inverseMass: number;\n    public velocity: Vector3; // plane not implemented to actually move, this is just set to 0 to help the collision resolution\n\n    public width: number;\n    public length: number;\n\n    public boundingBox: Vector3;\n\n    // for graphics\n    public mesh: Mesh;\n    public boundingBoxMesh: LineSegments;\n\n    constructor(position: Vector3, normal: Vector3, width: number, length: number) {\n        this.position = position;\n        this.normal = normal;\n\n        this.inverseMass = 0;\n        this.velocity = new Vector3(0, 0, 0);\n\n        this.width = width;\n        this.length = length;\n\n        const r = Math.sqrt(width*width + length*length);\n        this.boundingBox = new Vector3(2*r, 2*r, 2*r);\n\n        this.createMesh();\n        this.createBoundingBoxMesh();\n    }\n\n    private createMesh(): void {\n        const planeGeometry = new THREE.PlaneGeometry(this.width, this.length);\n        const material = new THREE.MeshPhongMaterial({ color: 0xffcb3e });\n        this.mesh = new THREE.Mesh(planeGeometry, material);\n\n        // set orientation based on normal\n        const rotation = getQuaternionRotatingV1ToV2(new Vector3(0, 0, 1), this.normal);\n        this.mesh.setRotationFromQuaternion(rotation);\n\n        this.mesh.position.set(this.position.x, this.position.y, this.position.z);\n    }\n\n    private createBoundingBoxMesh(): void {\n        const boxGeometry = new THREE.BoxGeometry(this.boundingBox.x, this.boundingBox.y, this.boundingBox.z);\n        const wireframe = new THREE.WireframeGeometry(boxGeometry);\n        this.boundingBoxMesh = new THREE.LineSegments( wireframe );\n        this.boundingBoxMesh.material = new THREE.LineBasicMaterial({ color: 0xffffff });\n    }\n\n    // below are just functions written because they are called by the collision resolution step\n    getAngularVelocity(): Vector3 {\n        const angularVelocity = new Vector3(0, 0, 0);\n        return angularVelocity;\n    }\n\n    getInertia(): Matrix3 {\n        // set to zero matrix, so that the inverse is also the zero matrix when called by collision resolution function\n        const m = new Matrix3();\n        m.set(\n            0, 0, 0,\n            0, 0, 0,\n            0, 0, 0\n        );\n        return m;\n    }\n\n    applyImpulse(point: Vector3, impulse: Vector3) {\n        console.log(\"impulse magnitude: \", impulse.length());\n    }\n}","/Users/danny/Github/physics_engine_for_the_web/frontend/src/Demos/Demo2.tsx",["83","84","85","86","87","88","89","90","91"],[],"import React from \"react\";\nimport { World, Sphere, Box, Plane, checkCollision, getAllContacts, resolveCollision } from \"../physics_engine/physics_engine\";\nimport * as THREE from \"three\";\nimport { Matrix3, Scene, Vector3 } from \"three\";\nimport { OrbitControls } from \"three-orbitcontrols-ts\";\nimport { yRotationMatrix3, zRotationMatrix3, convertMatrix3ToMatrix4, xRotationMatrix3, getQuaternionRotatingV1ToV2 } from \"../physics_engine/math_library\";\n\nconst CANVAS_WIDTH = 1000;\nconst CANVAS_HEIGHT = 500;\n\n// camera\nconst camera = new THREE.PerspectiveCamera(45, CANVAS_WIDTH / CANVAS_HEIGHT, 1, 1000);\ncamera.position.set(0, -CANVAS_HEIGHT / 6, CANVAS_HEIGHT / 6);\ncamera.up.set(0, 1, 0);\n\n// add lighting\nconst light_color = 0xffffff;\nconst intensity = 1;\nconst point_light = new THREE.PointLight(light_color, intensity);\npoint_light.position.set(10, 10, 50);\n\nconst ambient_light = new THREE.AmbientLight(light_color, 0.2);\n\nexport default class Demo2 extends React.Component {\n    private canvasRef: any;\n\n    private w: World;\n\n    private renderer: any;\n    private animationRequestID: any;\n    private scene: THREE.Scene;\n\n    constructor(props: any) {\n        super(props);\n        this.canvasRef = React.createRef();\n        this.w = new World();\n\n        // graphics\n        this.renderer = null;\n        this.animationRequestID = null;\n\n        // bindings\n        this.onRestart = this.onRestart.bind(this);\n        this.onResume = this.onResume.bind(this);\n        this.onPause = this.onPause.bind(this);\n    }\n\n    componentDidMount(): void {\n        // graphics\n        this.renderer = new THREE.WebGLRenderer({ canvas: this.canvasRef.current, alpha: false })\n        this.renderer.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // orbit controls\n        const controls = new OrbitControls(camera, this.renderer.domElement);\n\n        this.initialize();\n        this.onVisualize();\n    }\n\n    componentWillUnmount() {\n        if(this.renderer) {\n            this.renderer = null;\n        }\n\n        if (this.animationRequestID) {\n            cancelAnimationFrame(this.animationRequestID);\n        }\n    }\n\n    initialize(): void {\n        // cancel ongoing animation\n        if (this.animationRequestID) {\n            cancelAnimationFrame(this.animationRequestID);\n        }\n\n        this.w = new World();\n        this.scene = new THREE.Scene();\n\n        // set up objects\n        const sphere = new Sphere(new Vector3(-50, 10, 10), 5);\n        sphere.velocity = new Vector3(15, 0, 0);\n        const sphere2 = new Sphere(new Vector3(-20, 10, 10), 5);\n        const sphere3 = new Sphere(new Vector3(10, 10, 10), 5);\n        const box = new Box(new Vector3(30, 10, 10), 10, 10, 10);\n        \n        this.w.addObject(sphere);\n        this.w.addObject(sphere2);\n        this.w.addObject(sphere3);\n        this.w.addObject(box);\n\n        const box2 = new Box(new Vector3(-50, -20, 10), 10, 10, 10);\n        box2.velocity.x = 15;\n        const box3 = new Box(new Vector3(-20, -20, 10), 10, 10, 10);\n        box3.rotation.setFromUnitVectors(new Vector3(1, 1, 1).normalize(), new Vector3(1, 0, 0));\n        const box4 = new Box(new Vector3(10, -20, 10), 10, 10, 10);\n        const sphere4 = new Sphere(new Vector3(30, -20, 10), 5);\n\n        this.w.addObject(box2);\n        this.w.addObject(box3);\n        this.w.addObject(box4);\n        this.w.addObject(sphere4);\n\n        // add plane\n        const plane = new Plane(new Vector3(55, 0, 0), new Vector3(-1, 0, 0), 1000, 1000);\n        this.w.addObject(plane);\n\n        // add object meshes and bounding box meshes to scene\n        for (let object of this.w.objects) {\n            this.scene.add(object.mesh);\n\n            if (object instanceof Plane) {\n                continue;\n            }\n            this.scene.add(object.boundingBoxMesh);\n        }\n\n        // add gridHelper\n        const gridHelper = new THREE.GridHelper( 100, 10 );\n        gridHelper.rotateOnWorldAxis(new Vector3(1, 0, 0), Math.PI/2);\n        this.scene.add(gridHelper);\n\n        // add lighting\n        this.scene.add(point_light, ambient_light);\n    }\n\n    onVisualize() {\n        // cancel ongoing animation\n        if (this.animationRequestID) {\n            cancelAnimationFrame(this.animationRequestID);\n        }\n\n        const renderer = this.renderer;\n        const scene = this.scene;\n        const world = this.w;\n        const objects = world.objects;\n\n        let boundingBoxIntersections;\n        let contacts;\n\n        const currentInstance = this;\n        function animate() {\n            currentInstance.animationRequestID = requestAnimationFrame(animate);\n\n            // update bounding box intersections and contacts, for visualization\n            boundingBoxIntersections = world.getAllBoundingBoxIntersections();\n            contacts = getAllContacts(boundingBoxIntersections);\n\n            // resolve contacts\n            for (let contact of contacts) {\n                resolveCollision(contact);\n            }\n\n            // physics step\n            world.integrateObjects(1/60);\n\n            // graphics step\n            world.updateMeshes();\n\n            // reset mesh colors\n            for (let object of objects) {\n                object.mesh.material = new THREE.MeshPhongMaterial({ color: 0x00bcd6 })\n                object.mesh.material.opacity = 0.6;\n                object.mesh.material.transparent = true;\n\n                if (object instanceof Plane) {\n                    object.mesh.material = new THREE.MeshPhongMaterial({ color: 0xffcb3e });\n                    continue;\n                }\n                object.boundingBoxMesh.material = new THREE.LineBasicMaterial({ color: 0xffffff });\n            }\n\n            // color the bound boxes of intersecting boxes\n            for (let intersection of boundingBoxIntersections) {\n                const a = intersection.a, b = intersection.b;\n                if (!(a instanceof Plane) && ! (b instanceof Plane)) {\n                    a.boundingBoxMesh.material = new THREE.LineBasicMaterial({ color: 0xff0000 });\n                    b.boundingBoxMesh.material = new THREE.LineBasicMaterial({ color: 0xff0000 });\n                }\n\n                // check for collisions and color them\n                if (checkCollision(a, b)) {\n                    const red_material = new THREE.MeshPhongMaterial({ color: 0xff0000 });\n                    red_material.opacity = 0.6;\n                    red_material.transparent = true;\n                    a.mesh.material = red_material;\n                    b.mesh.material = red_material;\n                }\n            }\n\n            const toBeRemoved: any[] = [];\n\n            for (let contact of contacts) {\n                const sphere_geometry = new THREE.SphereGeometry(1);\n                const material = new THREE.MeshBasicMaterial({ color: 0xffff00 });\n                const sphere = new THREE.Mesh(sphere_geometry, material);\n                sphere.position.set(contact.contactPoint.x, contact.contactPoint.y, contact.contactPoint.z);\n                scene.add(sphere);\n                toBeRemoved.push(sphere);\n                const dir = contact.contactNormal.clone().normalize();\n                const origin = contact.contactPoint;\n                const length = 20;\n                const hex = 0xffff00;\n                const arrowHelper = new THREE.ArrowHelper(dir, origin, length, hex);\n                scene.add(arrowHelper);\n                toBeRemoved.push(arrowHelper);\n\n                if (contact.type === \"vertex-face\") {\n\n                } else if (contact.type === \"edge-edge\") {\n                    const a_points = [contact.edge_a.a, contact.edge_a.b];\n                    const b_points = [contact.edge_b.a, contact.edge_b.b];\n                    const material = new THREE.LineBasicMaterial({color: 0xffff00});\n                    const geometry_a = new THREE.BufferGeometry().setFromPoints(a_points);\n                    const geometry_b = new THREE.BufferGeometry().setFromPoints(b_points);\n                    const line_a = new THREE.Line(geometry_a, material);\n                    const line_b = new THREE.Line(geometry_b, material);\n                    scene.add(line_a);\n                    scene.add(line_b);\n                    toBeRemoved.push(line_a);\n                    toBeRemoved.push(line_b);\n                } else {\n                    console.error(\"contact type not recognized\");\n                }\n            }\n\n            currentInstance.renderer.render(scene, camera);\n            for (let object of toBeRemoved) {\n                scene.remove(object);\n            }\n        }\n\n        animate();\n    }\n\n    onRestart(): void {\n        this.initialize();\n        this.onVisualize();\n    }\n\n    onResume(): void {\n        this.onVisualize();\n    }\n\n    onPause(): void {\n        // cancel ongoing animation\n        if (this.animationRequestID) {\n            cancelAnimationFrame(this.animationRequestID);\n        }\n    }\n\n    render() {\n        return (\n            <div className=\"playground\">\n                <h2>Demo 2</h2>\n                <p>This scene shows how the physics engine detects and resolves collisions between spheres, boxes, and planes. At each time step, the engine first checks for all bounding box intersections using a sort and sweep algorithm. Then, the engine checks each bounding box intersection for collisions using the separating axis technique. If a collision is detected, contact data is generated that includes the information needed to resolve the collision. Finally, all colliding collisions are resolved by calculating and applying an impulse.</p>\n                <button onClick={this.onRestart}>Restart</button>\n                <button onClick={this.onResume}>Resume</button>\n                <button onClick={this.onPause}>Pause</button>\n                <div id=\"canvas_container\">\n                    <canvas ref={this.canvasRef} width={CANVAS_WIDTH} height={CANVAS_HEIGHT} />\n                </div>\n            </div>\n        )\n    }\n}","/Users/danny/Github/physics_engine_for_the_web/frontend/src/Demos/Demo1.tsx",["92"],[],"import React from \"react\";\nimport { World, Sphere, Box } from \"../physics_engine/physics_engine\";\nimport * as THREE from \"three\";\nimport { Vector3 } from \"three\";\nimport { OrbitControls } from \"three-orbitcontrols-ts\";\n\nconst CANVAS_WIDTH = 1000;\nconst CANVAS_HEIGHT = 500;\n\n// camera\nconst camera = new THREE.PerspectiveCamera(45, CANVAS_WIDTH / CANVAS_HEIGHT, 1, 1000);\ncamera.position.set(0, -CANVAS_HEIGHT / 6, CANVAS_HEIGHT / 6);\ncamera.up.set(0, 1, 0);\n\n// add lighting\nconst light_color = 0xffffff;\nconst intensity = 1;\nconst point_light = new THREE.PointLight(light_color, intensity);\npoint_light.position.set(50, 50, 50);\n\nconst ambient_light = new THREE.AmbientLight(light_color, 0.2);\n\nexport default class Demo1 extends React.Component {\n    private canvasRef: any;\n\n    private w: World;\n\n    private renderer: any;\n    private animationRequestID: any;\n    private scene: THREE.Scene;\n\n    constructor(props: any) {\n        super(props);\n        this.canvasRef = React.createRef();\n        this.w = new World();\n\n        // graphics\n        this.renderer = null;\n        this.animationRequestID = null;\n\n        // bindings\n        this.onRestart = this.onRestart.bind(this);\n        this.onResume = this.onResume.bind(this);\n        this.onPause = this.onPause.bind(this);\n    }\n\n    componentDidMount(): void {\n        // graphics\n        this.renderer = new THREE.WebGLRenderer({ canvas: this.canvasRef.current, alpha: false })\n        this.renderer.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // orbit controls\n        const controls = new OrbitControls(camera, this.renderer.domElement);\n\n        this.initialize();\n        this.onVisualize();\n    }\n\n    componentWillUnmount() {\n        if(this.renderer) {\n            this.renderer = null;\n        }\n\n        if (this.animationRequestID) {\n            cancelAnimationFrame(this.animationRequestID);\n        }\n    }\n\n    initialize(): void {\n        // cancel ongoing animation\n        if (this.animationRequestID) {\n            cancelAnimationFrame(this.animationRequestID);\n        }\n\n        this.w = new World();\n        this.scene = new THREE.Scene();\n\n        // set up objects\n        const sphere = new Sphere(new Vector3(0, 0, 0), 5);\n        const sphere2 = new Sphere(new Vector3(30, 20, 40), 3);\n        const box = new Box(new Vector3(30, 0, 0), 4, 4, 4);\n        const box2 = new Box(new Vector3(-50, 0, 20), 5, 5, 5);\n        const box3 = new Box(new Vector3(-40, -40, -20), 2, 2, 8);\n\n        sphere.inverseMass = 1/300000;\n\n        sphere.velocity = new Vector3(0, 0, 0);\n        sphere2.velocity = new Vector3(-10, 100, -10);\n        box.velocity = new Vector3(0, 150, 0);\n        box2.velocity = new Vector3(0, -100, 0);\n        box3.velocity = new Vector3(70, 0, -10);\n\n        box.angularMomentum = new Vector3(0, 3, 3).applyMatrix3(box.getInertia());\n        box2.angularMomentum = new Vector3(5, 5, 5).applyMatrix3(box2.getInertia());\n        box3.angularMomentum = new Vector3(-3, 1, 0).applyMatrix3(box3.getInertia());\n\n        this.w.addObject(sphere);\n        this.w.addObject(sphere2);\n        this.w.addObject(box);\n        this.w.addObject(box2);\n        this.w.addObject(box3);\n\n        // add object meshes and bounding box meshes to scene\n        for (let object of this.w.objects) {\n            this.scene.add(object.mesh);\n            //this.scene.add(object.boundingBoxMesh);\n        }\n\n        // add gridHelper\n        const gridHelper = new THREE.GridHelper( 100, 10 );\n        gridHelper.rotateOnWorldAxis(new Vector3(1, 0, 0), Math.PI/2);\n        this.scene.add(gridHelper);\n\n        // add lighting\n        this.scene.add(point_light, ambient_light);\n    }\n\n    onVisualize(): void {\n        // cancel ongoing animation\n        if (this.animationRequestID) {\n            cancelAnimationFrame(this.animationRequestID);\n        }\n\n        const renderer = this.renderer;\n        const scene = this.scene;\n        const world = this.w;\n        const objects = world.objects;\n\n        let gravitational_constant = 1;\n\n        const currentInstance = this;\n        function animate() {\n            currentInstance.animationRequestID = requestAnimationFrame(animate);\n\n            const toBeRemovedFromScene = [];\n\n            // apply forces\n            for (let obj1 of objects) {\n                if (obj1.inverseMass === 0) {\n                    continue;\n                }\n\n                const mass1 = 1/obj1.inverseMass;\n\n                for (let obj2 of objects) {\n                    const relative_position = obj2.position.clone().sub(obj1.position);\n                    if (obj2.inverseMass === 0 || relative_position.length() === 0) {\n                        continue;\n                    }\n\n                    const mass2 = 1/obj2.inverseMass;\n                    const u_12 = relative_position.clone().normalize();\n                    const radius_squared = relative_position.length() * relative_position.length();\n                    obj1.forceAccum.addScaledVector(u_12, gravitational_constant * mass1 * mass2 / radius_squared)\n                    obj2.forceAccum.addScaledVector(u_12, -gravitational_constant * mass1 * mass2 / radius_squared);\n                }\n            }\n\n            // add arrows to represent force vectors\n            for (let object of objects) {\n                const direction = object.forceAccum.clone().normalize();\n                const length = object.forceAccum.length()/2000;\n                const origin = object.position;\n                const hex = 0xff5c77;\n                const arrow = new THREE.ArrowHelper(direction, origin, length, hex);\n                toBeRemovedFromScene.push(arrow);\n                scene.add(arrow);\n            }\n\n            // physics step\n            // world.integrateObjects(1/60);\n            world.tick(1/60);\n            \n            // graphics step\n            world.updateMeshes();\n\n            // add arrows to represent velocity vectors\n            for (let object of objects) {\n                \n                const direction = object.velocity.clone().normalize();\n                const length = object.velocity.length() / 5;\n                const origin = object.position;\n                const hex = 0x4dd091;\n                const arrow = new THREE.ArrowHelper(direction, origin, length, hex);\n                toBeRemovedFromScene.push(arrow);\n                scene.add(arrow);\n            }\n\n            renderer.render(scene, camera);\n\n            for (let object of toBeRemovedFromScene) {\n                scene.remove(object);\n            }\n        }\n        animate();\n    }\n\n    onRestart(): void {\n        this.initialize();\n        this.onVisualize();\n    }\n\n    onResume(): void {\n        this.onVisualize();\n    }\n\n    onPause(): void {\n        // cancel ongoing animation\n        if (this.animationRequestID) {\n            cancelAnimationFrame(this.animationRequestID);\n        }\n    }\n\n    render() {\n        return (\n            <div className=\"playground\">\n                <h2>Demo 1</h2>\n                <p>This scene shows how the physics engine is able to simulate unconstrained motion. At each time step, a gravitational force is applied to each object. Then, each object's position and orientiation is updated based on its velocity and angular momentum.</p>\n                <button onClick={this.onRestart}>Restart</button>\n                <button onClick={this.onResume}>Resume</button>\n                <button onClick={this.onPause}>Pause</button>\n                <div id=\"canvas_container\">\n                    <canvas ref={this.canvasRef} width={CANVAS_WIDTH} height={CANVAS_HEIGHT} />\n                </div>\n            </div>\n        )\n    }\n}","/Users/danny/Github/physics_engine_for_the_web/frontend/src/Demos/Demo3.tsx",["93","94","95","96","97","98"],[],"import React from \"react\";\nimport * as THREE from \"three\";\nimport { OrbitControls } from \"three-orbitcontrols-ts\";\nimport { Matrix4, Vector3 } from \"three\";\nimport { World, Sphere, Box, Plane } from \"../physics_engine/physics_engine\";\n\nconst CANVAS_WIDTH = 1000;\nconst CANVAS_HEIGHT = 500;\n\n// camera\nconst camera = new THREE.PerspectiveCamera(45, CANVAS_WIDTH / CANVAS_HEIGHT, 1, 1000);\ncamera.position.set(0, -CANVAS_HEIGHT / 6, CANVAS_HEIGHT / 6);\ncamera.up.set(0, 1, 0);\n\n// add lighting\nconst light_color = 0xffffff;\nconst intensity = 1;\nconst point_light = new THREE.PointLight(light_color, intensity);\npoint_light.position.set(10, 10, 50);\n\nconst ambient_light = new THREE.AmbientLight(light_color, 0.2);\n\nexport default class Demo3 extends React.Component {\n    private canvasRef: any;\n\n    private w: World;\n\n    private renderer: any;\n    private animationRequestID: any;\n    private scene: THREE.Scene;\n\n    constructor(props: any) {\n        super(props);\n        this.canvasRef = React.createRef();\n        this.w = new World();\n\n        // graphics\n        this.renderer = null;\n        this.animationRequestID = null;\n\n        // bindings\n        this.onRestart = this.onRestart.bind(this);\n        this.onResume = this.onResume.bind(this);\n        this.onPause = this.onPause.bind(this);\n    }\n\n    componentDidMount(): void {\n        // graphics\n        this.renderer = new THREE.WebGLRenderer({ canvas: this.canvasRef.current, alpha: false })\n        this.renderer.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // orbit controls\n        const controls = new OrbitControls(camera, this.renderer.domElement);\n\n        this.initialize();\n        this.onVisualize();\n    }\n\n    componentWillUnmount() {\n        if(this.renderer) {\n            this.renderer = null;\n        }\n\n        if (this.animationRequestID) {\n            cancelAnimationFrame(this.animationRequestID);\n        }\n    }\n\n    initialize(): void {\n        // cancel ongoing animation\n        if (this.animationRequestID) {\n            cancelAnimationFrame(this.animationRequestID);\n        }\n\n        this.w = new World();\n        this.scene = new THREE.Scene();\n\n        // set up objects\n        const s = new Sphere(new Vector3(-70, 0, 40), 8);\n        s.velocity = new Vector3(30, 0, 0);\n\n        this.w.addObject(s);\n\n        // add pyramid of boxes\n        let height = 7.5;\n        for (let i = 0; i < 2 ; i++) {\n            for (let j = 0; j < 2; j++) {\n                const box = new Box(new Vector3(i * 25 + 5, j*17 - 7.5, height), 15, 15, 20);\n                this.w.addObject(box);\n            }\n        }\n        height += 15;\n        const box1 = new Box(new Vector3(15, 0, height), 14, 14, 15);\n        // this.w.addObject(box1);\n        height += 15;\n        \n        const wall = new Box(new Vector3(50, 0, 25), 5, 80, 50);\n\n        this.w.addObject(wall);\n\n        // rotating cubes on corners\n        const corners = [];\n        corners.push(new Vector3(-55, 55, 40), new Vector3(-55, -55, 40), new Vector3(55, 55, 40), new Vector3(55, -55, 40));\n        for (let corner of corners) {\n            const rotatingCube = new Box(corner, 10, 10, 10);\n            rotatingCube.angularMomentum = new Vector3(1, 1, 5).applyMatrix3(rotatingCube.getInertia());\n            this.w.addObject(rotatingCube);\n        }\n\n        // add some bouncing balls at the top and bottom\n        const sides =[];\n        sides.push(new Vector3(0, 55, 40), new Vector3(0, -55, 40));\n        for (let side of sides) {\n            const bouncingBall = new Sphere(side, 5);\n            this.w.addObject(bouncingBall);\n        }\n\n        // add plane\n        const plane = new Plane(new Vector3(0, 0, 0), new Vector3(0, 0, 1), 1000, 1000);\n        this.w.addObject(plane);\n\n        // add object meshes and bounding box meshes to scene\n        for (let object of this.w.objects) {\n            this.scene.add(object.mesh);\n        }\n\n        // add gridHelper\n        const gridHelper = new THREE.GridHelper( 100, 10 );\n        gridHelper.rotateOnWorldAxis(new Vector3(1, 0, 0), Math.PI/2);\n        this.scene.add(gridHelper);\n\n        // add lighting\n        this.scene.add(point_light, ambient_light);\n    }\n\n    onVisualize(): void {\n        // cancel ongoing animation\n        if (this.animationRequestID) {\n            cancelAnimationFrame(this.animationRequestID);\n        }\n\n        const renderer = this.renderer;\n        const scene = this.scene;\n        const world = this.w;\n        const objects = world.objects;\n\n        let boundingBoxIntersections;\n        let contacts;\n\n        const currentInstance = this;\n        function animate() {\n            currentInstance.animationRequestID = requestAnimationFrame(animate);\n\n            // add gravity\n            for (let object of objects) {\n                if (object instanceof Plane) {\n                    continue;\n                }\n\n                const mass = 1/object.inverseMass;\n                object.forceAccum.addScaledVector(new Vector3(0, 0, -1), mass * 10);\n            }\n\n            world.tick(1/60);\n\n            // graphics step\n            world.updateMeshes();\n\n            currentInstance.renderer.render(scene, camera);\n        }\n\n        animate();\n    }\n\n    onRestart(): void {\n        this.initialize();\n        this.onVisualize();\n    }\n\n    onResume(): void {\n        this.onVisualize();\n    }\n\n    onPause(): void {\n        // cancel ongoing animation\n        if (this.animationRequestID) {\n            cancelAnimationFrame(this.animationRequestID);\n        }\n    }\n\n    render() {\n        return (\n            <div className=\"demo2\">\n                <h2>Demo 3</h2>\n                <p>This scene shows how the physics engine simulates constrained dynamics. The sphere, set with some initial velocity, is launched into a small pile of cubes, and all objects are accelerated by the force of gravity. The engine may be extended to become part of physics-based game, such as one involving ballistics.</p>\n                <button onClick={this.onRestart}>Restart</button>\n                <button onClick={this.onResume}>Resume</button>\n                <button onClick={this.onPause}>Pause</button>\n                <div id=\"canvas_container\">\n                    <canvas ref={this.canvasRef} width={CANVAS_WIDTH} height={CANVAS_HEIGHT} />\n                </div>\n            </div>\n        )\n    }\n}","/Users/danny/Github/physics_engine_for_the_web/frontend/src/About/About.tsx",["99","100","101"],[],"import React from \"react\";\nimport { World } from \"../physics_engine/physics_engine\";\nimport * as THREE from \"three\";\nimport { OrbitControls } from \"three-orbitcontrols-ts\";\nimport { Box } from \"../physics_engine/Box\";\nimport { Sphere } from \"../physics_engine/Sphere\";\nimport { Vector3 } from \"three\";\n\nimport \"./About.css\";\n\nconst CANVAS_WIDTH = 1000;\nconst CANVAS_HEIGHT = 200;\n\n// camera\nconst camera = new THREE.PerspectiveCamera(45, CANVAS_WIDTH / CANVAS_HEIGHT, 1, 1000);\ncamera.position.set(0, 0, CANVAS_HEIGHT / 4);\ncamera.up.set(0, 1, 0);\n\n// add lighting\nconst light_color = 0xffffff;\nconst intensity = 1;\nconst point_light = new THREE.PointLight(light_color, intensity);\npoint_light.position.set(0, 0, 50);\n\nconst ambient_light = new THREE.AmbientLight(light_color, 0.2);\n\nexport default class Home extends React.Component {\n    canvasRef: any;\n    private w: World;\n    private renderer: any;\n    private animationRequestID: any;\n\n    constructor(props: any) {\n        super(props);\n        this.canvasRef = React.createRef();\n        this.w = new World();\n\n        // graphics\n        this.renderer = null;\n        this.animationRequestID = null;\n    }\n\n    componentDidMount(): void {\n        this.w = new World();\n\n        // graphics\n        this.renderer = new THREE.WebGLRenderer({ canvas: this.canvasRef.current, alpha: true })\n        this.renderer.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // orbit controls\n        // const controls = new OrbitControls(camera, this.renderer.domElement);\n\n        this.onVisualize();\n    }\n\n    componentWillUnmount() {\n        if(this.renderer) {\n            this.renderer = null;\n        }\n\n        if (this.animationRequestID) {\n            cancelAnimationFrame(this.animationRequestID);\n        }\n    }\n\n    onVisualize() {\n        // cancel ongoing animation\n        if (this.animationRequestID) {\n            cancelAnimationFrame(this.animationRequestID);\n        }\n\n        this.w = new World();\n\n        const box = new Box(new Vector3(0, 0, 0), 15, 15, 15);\n        box.angularMomentum = new Vector3(2, 2, 1).applyMatrix3(box.getInertia());\n        this.w.addObject(box);\n\n        const boxMesh = box.mesh;\n        \n        const scene = new THREE.Scene();\n        scene.add(boxMesh);\n        scene.add(point_light, ambient_light);\n\n        const currentInstance = this;\n        function animate() {\n            currentInstance.animationRequestID = requestAnimationFrame(animate);\n\n            currentInstance.w.integrateObjects(1/60);\n            currentInstance.w.updateMeshes();\n\n            currentInstance.renderer.render(scene, camera);\n        }\n\n        animate();\n    }\n\n    render() {\n        return (\n            <div className=\"about\" >\n                <h2>About</h2>\n                <p>Hello. I recently created a simpe rigid-body physics engine as a personal project.\n                     This site is meant to serve as a visual demo to showcase its functionality. </p>\n                <p>For anyone interested, the source code is available on the <a href=\"https://github.com/dannyh2021/physics_game_engine\" target=\"_blank\">Github repo</a>.</p>\n                <div id=\"canvas_container\">\n                    <canvas ref={this.canvasRef} width={CANVAS_WIDTH} height={CANVAS_HEIGHT} />\n                </div>\n            </div>\n        )\n    }\n}",{"ruleId":"102","severity":1,"message":"103","line":2,"column":8,"nodeType":"104","messageId":"105","endLine":2,"endColumn":12},{"ruleId":"102","severity":1,"message":"106","line":2,"column":13,"nodeType":"104","messageId":"105","endLine":2,"endColumn":18},{"ruleId":"102","severity":1,"message":"107","line":4,"column":7,"nodeType":"104","messageId":"105","endLine":4,"endColumn":14},{"ruleId":"108","severity":1,"message":"109","line":44,"column":25,"nodeType":"110","messageId":"111","endLine":44,"endColumn":36,"fix":"112"},{"ruleId":"102","severity":1,"message":"113","line":3,"column":10,"nodeType":"104","messageId":"105","endLine":3,"endColumn":30},{"ruleId":"102","severity":1,"message":"114","line":3,"column":32,"nodeType":"104","messageId":"105","endLine":3,"endColumn":43},{"ruleId":"102","severity":1,"message":"115","line":3,"column":105,"nodeType":"104","messageId":"105","endLine":3,"endColumn":119},{"ruleId":"102","severity":1,"message":"116","line":3,"column":121,"nodeType":"104","messageId":"105","endLine":3,"endColumn":137},{"ruleId":"102","severity":1,"message":"117","line":1,"column":39,"nodeType":"104","messageId":"105","endLine":1,"endColumn":49},{"ruleId":"102","severity":1,"message":"118","line":3,"column":10,"nodeType":"104","messageId":"105","endLine":3,"endColumn":33},{"ruleId":"102","severity":1,"message":"119","line":3,"column":64,"nodeType":"104","messageId":"105","endLine":3,"endColumn":80},{"ruleId":"102","severity":1,"message":"120","line":4,"column":10,"nodeType":"104","messageId":"105","endLine":4,"endColumn":17},{"ruleId":"102","severity":1,"message":"121","line":4,"column":19,"nodeType":"104","messageId":"105","endLine":4,"endColumn":24},{"ruleId":"102","severity":1,"message":"119","line":6,"column":10,"nodeType":"104","messageId":"105","endLine":6,"endColumn":26},{"ruleId":"102","severity":1,"message":"122","line":6,"column":28,"nodeType":"104","messageId":"105","endLine":6,"endColumn":44},{"ruleId":"102","severity":1,"message":"118","line":6,"column":46,"nodeType":"104","messageId":"105","endLine":6,"endColumn":69},{"ruleId":"102","severity":1,"message":"123","line":6,"column":71,"nodeType":"104","messageId":"105","endLine":6,"endColumn":87},{"ruleId":"102","severity":1,"message":"124","line":6,"column":89,"nodeType":"104","messageId":"105","endLine":6,"endColumn":116},{"ruleId":"102","severity":1,"message":"125","line":54,"column":15,"nodeType":"104","messageId":"105","endLine":54,"endColumn":23},{"ruleId":"102","severity":1,"message":"126","line":132,"column":15,"nodeType":"104","messageId":"105","endLine":132,"endColumn":23},{"ruleId":"102","severity":1,"message":"125","line":53,"column":15,"nodeType":"104","messageId":"105","endLine":53,"endColumn":23},{"ruleId":"102","severity":1,"message":"127","line":4,"column":10,"nodeType":"104","messageId":"105","endLine":4,"endColumn":17},{"ruleId":"102","severity":1,"message":"125","line":53,"column":15,"nodeType":"104","messageId":"105","endLine":53,"endColumn":23},{"ruleId":"102","severity":1,"message":"128","line":93,"column":15,"nodeType":"104","messageId":"105","endLine":93,"endColumn":19},{"ruleId":"102","severity":1,"message":"126","line":142,"column":15,"nodeType":"104","messageId":"105","endLine":142,"endColumn":23},{"ruleId":"102","severity":1,"message":"129","line":147,"column":13,"nodeType":"104","messageId":"105","endLine":147,"endColumn":37},{"ruleId":"102","severity":1,"message":"130","line":148,"column":13,"nodeType":"104","messageId":"105","endLine":148,"endColumn":21},{"ruleId":"102","severity":1,"message":"131","line":4,"column":10,"nodeType":"104","messageId":"105","endLine":4,"endColumn":23},{"ruleId":"102","severity":1,"message":"132","line":6,"column":10,"nodeType":"104","messageId":"105","endLine":6,"endColumn":16},{"ruleId":"133","severity":1,"message":"134","line":103,"column":79,"nodeType":"135","messageId":"136","endLine":103,"endColumn":155,"fix":"137"},"@typescript-eslint/no-unused-vars","'logo' is defined but never used.","Identifier","unusedVar","'THREE' is defined but never used.","'DAMPING' is assigned a value but never used.","new-parens","Missing '()' invoking a constructor.","NewExpression","missing",{"range":"138","text":"139"},"'getVectorCrossMatrix' is defined but never used.","'addMatrices' is defined but never used.","'getEulerAngles' is defined but never used.","'printEulerAngles' is defined but never used.","'Quaternion' is defined but never used.","'convertMatrix3ToMatrix4' is defined but never used.","'yRotationMatrix3' is defined but never used.","'Matrix3' is defined but never used.","'Scene' is defined but never used.","'zRotationMatrix3' is defined but never used.","'xRotationMatrix3' is defined but never used.","'getQuaternionRotatingV1ToV2' is defined but never used.","'controls' is assigned a value but never used.","'renderer' is assigned a value but never used.","'Matrix4' is defined but never used.","'box1' is assigned a value but never used.","'boundingBoxIntersections' is defined but never used.","'contacts' is defined but never used.","'OrbitControls' is defined but never used.","'Sphere' is defined but never used.","react/jsx-no-target-blank","Using target=\"_blank\" without rel=\"noreferrer\" (which implies rel=\"noopener\") is a security risk in older browsers: see https://mathiasbynens.github.io/rel-noopener/#recommendations","JSXOpeningElement","noTargetBlankWithoutNoreferrer",{"range":"140","text":"141"},[1243,1243],"()",[3106,3106]," rel=\"noreferrer\""]