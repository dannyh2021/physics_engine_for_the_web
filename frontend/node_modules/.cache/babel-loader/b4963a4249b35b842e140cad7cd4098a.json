{"ast":null,"code":"import { Vector3 } from \"three\";\nimport { Sphere } from \"./Sphere\"; // import { Sphere } from \"three\";\n\nconst dt = 1 / 60; // time step in seconds\n\nexport class World {\n  constructor() {\n    this.objects = [];\n    this.currentLoopInterval = null;\n    this.characterForce = void 0;\n    this.objects = [];\n    this.characterForce = new Vector3(0, 0, 0);\n  }\n\n  startLoop() {\n    const currentInstance = this; // stop current loop if it exits\n\n    this.stopCurrentLoop();\n    let lastTimeCalled = performance.now();\n    let fps = 0;\n    let times = [];\n\n    function step() {\n      // calculate fps\n      const now = performance.now();\n\n      while (times.length > 0 && times[0] <= now - 1000) {\n        times.shift();\n      }\n\n      times.push(now);\n      fps = times.length; // console.log(\"fps: \", fps);\n\n      for (let i = 0; i < currentInstance.objects.length; i++) {\n        currentInstance.objects[i].integrate(dt);\n      }\n    }\n\n    this.currentLoopInterval = setInterval(step, dt * 1000);\n  }\n  /** Stops current loop if it exists. */\n\n\n  stopCurrentLoop() {\n    if (this.currentLoopInterval) {\n      clearInterval(this.currentLoopInterval);\n    }\n  }\n\n  startGameLoop() {\n    const s = new Sphere(new Vector3(0, 0, 0), 3);\n    const s2 = new Sphere(new Vector3(10, 0, 0), 3);\n    const s3 = new Sphere(new Vector3(0, 5, 0), 3);\n    this.objects = [];\n    this.objects.push(s);\n    this.objects.push(s2); //this.objects.push(s3);\n\n    this.clearCurrentLoop();\n    let lastCalledTime = performance.now(); // returns timestamp in ms\n\n    let fps = 0;\n    let times = [];\n    let i = 0; // this.currentLoopInterval = setInterval(() => {i++; console.log(i)}, 1000);\n\n    const currentInstance = this;\n\n    function animate() {\n      requestAnimationFrame(animate);\n      s.forceAccum.add(currentInstance.characterForce);\n      currentInstance.characterForce = new Vector3(0, 0, 0);\n      s.integrate(1 / 60);\n    }\n\n    animate();\n  }\n\n  addObject(obj) {\n    this.objects.push(obj);\n  }\n\n  getObjects() {\n    return this.objects;\n  }\n\n  updateCharacterForce(f) {\n    this.characterForce = f;\n  }\n\n  detectCollisions() {}\n\n  checkCollisionSpheres(s1, s2) {\n    const d = s1.position.clone().sub(s2.position).length(); // distance between centers\n    // collision if distance between spheres is smaller than sub of radiuses\n\n    if (d < s1.radius + s2.radius) {\n      return true;\n    }\n\n    return false;\n  }\n\n  resolveCollisionSpheres(s1, s2) {}\n\n  clearCurrentLoop() {\n    clearInterval(this.currentLoopInterval);\n  }\n\n}","map":{"version":3,"names":["Vector3","Sphere","dt","World","constructor","objects","currentLoopInterval","characterForce","startLoop","currentInstance","stopCurrentLoop","lastTimeCalled","performance","now","fps","times","step","length","shift","push","i","integrate","setInterval","clearInterval","startGameLoop","s","s2","s3","clearCurrentLoop","lastCalledTime","animate","requestAnimationFrame","forceAccum","add","addObject","obj","getObjects","updateCharacterForce","f","detectCollisions","checkCollisionSpheres","s1","d","position","clone","sub","radius","resolveCollisionSpheres"],"sources":["/Users/danny/Github/physics_engine_for_the_web/frontend/src/physics_engine/physics_engine.ts"],"sourcesContent":["import { Vector3 } from \"three\";\nimport * as THREE from \"three\";\nimport { Sphere } from \"./Sphere\";\n// import { Sphere } from \"three\";\n\nconst dt = 1/60; // time step in seconds\n\nexport class World {\n    private objects: any[] = [];\n    private currentLoopInterval: any = null;\n\n    private characterForce: Vector3;\n\n    constructor() {\n        this.objects = [];\n\n        this.characterForce = new Vector3(0, 0, 0);\n    }\n\n    startLoop(): void {\n        const currentInstance = this;\n\n        // stop current loop if it exits\n        this.stopCurrentLoop();\n\n        let lastTimeCalled = performance.now();\n        let fps = 0;\n        let times: any[] = [];\n\n        function step() {\n            // calculate fps\n            const now = performance.now();\n            while (times.length > 0 && times[0] <= now - 1000) {\n                times.shift();\n            }\n            times.push(now);\n            fps = times.length;\n            // console.log(\"fps: \", fps);\n\n            for (let i = 0; i < currentInstance.objects.length; i++) {\n                currentInstance.objects[i].integrate(dt);\n            }\n        }\n\n        this.currentLoopInterval = setInterval(step, dt * 1000);\n    }\n\n    /** Stops current loop if it exists. */\n    stopCurrentLoop(): void {\n        if (this.currentLoopInterval) {\n            clearInterval(this.currentLoopInterval);\n        }\n    }\n\n    startGameLoop(): void {\n        const s = new Sphere(new Vector3(0, 0, 0), 3);\n        const s2 = new Sphere(new Vector3(10, 0, 0), 3);\n        const s3 = new Sphere(new Vector3(0, 5, 0), 3);\n        \n        this.objects = [];\n        this.objects.push(s);\n        this.objects.push(s2);\n        //this.objects.push(s3);\n\n        this.clearCurrentLoop();\n\n        let lastCalledTime = performance.now() // returns timestamp in ms\n        let fps = 0;\n        let times = [];\n\n        let i = 0;\n        // this.currentLoopInterval = setInterval(() => {i++; console.log(i)}, 1000);\n\n        const currentInstance = this;\n        function animate(): void {\n            requestAnimationFrame(animate);\n\n            s.forceAccum.add(currentInstance.characterForce);\n            currentInstance.characterForce = new Vector3(0, 0, 0);\n\n            s.integrate(1/60);\n        }\n        animate();\n    }\n\n    addObject(obj: any): void {\n        this.objects.push(obj);\n    }\n\n    getObjects(): any[] {\n        return this.objects;\n    }\n\n    updateCharacterForce(f: Vector3) {\n        this.characterForce = f;\n    }\n\n    detectCollisions(): void {\n\n    }\n\n    checkCollisionSpheres(s1: Sphere, s2: Sphere) {\n        const d = (s1.position.clone().sub(s2.position)).length(); // distance between centers\n\n        // collision if distance between spheres is smaller than sub of radiuses\n        if (d < (s1.radius + s2.radius)) {\n            return true;\n        }\n        return false;\n    }\n\n    resolveCollisionSpheres(s1: Sphere, s2: Sphere) {\n        \n    }\n\n    clearCurrentLoop(): void {\n        clearInterval(this.currentLoopInterval);\n    }\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}