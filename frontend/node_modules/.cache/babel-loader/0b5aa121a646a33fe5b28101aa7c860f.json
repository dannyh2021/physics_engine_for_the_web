{"ast":null,"code":"import * as THREE from \"three\";\nimport { Vector3, Matrix3, Quaternion } from \"three\";\nimport { convertQuaternionToMatrix, addQuaternions, scaleQuaternion, getEulerAngles } from \"./math_library\";\nexport class Box {\n  // inertia tensor in body space\n  // the orientation\n  // width, length, and height of boundBox\n  constructor(position, width, length, height) {\n    this.inverseMass = void 0;\n    this.width = void 0;\n    this.length = void 0;\n    this.height = void 0;\n    this.inertia = void 0;\n    this.position = void 0;\n    this.momentum = void 0;\n    this.rotation = void 0;\n    this.angularMomentum = void 0;\n    this.boundingBox = void 0;\n    this.mesh = void 0;\n    this.inverseMass = 1 / (width * length * height);\n    this.width = width;\n    this.length = length;\n    this.height = height;\n    this.inertia = new Matrix3();\n    this.setInertia();\n    this.position = position;\n    this.momentum = new Vector3(0, 0, 0); // this.momentum = (new Vector3(1, 0, 0)).multiplyScalar(1/this.inverseMass);\n\n    this.rotation = new Quaternion(0, 0, 0, 1);\n    this.angularMomentum = new Vector3(0.1, 0.1, 1).applyMatrix3(this.inertia);\n    this.setBoundingBox();\n    this.createMesh();\n    this.updateMesh();\n  }\n\n  setInertia() {\n    const I_xx = 1 / 12 * (this.length * this.length + this.height * this.height);\n    const I_yy = 1 / 12 * (this.width * this.width + this.height * this.height);\n    const I_zz = 1 / 12 * (this.width * this.width + this.length * this.length);\n    this.inertia.set(I_xx, 0, 0, 0, I_yy, 0, 0, 0, I_zz);\n  } // for now, set to big enough bounding box so that we don't need to update it.\n\n\n  setBoundingBox() {\n    const radius = Math.sqrt(this.width / 2 * (this.width / 2) + this.length / 2 * (this.length / 2) + this.height / 2 * (this.height / 2));\n    this.boundingBox = new Vector3(radius * 2, radius * 2, radius * 2);\n  }\n\n  createMesh() {\n    const boxGeometry = new THREE.BoxGeometry(this.width, this.length, this.height);\n    const material = new THREE.MeshPhongMaterial({\n      color: 0x00bcd6\n    });\n    this.mesh = new THREE.Mesh(boxGeometry, material);\n  } // updates mesh to current position and orientation\n\n\n  updateMesh() {\n    this.mesh.position.set(this.position.x, this.position.y, this.position.z);\n    this.mesh.setRotationFromQuaternion(this.rotation);\n  }\n\n  integrate(duration) {\n    // Don't integrate if mass is infinite or duration <= 0.\n    if (this.inverseMass <= 0 || duration <= 0) {\n      return;\n    }\n\n    this.position.addScaledVector(this.momentum, this.inverseMass * duration); // update rotation\n\n    const I_b_inverse = this.inertia.clone().invert();\n    const rotationMatrix = convertQuaternionToMatrix(this.rotation);\n    const I_inverse = rotationMatrix.clone().multiply(I_b_inverse).multiply(rotationMatrix.clone().transpose());\n    const angularVelocity = this.angularMomentum.clone().applyMatrix3(I_b_inverse); // ddt_q = (1/2) * w(t) * q(t)\n\n    const ddt_Rotation = new Quaternion(angularVelocity.x / 2, angularVelocity.y / 2, angularVelocity.z / 2, 0).multiply(this.rotation);\n    this.rotation = addQuaternions(this.rotation, scaleQuaternion(ddt_Rotation, duration));\n    this.rotation.normalize();\n    const eulerAngles = getEulerAngles(rotationMatrix);\n    console.log(\"euler angles: \", eulerAngles);\n  }\n\n}","map":{"version":3,"names":["THREE","Vector3","Matrix3","Quaternion","convertQuaternionToMatrix","addQuaternions","scaleQuaternion","getEulerAngles","Box","constructor","position","width","length","height","inverseMass","inertia","momentum","rotation","angularMomentum","boundingBox","mesh","setInertia","applyMatrix3","setBoundingBox","createMesh","updateMesh","I_xx","I_yy","I_zz","set","radius","Math","sqrt","boxGeometry","BoxGeometry","material","MeshPhongMaterial","color","Mesh","x","y","z","setRotationFromQuaternion","integrate","duration","addScaledVector","I_b_inverse","clone","invert","rotationMatrix","I_inverse","multiply","transpose","angularVelocity","ddt_Rotation","normalize","eulerAngles","console","log"],"sources":["/Users/danny/Github/physics_engine_for_the_web/frontend/src/physics_engine/Box.ts"],"sourcesContent":["import * as THREE from \"three\";\nimport { Vector3, Matrix3, Quaternion, Mesh } from \"three\";\nimport { getVectorCrossMatrix, addMatrices, convertQuaternionToMatrix, addQuaternions, scaleQuaternion, getEulerAngles, printEulerAngles } from \"./math_library\";\n\nexport class Box {\n    public inverseMass: number;\n\n    public width: number;\n    public length: number;\n    public height: number;\n\n    public inertia: Matrix3; // inertia tensor in body space\n\n    public position: Vector3;\n    public momentum: Vector3;\n\n    public rotation: Quaternion // the orientation\n    public angularMomentum: Vector3;\n\n    public boundingBox: Vector3 // width, length, and height of boundBox\n\n    public mesh: Mesh;\n\n    constructor(position: Vector3, width: number, length: number, height: number) {\n        this.inverseMass = 1 / (width * length * height);\n\n        this.width = width;\n        this.length = length;\n        this.height = height;\n\n        this.inertia = new Matrix3();\n        this.setInertia();\n        \n        this.position = position;\n        this.momentum = new Vector3(0, 0, 0);\n        // this.momentum = (new Vector3(1, 0, 0)).multiplyScalar(1/this.inverseMass);\n\n        this.rotation = new Quaternion(0, 0, 0, 1);\n        this.angularMomentum = new Vector3(0.1, 0.1, 1).applyMatrix3(this.inertia);\n\n        this.setBoundingBox();\n\n        this.createMesh();\n        this.updateMesh();\n    }\n\n    private setInertia(): void {\n        const I_xx = (1/12) * (this.length*this.length + this.height*this.height);\n        const I_yy = (1/12) * (this.width*this.width + this.height*this.height);\n        const I_zz = (1/12) * (this.width*this.width + this.length*this.length);\n\n        this.inertia.set(\n            I_xx, 0, 0,\n            0, I_yy, 0,\n            0, 0, I_zz\n        );\n    }\n\n    // for now, set to big enough bounding box so that we don't need to update it.\n    private setBoundingBox(): void {\n        const radius = Math.sqrt((this.width/2)*(this.width/2) + (this.length/2)*(this.length/2) + (this.height/2)*(this.height/2));\n        this.boundingBox = new Vector3(radius * 2, radius * 2, radius * 2);\n    };\n\n    private createMesh(): void {\n        const boxGeometry = new THREE.BoxGeometry(this.width, this.length, this.height);\n        const material = new THREE.MeshPhongMaterial({ color: 0x00bcd6 });\n        this.mesh = new THREE.Mesh(boxGeometry, material);\n    }\n\n    // updates mesh to current position and orientation\n    updateMesh(): void {\n        this.mesh.position.set(this.position.x, this.position.y, this.position.z);\n        this.mesh.setRotationFromQuaternion(this.rotation);\n    }\n\n    integrate(duration: number): void {\n        // Don't integrate if mass is infinite or duration <= 0.\n        if (this.inverseMass <= 0 || duration <= 0) {\n            return;\n        }\n\n        this.position.addScaledVector(this.momentum, this.inverseMass * duration);\n\n        // update rotation\n        const I_b_inverse = this.inertia.clone().invert();\n        const rotationMatrix = convertQuaternionToMatrix(this.rotation);\n        const I_inverse = rotationMatrix.clone().multiply(I_b_inverse).multiply(rotationMatrix.clone().transpose());\n        const angularVelocity = this.angularMomentum.clone().applyMatrix3(I_b_inverse);\n\n        // ddt_q = (1/2) * w(t) * q(t)\n        const ddt_Rotation = (new Quaternion(angularVelocity.x/2, angularVelocity.y/2, angularVelocity.z/2, 0)).multiply(this.rotation);\n        this.rotation = addQuaternions(this.rotation, scaleQuaternion(ddt_Rotation, duration));\n        this.rotation.normalize();\n\n        const eulerAngles = getEulerAngles(rotationMatrix);\n        console.log(\"euler angles: \", eulerAngles);\n    }\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}