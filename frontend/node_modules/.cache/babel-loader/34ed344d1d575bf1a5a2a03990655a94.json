{"ast":null,"code":"import { Matrix3, Vector3 } from \"three\";\nimport { Sphere } from \"./Sphere\";\nimport { Box } from \"./Box\";\nimport { Plane } from \"./Plane\";\nexport { Sphere } from \"./Sphere\";\nexport { Box } from \"./Box\";\nexport { Plane } from \"./Plane\";\nexport class World {\n  // 0 is fully inelastic, 1 is fully elastic\n  // time step in seconds\n  constructor() {\n    this.objects = void 0;\n    this.coefficient_of_restitution = 0.8;\n    this.dt = 1 / 60;\n    this.objects = [];\n  }\n\n  addObject(obj) {\n    this.objects.push(obj);\n  }\n\n  getAllBoundingBoxIntersections() {\n    // for now just sort against x-axis. Slightly better is to update axis based on one with highest variance\n    // worst case is still O(n^2)\n    function compareBoundingBoxes(a, b) {\n      const a_min = a.position.x - a.boundingBox.x / 2;\n      const b_min = b.position.x - b.boundingBox.x / 2;\n      return a_min - b_min;\n    } // sort objects along x-axis\n\n\n    const objectsCopy = [...this.objects];\n    objectsCopy.sort(compareBoundingBoxes); // sweep the array for collisions\n\n    const intersections = [];\n\n    for (let i = 0; i < objectsCopy.length - 1; i++) {\n      // test against all possible overlapping boxes following the current one.\n      for (let j = i + 1; j < objectsCopy.length; j++) {\n        // stop testing when AABBs are beyond the current AABB\n        const i_max = objectsCopy[i].position.x + objectsCopy[i].boundingBox.x / 2;\n        const j_min = objectsCopy[j].position.x - objectsCopy[j].boundingBox.x / 2;\n\n        if (j_min > i_max) {\n          break;\n        }\n\n        if (checkBoundingBoxIntersection(objectsCopy[i], objectsCopy[j])) {\n          intersections.push({\n            a: objectsCopy[i],\n            b: objectsCopy[j]\n          });\n        }\n      }\n    }\n\n    return intersections;\n  } // applies the forceAccum, detects and resolves collisions, and finally updates the positions of all objects.\n\n\n  tick(duration) {\n    for (let object of this.objects) {\n      if (object instanceof Plane) {\n        continue;\n      }\n\n      object.integrateForceAccum(duration);\n    }\n\n    const boundingBoxIntersections = this.getAllBoundingBoxIntersections();\n    const contacts = getAllContacts(boundingBoxIntersections);\n\n    for (let contact of contacts) {\n      this.resolveCollision(contact);\n    }\n\n    for (let object of this.objects) {\n      if (object instanceof Plane) {\n        continue;\n      }\n\n      object.integrate(duration);\n    }\n  } // integrates the forceAccum to update the velocity of each object\n\n\n  integrateForceAccumObjects(duration) {\n    for (let object of this.objects) {\n      if (object instanceof Plane) {\n        continue;\n      }\n\n      object.integrateForceAccum(duration);\n    }\n  } // integrates the velocities to update the position of each object\n\n\n  integrateObjects(duration) {\n    for (let object of this.objects) {\n      if (object instanceof Plane) {\n        continue;\n      }\n\n      object.integrate(duration);\n    }\n  }\n\n  resolveCollision(contactData) {\n    const a = contactData.a;\n    const b = contactData.b;\n    const normal = contactData.contactNormal;\n\n    if (contactData.type === \"vertex-face\") {\n      console.log(\"resolving vertex-face contact\");\n      const vertex = contactData.contactPoint;\n      const r_a = vertex.clone().sub(a.position);\n      const r_b = vertex.clone().sub(b.position);\n      const vertexVelocity_a = a.velocity.clone().add(a.getAngularVelocity().cross(r_a));\n      const vertexVelocity_b = b.velocity.clone().add(b.getAngularVelocity().cross(r_b));\n      const relativeVelocity = normal.dot(vertexVelocity_a.clone().sub(vertexVelocity_b));\n\n      if (relativeVelocity < 0) {\n        console.log(\"colliding contact\");\n        const I_inverse_a = a.getInertia().invert();\n        const I_inverse_b = b.getInertia().invert();\n        const term1 = normal.dot(r_a.clone().cross(normal).applyMatrix3(I_inverse_a).cross(r_a));\n        const term2 = normal.dot(r_b.clone().cross(normal).applyMatrix3(I_inverse_b).cross(r_b));\n        const j = -(1 + coefficient_of_restitution) * relativeVelocity / (a.inverseMass + b.inverseMass + term1 + term2);\n        console.log(\"relative Velocity: \", relativeVelocity);\n        const impulse = normal.clone().multiplyScalar(j);\n        const impulse2 = normal.clone().multiplyScalar(-j);\n        a.applyImpulse(vertex, impulse);\n        b.applyImpulse(vertex, impulse2);\n      } else if (relativeVelocity === 0) {\n        console.log(\"resting contact\");\n      } else {\n        // ignore\n        console.log(\"leaving\");\n      }\n    } else if (contactData.type === \"edge-edge\") {\n      console.log(\"resolving edge-edge contact\");\n      console.log(\"edge_a\", contactData.edge_a);\n      console.log(\"edge_b\", contactData.edge_b);\n      console.log(\"contactNormal: \", contactData.contactNormal);\n      const vertex = getClosestPointBetweenTwoEdges(contactData.edge_a, contactData.edge_b);\n      const r_a = vertex.clone().sub(a.position);\n      const r_b = vertex.clone().sub(b.position);\n      const vertexVelocity_a = a.velocity.clone().add(a.getAngularVelocity().cross(r_a));\n      const vertexVelocity_b = b.velocity.clone().add(b.getAngularVelocity().cross(r_b));\n      const relativeVelocity = normal.dot(vertexVelocity_a.clone().sub(vertexVelocity_b));\n\n      if (relativeVelocity < 0) {\n        console.log(\"colliding contact\");\n        const I_inverse_a = a.getInertia().invert();\n        let I_inverse_b = b.getInertia().invert();\n        const term1 = normal.dot(r_a.clone().cross(normal).applyMatrix3(I_inverse_a).cross(r_a));\n        const term2 = normal.dot(r_b.clone().cross(normal).applyMatrix3(I_inverse_b).cross(r_b));\n        const j = -(1 + coefficient_of_restitution) * relativeVelocity / (a.inverseMass + b.inverseMass + term1 + term2);\n        const impulse = normal.clone().multiplyScalar(j);\n        const impulse2 = normal.clone().multiplyScalar(-j);\n        a.applyImpulse(vertex, impulse);\n        b.applyImpulse(vertex, impulse2);\n      } else if (relativeVelocity === 0) {\n        console.log(\"resting contact\");\n      } else {\n        // ignore\n        console.log(\"leaving\");\n      }\n    } else {\n      console.error(\"contactData type not recognized.\");\n      console.log(\"contact data: \", contactData);\n    }\n  }\n\n  updateMeshes() {\n    for (let object of this.objects) {\n      if (object instanceof Plane) {\n        continue;\n      }\n\n      object.updateMesh();\n      object.updateBoundingBoxMesh();\n    }\n  }\n\n}\n/**\n * checks if the bounding box of two objects intersect\n * @param a the first object\n * @param b the other object\n */\n\nexport function checkBoundingBoxIntersection(a, b) {\n  // create intervals\n  const a_x_min = a.position.x - a.boundingBox.x / 2;\n  const a_x_max = a.position.x + a.boundingBox.x / 2;\n  const a_y_min = a.position.y - a.boundingBox.y / 2;\n  const a_y_max = a.position.y + a.boundingBox.y / 2;\n  const a_z_min = a.position.z - a.boundingBox.z / 2;\n  const a_z_max = a.position.z + a.boundingBox.z / 2;\n  const b_x_min = b.position.x - b.boundingBox.x / 2;\n  const b_x_max = b.position.x + b.boundingBox.x / 2;\n  const b_y_min = b.position.y - b.boundingBox.y / 2;\n  const b_y_max = b.position.y + b.boundingBox.y / 2;\n  const b_z_min = b.position.z - b.boundingBox.z / 2;\n  const b_z_max = b.position.z + b.boundingBox.z / 2; // intersecting if all intervals are intersecting\n\n  if (a_x_min < b_x_max && b_x_min < a_x_max && a_y_min < b_y_max && b_y_min < a_y_max && a_z_min < b_z_max && b_z_min < a_z_max) {\n    return true;\n  }\n\n  return false;\n} // returns true if the two objects are intersecting\n\nexport function checkCollision(a, b) {\n  if (a instanceof Box && b instanceof Box) {\n    return checkCollisionBoxes(a, b);\n  } else if (a instanceof Box && b instanceof Sphere) {\n    return checkCollisionBoxAndSphere(a, b);\n  } else if (a instanceof Box && b instanceof Plane) {\n    return checkCollisionBoxAndPlane(a, b);\n  } else if (a instanceof Sphere && b instanceof Box) {\n    return checkCollisionBoxAndSphere(b, a);\n  } else if (a instanceof Sphere && b instanceof Sphere) {\n    return checkCollisionSpheres(a, b);\n  } else if (a instanceof Sphere && b instanceof Plane) {\n    return checkCollisionSphereAndPlane(a, b);\n  } else if (a instanceof Plane && b instanceof Box) {\n    return checkCollisionBoxAndPlane(b, a);\n  } else if (a instanceof Plane && b instanceof Sphere) {\n    return checkCollisionSphereAndPlane(b, a);\n  } else {\n    console.error(\"checking collision between these types not implemented.\");\n  }\n}\nexport function checkCollisionBoxes(a, b) {\n  // two convex objects don't collide iff there exists a separating plane between them\n  // search for separating plane.\n  // either its contain a face of one polyhedra or it contains an edge of one polyhedra and is parallel to the edge of the other polyhedra.\n  const a_coordinateAxes = getCoordinateAxes(a);\n  const b_coordinateAxes = getCoordinateAxes(b); // check the 6 face axes\n\n  for (let faceAxis of a_coordinateAxes) {\n    if (separatingAxisPenetration(a, b, faceAxis) < 0) {\n      return false;\n    }\n  }\n\n  for (let faceAxis of b_coordinateAxes) {\n    if (separatingAxisPenetration(a, b, faceAxis) < 0) {\n      return false;\n    }\n  } // check the 9 edge-edge axes\n\n\n  for (let a_axis of a_coordinateAxes) {\n    for (let b_axis of b_coordinateAxes) {\n      let m = a_axis.clone().cross(b_axis).normalize();\n\n      if (m.length() > 0) {\n        // note to self: should use epsilon when checking for zero vector to  improve stability\n        if (separatingAxisPenetration(a, b, m) < 0) {\n          return false;\n        }\n      } else {\n        // for now, ignore case where the corresponding edges are parallel.\n        continue;\n      }\n    }\n  }\n\n  return true;\n}\nexport function checkCollisionSpheres(a, b) {\n  // two spheres intersect if the distance between their centers is not greater than the sum of their radii\n  const d = a.position.clone().sub(b.position).length();\n  return d <= a.radius + b.radius;\n}\nexport function checkCollisionSphereAndPlane(sphere, plane) {\n  const relativePosition = sphere.position.clone().sub(plane.position);\n  const d = relativePosition.dot(plane.normal); // distance to center of sphere, negative if center is below plane.\n\n  return d <= sphere.radius;\n}\nexport function checkCollisionBoxAndSphere(box, sphere) {\n  // convert sphere center to box coordinate space\n  const inverseRotation = box.rotation.clone();\n  let sphereCenter = sphere.position.clone().sub(box.position).applyQuaternion(inverseRotation); // Clamp each coordinate to the box.\n\n  const closestPoint = sphereCenter.clone();\n  closestPoint.x = Math.max(Math.min(closestPoint.x, box.width / 2), -box.width / 2);\n  closestPoint.y = Math.max(Math.min(closestPoint.y, box.length / 2), -box.length / 2);\n  closestPoint.z = Math.max(Math.min(closestPoint.z, box.height / 2), -box.height / 2); // check if they're in contact\n\n  const distance = sphereCenter.clone().sub(closestPoint).length();\n  return distance < sphere.radius;\n}\nexport function checkCollisionBoxAndPlane(box, plane) {\n  const vertices = getVertices(box);\n\n  for (let v of vertices) {\n    const relative_position = v.clone().sub(plane.position);\n    const d = relative_position.dot(plane.normal);\n\n    if (d < 0) {\n      return true;\n    }\n  }\n\n  return false;\n}\nexport function getAllContacts(boundingBoxIntersections) {\n  const contacts = [];\n\n  for (let i = 0; i < boundingBoxIntersections.length; i++) {\n    const a = boundingBoxIntersections[i].a;\n    const b = boundingBoxIntersections[i].b; // check for collisions and color them\n\n    if (checkCollision(a, b)) {\n      const contact = getContactData(a, b);\n      contacts.push(contact);\n    }\n  }\n\n  return contacts;\n}\nexport function getContactData(a, b) {\n  if (a instanceof Box && b instanceof Box) {\n    return getContactDataBoxes(a, b);\n  } else if (a instanceof Box && b instanceof Sphere) {\n    return getContactDataBoxAndSphere(a, b);\n  } else if (a instanceof Box && b instanceof Plane) {\n    return getContactDataBoxAndPlane(a, b);\n  } else if (a instanceof Sphere && b instanceof Box) {\n    return getContactDataBoxAndSphere(b, a);\n  } else if (a instanceof Sphere && b instanceof Sphere) {\n    return getContactDataSpheres(a, b);\n  } else if (a instanceof Sphere && b instanceof Plane) {\n    return getContactDataSphereAndPlane(a, b);\n  } else if (a instanceof Plane && b instanceof Box) {\n    return getContactDataBoxAndPlane(b, a);\n  } else if (a instanceof Plane && b instanceof Sphere) {\n    return getContactDataSphereAndPlane(b, a);\n  } else {\n    console.error(\"getting contact data between these types not implemented.\");\n    return {\n      a: a,\n      b: b,\n      type: \"none\",\n      contactNormal: new Vector3(0, 0, 1),\n      penetration: 0,\n      contactPoint: new Vector3(0, 0, 0),\n      edge_a: {\n        a: new Vector3(0, 0, 0),\n        b: new Vector3(0, 0, 0)\n      },\n      edge_b: {\n        a: new Vector3(0, 0, 0),\n        b: new Vector3(0, 0, 0)\n      }\n    };\n  }\n} // note: all getContact functions assume the objects already intersect.\n// convention: contact data is of format {a, b, type, contactNormal, penetration, contactPoint, ...} where contactNormal points from b to a\n// get contact data for two colliding boxes, assuming collision\n\nfunction getContactDataBoxes(a, b) {\n  const vector_ab = b.position.clone().sub(a.position);\n  const a_coordinateAxes = getCoordinateAxes(a);\n  const b_coordinateAxes = getCoordinateAxes(b);\n  let smallestOverlap = Infinity;\n  let contact;\n\n  for (let a_axis of a_coordinateAxes) {\n    const overlap = separatingAxisPenetration(a, b, a_axis);\n\n    if (overlap < smallestOverlap) {\n      smallestOverlap = overlap; // set contact\n\n      const axis = a_axis.clone();\n\n      if (vector_ab.dot(axis) < 0) {\n        // orient axis to normal of the correct face.\n        axis.multiplyScalar(-1);\n      }\n\n      axis.normalize();\n      const vertex = getClosestVertex(a, b, axis);\n      contact = {\n        a: b,\n        b: a,\n        type: \"vertex-face\",\n        contactNormal: axis,\n        penetration: smallestOverlap,\n        contactPoint: vertex,\n        edge_a: {\n          a: new Vector3(0, 0, 0),\n          b: new Vector3(0, 0, 0)\n        },\n        edge_b: {\n          a: new Vector3(0, 0, 0),\n          b: new Vector3(0, 0, 0)\n        }\n      };\n    }\n  }\n\n  for (let b_axis of b_coordinateAxes) {\n    const overlap = separatingAxisPenetration(a, b, b_axis);\n\n    if (overlap < smallestOverlap) {\n      smallestOverlap = overlap; // set contact\n\n      const axis = b_axis.clone();\n\n      if (vector_ab.clone().dot(axis) > 0) {\n        // orient axis to normal of the correct face.\n        axis.multiplyScalar(-1);\n      }\n\n      axis.normalize();\n      const vertex = getClosestVertex(b, a, axis);\n      contact = {\n        a: a,\n        b: b,\n        type: \"vertex-face\",\n        contactNormal: axis,\n        penetration: smallestOverlap,\n        contactPoint: vertex,\n        edge_a: {\n          a: new Vector3(0, 0, 0),\n          b: new Vector3(0, 0, 0)\n        },\n        edge_b: {\n          a: new Vector3(0, 0, 0),\n          b: new Vector3(0, 0, 0)\n        }\n      };\n    }\n  }\n\n  for (let a_axis of a_coordinateAxes) {\n    for (let b_axis of b_coordinateAxes) {\n      let m = a_axis.clone().cross(b_axis).normalize();\n\n      if (m.length() > 0.005) {\n        // check parallel edges\n        const overlap = separatingAxisPenetration(a, b, m);\n\n        if (overlap < smallestOverlap) {\n          smallestOverlap = overlap; // set contact\n\n          const axis = m.clone();\n\n          if (vector_ab.clone().dot(axis) > 0) {\n            axis.multiplyScalar(-1);\n          }\n\n          axis.normalize();\n          const edge_a = getClosestEdge(b, a, a_axis, m);\n          const edge_b = getClosestEdge(a, b, b_axis, m);\n          contact = {\n            a: a,\n            b: b,\n            type: \"edge-edge\",\n            contactNormal: axis,\n            penetration: smallestOverlap,\n            contactPoint: getClosestPointBetweenTwoEdges(edge_a, edge_b),\n            edge_a: edge_a,\n            edge_b: edge_b\n          };\n        }\n      } else {\n        // for now, ignore case where the corresponding edges are parallel.\n        continue;\n      }\n    }\n  }\n\n  return contact;\n}\n\nfunction getContactDataBoxAndSphere(box, sphere) {\n  // convert sphere center to box coordinate space\n  const inverseRotation = box.rotation.clone();\n  let sphereCenter = sphere.position.clone().sub(box.position).applyQuaternion(inverseRotation); // Clamp each coordinate to the box.\n\n  let closestPoint = sphereCenter.clone();\n  closestPoint.x = Math.max(Math.min(closestPoint.x, box.width / 2), -box.width / 2);\n  closestPoint.y = Math.max(Math.min(closestPoint.y, box.length / 2), -box.length / 2);\n  closestPoint.z = Math.max(Math.min(closestPoint.z, box.height / 2), -box.height / 2);\n  const distance = sphereCenter.clone().sub(closestPoint).length();\n  const penetration = sphere.radius - distance; // convert back to world space\n\n  closestPoint.applyQuaternion(box.rotation).add(box.position);\n  const contactPoint = closestPoint;\n  const contactNormal = closestPoint.clone().sub(sphere.position.clone()).normalize();\n  const contact = {\n    a: box,\n    b: sphere,\n    type: \"vertex-face\",\n    contactNormal: contactNormal,\n    penetration: penetration,\n    contactPoint: contactPoint,\n    edge_a: {\n      a: new Vector3(0, 0, 0),\n      b: new Vector3(0, 0, 0)\n    },\n    edge_b: {\n      a: new Vector3(0, 0, 0),\n      b: new Vector3(0, 0, 0)\n    }\n  };\n  return contact;\n}\n\nfunction getContactDataSpheres(a, b) {\n  const v_ab = b.position.clone().sub(a.position);\n  const contactPoint = a.position.clone().add(v_ab.clone().multiplyScalar(a.radius).sub(v_ab.clone().multiplyScalar(b.radius)).multiplyScalar(0.5));\n  const penetration = a.radius - b.radius - v_ab.length();\n  const contactNormal = v_ab.clone().multiplyScalar(-1).normalize();\n  const contact = {\n    a: a,\n    b: b,\n    type: \"vertex-face\",\n    contactNormal: contactNormal,\n    penetration: penetration,\n    contactPoint: contactPoint,\n    edge_a: {\n      a: new Vector3(0, 0, 0),\n      b: new Vector3(0, 0, 0)\n    },\n    edge_b: {\n      a: new Vector3(0, 0, 0),\n      b: new Vector3(0, 0, 0)\n    }\n  };\n  return contact;\n}\n\nfunction getContactDataBoxAndPlane(box, plane) {\n  const vertices = getVertices(box);\n  let contactPoint = vertices[0];\n  let penetration = 0;\n\n  for (let v of vertices) {\n    const relative_position = v.clone().sub(plane.position);\n    const d = relative_position.dot(plane.normal);\n\n    if (d < penetration) {\n      contactPoint = v;\n      penetration = d;\n    }\n  }\n\n  const contact = {\n    a: box,\n    b: plane,\n    type: \"vertex-face\",\n    contactNormal: plane.normal.clone(),\n    penetration: penetration,\n    contactPoint: contactPoint,\n    edge_a: {\n      a: new Vector3(0, 0, 0),\n      b: new Vector3(0, 0, 0)\n    },\n    edge_b: {\n      a: new Vector3(0, 0, 0),\n      b: new Vector3(0, 0, 0)\n    }\n  };\n  return contact;\n}\n\nfunction getContactDataSphereAndPlane(sphere, plane) {\n  const relativePosition = sphere.position.clone().sub(plane.position);\n  const d = relativePosition.dot(plane.normal); // distance to center of sphere, negative if center is below plane.\n\n  const penetration = sphere.radius - d;\n  const contactPoint = sphere.position.clone().addScaledVector(plane.normal, -sphere.radius);\n  const contact = {\n    a: sphere,\n    b: plane,\n    type: \"vertex-face\",\n    contactNormal: plane.normal.clone(),\n    penetration: penetration,\n    contactPoint: contactPoint,\n    edge_a: {\n      a: new Vector3(0, 0, 0),\n      b: new Vector3(0, 0, 0)\n    },\n    edge_b: {\n      a: new Vector3(0, 0, 0),\n      b: new Vector3(0, 0, 0)\n    }\n  };\n  return contact;\n}\n\nconst coefficient_of_restitution = 0.8;\nexport function resolveCollision(contactData) {\n  const a = contactData.a;\n  const b = contactData.b;\n  const normal = contactData.contactNormal;\n\n  if (contactData.type === \"vertex-face\") {\n    console.log(\"resolving vertex-face contact\");\n    const vertex = contactData.contactPoint;\n    const r_a = vertex.clone().sub(a.position);\n    const r_b = vertex.clone().sub(b.position);\n    const vertexVelocity_a = a.velocity.clone().add(a.getAngularVelocity().cross(r_a));\n    const vertexVelocity_b = b.velocity.clone().add(b.getAngularVelocity().cross(r_b));\n    const relativeVelocity = normal.dot(vertexVelocity_a.clone().sub(vertexVelocity_b));\n\n    if (relativeVelocity < 0) {\n      console.log(\"colliding contact\");\n      const I_inverse_a = a.getInertia().invert();\n      const I_inverse_b = b.getInertia().invert();\n      const term1 = normal.dot(r_a.clone().cross(normal).applyMatrix3(I_inverse_a).cross(r_a));\n      const term2 = normal.dot(r_b.clone().cross(normal).applyMatrix3(I_inverse_b).cross(r_b));\n      const j = -(1 + coefficient_of_restitution) * relativeVelocity / (a.inverseMass + b.inverseMass + term1 + term2);\n      console.log(\"relative Velocity: \", relativeVelocity);\n      const impulse = normal.clone().multiplyScalar(j);\n      const impulse2 = normal.clone().multiplyScalar(-j);\n      a.applyImpulse(vertex, impulse);\n      b.applyImpulse(vertex, impulse2);\n    } else if (relativeVelocity === 0) {\n      console.log(\"resting contact\");\n    } else {\n      // ignore\n      console.log(\"leaving\");\n    }\n  } else if (contactData.type === \"edge-edge\") {\n    console.log(\"resolving edge-edge contact\");\n    console.log(\"edge_a\", contactData.edge_a);\n    console.log(\"edge_b\", contactData.edge_b);\n    console.log(\"contactNormal: \", contactData.contactNormal);\n    const vertex = getClosestPointBetweenTwoEdges(contactData.edge_a, contactData.edge_b);\n    const r_a = vertex.clone().sub(a.position);\n    const r_b = vertex.clone().sub(b.position);\n    const vertexVelocity_a = a.velocity.clone().add(a.getAngularVelocity().cross(r_a));\n    const vertexVelocity_b = b.velocity.clone().add(b.getAngularVelocity().cross(r_b));\n    const relativeVelocity = normal.dot(vertexVelocity_a.clone().sub(vertexVelocity_b));\n\n    if (relativeVelocity < 0) {\n      console.log(\"colliding contact\");\n      const I_inverse_a = a.getInertia().invert();\n      let I_inverse_b = b.getInertia().invert();\n      const term1 = normal.dot(r_a.clone().cross(normal).applyMatrix3(I_inverse_a).cross(r_a));\n      const term2 = normal.dot(r_b.clone().cross(normal).applyMatrix3(I_inverse_b).cross(r_b));\n      const j = -(1 + coefficient_of_restitution) * relativeVelocity / (a.inverseMass + b.inverseMass + term1 + term2);\n      const impulse = normal.clone().multiplyScalar(j);\n      const impulse2 = normal.clone().multiplyScalar(-j);\n      a.applyImpulse(vertex, impulse);\n      b.applyImpulse(vertex, impulse2);\n    } else if (relativeVelocity === 0) {\n      console.log(\"resting contact\");\n    } else {\n      // ignore\n      console.log(\"leaving\");\n    }\n  } else {\n    console.error(\"contactData type not recognized.\");\n    console.log(\"contact data: \", contactData);\n  }\n} // returns closest edge of box b\n// edge should be parallel to input edgeVector\n\nfunction getClosestEdge(a, b, edgeVector, separatingAxis) {\n  const x = separatingAxis.x;\n  const y = separatingAxis.y;\n  const z = separatingAxis.z;\n  const projectionMatrix = new Matrix3();\n  projectionMatrix.set(x * x, x * y, x * z, x * y, y * y, y * z, x * z, y * z, z * z);\n  const a_center = a.position.clone().applyMatrix3(projectionMatrix);\n  const b_edges = getEdges(b);\n  const parallel_b_edges = [];\n\n  for (let b_edge of b_edges) {\n    const b_edgeVector = b_edge.b.clone().sub(b_edge.a);\n\n    if (b_edgeVector.clone().cross(edgeVector).length() < 0.005) {\n      parallel_b_edges.push(b_edge);\n    }\n  }\n\n  let closestEdge = parallel_b_edges[0];\n  let closestDistance = closestEdge.a.clone().sub(a_center).length();\n\n  for (let b_edge of parallel_b_edges) {\n    const d = b_edge.a.clone().sub(a_center).length();\n\n    if (d < closestDistance) {\n      closestDistance = d;\n      closestEdge = b_edge;\n    }\n  }\n\n  return closestEdge;\n} // returns closest vertex of box b to face of box a\n\n\nfunction getClosestVertex(a, b, lineVector) {\n  const a_vertices = getVertices(a);\n  const b_vertices = getVertices(b);\n  const x = lineVector.x;\n  const y = lineVector.y;\n  const z = lineVector.z;\n  const projectionMatrix = new Matrix3();\n  projectionMatrix.set(x * x, x * y, x * z, x * y, y * y, y * z, x * z, y * z, z * z);\n  const a_center = a.position.clone().applyMatrix3(projectionMatrix);\n  let a_radius = 0;\n\n  for (let a_v of a_vertices) {\n    const a_v_projection = a_v.clone().applyMatrix3(projectionMatrix);\n    const r = a_v_projection.clone().sub(a_center).length();\n\n    if (r > a_radius) {\n      a_radius = r;\n    }\n  }\n\n  const b_center = b.position.clone().applyMatrix3(projectionMatrix);\n  let vertex = b_vertices[0];\n  let smallestDistanceToA = b_center.clone().sub(a_center).length() - a_radius;\n\n  for (let b_v of b_vertices) {\n    const b_v_projection = b_v.clone().applyMatrix3(projectionMatrix);\n    const d = b_v_projection.clone().sub(a_center).length() - a_radius;\n\n    if (d < smallestDistanceToA) {\n      smallestDistanceToA = d;\n      vertex = b_v;\n    }\n  }\n\n  return vertex;\n}\n\nfunction separatingAxisPenetration(a, b, lineVector) {\n  const x = lineVector.x;\n  const y = lineVector.y;\n  const z = lineVector.z;\n  const projectionMatrix = new Matrix3();\n  projectionMatrix.set(x * x, x * y, x * z, x * y, y * y, y * z, x * z, y * z, z * z);\n  const a_center = a.position.clone().applyMatrix3(projectionMatrix);\n  const b_center = b.position.clone().applyMatrix3(projectionMatrix);\n  const d = b_center.clone().sub(a_center).length();\n  const a_vertices = getVertices(a);\n  const b_vertices = getVertices(b);\n  let r_a = 0,\n      r_b = 0;\n\n  for (let a_v of a_vertices) {\n    const a_v_projection = a_v.applyMatrix3(projectionMatrix);\n    const r = a_center.clone().sub(a_v_projection).length();\n\n    if (r > r_a) {\n      r_a = r;\n    }\n  }\n\n  for (let b_v of b_vertices) {\n    const b_v_projection = b_v.applyMatrix3(projectionMatrix);\n    const r = b_center.clone().sub(b_v_projection).length();\n\n    if (r > r_b) {\n      r_b = r;\n    }\n  } // returns the overlap. positive indicates overlap, negative indicates separation.\n\n\n  return r_a + r_b - d;\n}\n\nfunction getClosestPointBetweenTwoEdges(e1, e2) {\n  const p1 = e1.a;\n  const p2 = e1.b;\n  const p3 = e2.a;\n  const p4 = e2.b;\n  const v12 = p2.clone().sub(p1);\n  const v34 = p4.clone().sub(p3);\n  const v13 = p3.clone().sub(p1);\n  let s, t; // terms\n\n  const R_1_squared = v12.dot(v12);\n  const R_2_squared = v34.dot(v34);\n  const D_4321 = v12.dot(v34);\n  const D_3121 = v12.dot(v13);\n  const D_4331 = v13.dot(v34);\n  const denominator = D_4321 * D_4321 - R_1_squared * R_2_squared;\n  s = (D_4321 * D_4331 - R_2_squared * D_3121) / denominator;\n  t = (R_1_squared * D_4331 - D_4321 * D_3121) / denominator;\n  s = Math.max(Math.min(s, 1), 0);\n  t = Math.max(Math.min(t, 1), 0);\n  const point_a = e1.a.clone().add(v12.clone().multiplyScalar(s));\n  const point_b = e2.a.clone().add(v34.clone().multiplyScalar(t));\n  return point_a.clone().add(point_b).multiplyScalar(1 / 2);\n}\n\nfunction getCoordinateAxes(box) {\n  const x = new Vector3(1, 0, 0),\n        y = new Vector3(0, 1, 0),\n        z = new Vector3(0, 0, 1);\n  const axes = [x, y, z];\n\n  for (let axis of axes) {\n    axis.applyQuaternion(box.rotation);\n  }\n\n  return axes;\n}\n\nfunction getVertices(box) {\n  const x = box.position.x;\n  const y = box.position.y;\n  const z = box.position.z;\n  const v1 = new Vector3(x - box.width / 2, y - box.length / 2, z - box.height / 2);\n  const v2 = new Vector3(x - box.width / 2, y + box.length / 2, z - box.height / 2);\n  const v3 = new Vector3(x + box.width / 2, y + box.length / 2, z - box.height / 2);\n  const v4 = new Vector3(x + box.width / 2, y - box.length / 2, z - box.height / 2);\n  const v5 = new Vector3(x - box.width / 2, y - box.length / 2, z + box.height / 2);\n  const v6 = new Vector3(x - box.width / 2, y + box.length / 2, z + box.height / 2);\n  const v7 = new Vector3(x + box.width / 2, y + box.length / 2, z + box.height / 2);\n  const v8 = new Vector3(x + box.width / 2, y - box.length / 2, z + box.height / 2);\n  const vertices = [v1, v2, v3, v4, v5, v6, v7, v8]; // rotate vertices\n\n  for (let vertex of vertices) {\n    // convert to body space, apply rotation, convert back to world space\n    vertex.sub(box.position);\n    vertex.applyQuaternion(box.rotation);\n    vertex.add(box.position);\n  }\n\n  return vertices;\n}\n\nfunction getEdges(box) {\n  const x = box.position.x;\n  const y = box.position.y;\n  const z = box.position.z;\n  const v1 = new Vector3(x - box.width / 2, y - box.length / 2, z - box.height / 2);\n  const v2 = new Vector3(x - box.width / 2, y + box.length / 2, z - box.height / 2);\n  const v3 = new Vector3(x + box.width / 2, y + box.length / 2, z - box.height / 2);\n  const v4 = new Vector3(x + box.width / 2, y - box.length / 2, z - box.height / 2);\n  const v5 = new Vector3(x - box.width / 2, y - box.length / 2, z + box.height / 2);\n  const v6 = new Vector3(x - box.width / 2, y + box.length / 2, z + box.height / 2);\n  const v7 = new Vector3(x + box.width / 2, y + box.length / 2, z + box.height / 2);\n  const v8 = new Vector3(x + box.width / 2, y - box.length / 2, z + box.height / 2);\n  const vertices = [v1, v2, v3, v4, v5, v6, v7, v8]; // rotate vertices\n\n  for (let vertex of vertices) {\n    // convert to body space, apply rotation, convert back to world space\n    vertex.sub(box.position);\n    vertex.applyQuaternion(box.rotation);\n    vertex.add(box.position);\n  }\n\n  const edges = [];\n  edges.push({\n    a: v1,\n    b: v2\n  });\n  edges.push({\n    a: v1,\n    b: v4\n  });\n  edges.push({\n    a: v1,\n    b: v5\n  });\n  edges.push({\n    a: v2,\n    b: v3\n  });\n  edges.push({\n    a: v2,\n    b: v6\n  });\n  edges.push({\n    a: v3,\n    b: v4\n  });\n  edges.push({\n    a: v3,\n    b: v7\n  });\n  edges.push({\n    a: v4,\n    b: v8\n  });\n  edges.push({\n    a: v5,\n    b: v6\n  });\n  edges.push({\n    a: v5,\n    b: v8\n  });\n  edges.push({\n    a: v6,\n    b: v7\n  });\n  edges.push({\n    a: v7,\n    b: v8\n  });\n  return edges;\n}\n\nexport function getAllBoundingBoxIntersections(objects) {\n  // for now just sort against x-axis. Slightly better is to update axis based on one with highest variance\n  // worst case is still O(n^2)\n  function compareBoundingBoxes(a, b) {\n    const a_min = a.position.x - a.boundingBox.x / 2;\n    const b_min = b.position.x - b.boundingBox.x / 2;\n    return a_min - b_min;\n  } // sort objects along x-axis\n\n\n  const objectsCopy = [...objects];\n  objectsCopy.sort(compareBoundingBoxes); // sweep the array for collisions\n\n  const intersections = [];\n\n  for (let i = 0; i < objectsCopy.length - 1; i++) {\n    // test against all possible overlapping boxes following the current one.\n    for (let j = i + 1; j < objectsCopy.length; j++) {\n      // stop testing when AABBs are beyond the current AABB\n      const i_max = objectsCopy[i].position.x + objectsCopy[i].boundingBox.x / 2;\n      const j_min = objectsCopy[j].position.x - objectsCopy[j].boundingBox.x / 2;\n\n      if (j_min > i_max) {\n        break;\n      }\n\n      if (checkBoundingBoxIntersection(objectsCopy[i], objectsCopy[j])) {\n        intersections.push({\n          a: objectsCopy[i],\n          b: objectsCopy[j]\n        });\n      }\n    }\n  }\n\n  return intersections;\n}\n/**\n * for symmetrical objects, valid separating axis iff sum the radii (half_widths) of the projected intervals is less than the distance between the centers\n * @param a \n * @param b \n * @param lineVector a unit vector describing the direction of the line\n * @returns true if the lineVector is a separating axis\n */\n\n/*export function testSeparatingAxis(a: Box, b: Box, lineVector: Vector3): boolean {\n    const x = lineVector.x;\n    const y = lineVector.y;\n    const z = lineVector.z;\n    const projectionMatrix = new Matrix3();\n    projectionMatrix.set(\n        x*x, x*y, x*z,\n        x*y, y*y, y*z,\n        x*z, y*z, z*z\n    );\n\n    const a_center = a.position.clone().applyMatrix3(projectionMatrix);\n    const b_center = b.position.clone().applyMatrix3(projectionMatrix);\n    const d = b_center.clone().sub(a_center).length();\n\n    const a_vertices = getVertices(a);\n    const b_vertices = getVertices(b);\n    \n    let r_a = 0, r_b = 0;\n    for (let a_v of a_vertices) {\n        const a_v_projection = a_v.applyMatrix3(projectionMatrix);\n        const r = a_center.clone().sub(a_v_projection).length()\n        if (r > r_a) {\n            r_a = r;\n        }\n    }\n    for (let b_v of b_vertices) {\n        const b_v_projection = b_v.applyMatrix3(projectionMatrix);\n        const r = b_center.clone().sub(b_v_projection).length()\n        if (r > r_b) {\n            r_b = r;\n        }\n    }\n    if (r_a + r_b < d) {\n        return true;\n    }\n\n    return false;\n}*/\n\n/*\nexport function checkCollisionBoxes(a: Box, b: Box): boolean {\n    // two convex objects don't collide iff there exists a separating plane between them\n\n    // search for separating plane.\n    // either its contain a face of one polyhedra or it contains an edge of one polyhedra and is parallel to the edge of the other polyhedra.\n    \n    const a_facePlanes = getFacePlanes(a);\n    for (let facePlane of a_facePlanes) {\n        if (testSeparatingAxis(a, b, facePlane.normal)) {\n            return false;\n        };\n    }\n    const b_facePlanes = getFacePlanes(b);\n    for (let facePlane of b_facePlanes) {\n        if (testSeparatingAxis(a, b, facePlane.normal)) {\n            return false;\n        }\n    }\n\n    const a_edges = getEdges(a);\n    const b_edges = getEdges(b);\n\n    for (let i = 0; i < a_edges.length; i++) {\n        for (let j = 0; j < b_edges.length; j++) {\n            const edge_i = a_edges[i].b.clone().sub(a_edges[i].a);\n            const edge_j = b_edges[j].b.clone().sub(b_edges[j].a);\n            let m = edge_i.clone().cross(edge_j);\n            if (m.length() !== 0) { // note to self: should use epsilon when checking for zero vector to improve stability\n                if (testSeparatingAxis(a, b, m)) {\n                    return false;\n                }\n            } else {\n                const edge_n = b_edges[j].b.clone().sub(a_edges[i].a);\n                m = edge_i.clone().cross(edge_n);\n                if (m.length() !== 0) {\n                    testSeparatingAxis(a, b, m);\n                } else {\n                    return true; // since edge_i and edge_2 are colinear\n                }\n            }\n        }\n    }\n\n    return true;\n}*/\n\n/*\nfunction getFaces(box: Box) {\n    const x = box.position.x;\n    const y = box.position.y;\n    const z = box.position.z;\n    const v1 = new Vector3(x - box.width/2, y - box.length/2, z - box.height/2);\n    const v2 = new Vector3(x - box.width/2, y + box.length/2, z - box.height/2);\n    const v3 = new Vector3(x + box.width/2, y + box.length/2, z - box.height/2);\n    const v4 = new Vector3(x + box.width/2, y - box.length/2, z - box.height/2);\n    const v5 = new Vector3(x - box.width/2, y - box.length/2, z + box.height/2);\n    const v6 = new Vector3(x - box.width/2, y + box.length/2, z + box.height/2);\n    const v7 = new Vector3(x + box.width/2, y + box.length/2, z + box.height/2);\n    const v8 = new Vector3(x + box.width/2, y - box.length/2, z + box.height/2);\n    const vertices = [v1, v2, v3, v4, v5, v6, v7, v8];\n\n    // rotate vertices\n    for (let vertex of vertices) {\n        // convert to body space, apply rotation, convert back to world space\n        vertex.sub(box.position);\n        vertex.applyQuaternion(box.rotation);\n        vertex.add(box.position);\n    }\n    \n    const f1 = { edges: [{a: v1, b: v2}, {a: v1, b: v4}, {a: v2, b: v3}, {a: v3, b: v4}] }; // bottom\n    const f2 = { edges: [{a: v5, b: v6}, {a: v5, b: v8}, {a: v6, b: v7}, {a: v7, b: v8}] }; // top\n    const f3 = { edges: [{a: v1, b: v2}, {a: v1, b: v5}, {a: v5, b: v6}, {a: v6, b: v2}] }; // left\n    const f4 = { edges: [{a: v4, b: v8}, {a: v4, b: v3}, {a: v8, b: v7}, {a: v7, b: v3}] }; // right\n    const f5 = { edges: [{a: v1, b: v4}, {a: v1, b: v5}, {a: v5, b: v8}, {a: v8, b: v4}] }; // front\n    const f6 = { edges: [{a: v2, b: v3}, {a: v2, b: v6}, {a: v6, b: v7}, {a: v7, b: v3}] }; // back\n    const faces = [f1, f2, f3, f4, f5, f6];\n    return faces;\n}*/\n\n/*\nexport function getAllBoundingBoxIntersections(boxes: Box[]) {\n    // create and sort intervals along x, y, and z\n    const x_intervals = [];\n    const y_intervals = [];\n    const z_intervals = [];\n    for(let box of boxes) {\n        const x_min = box.position.x - box.boundingBox.x/2;\n        const x_max = box.position.x + box.boundingBox.x/2;\n        x_intervals.push({ type: \"min\", value: x_min, object: box});\n        x_intervals.push({ type: \"max\", value: x_max, object: box});\n\n        \n        const y_min = box.position.y - box.boundingBox.y/2;\n        const y_max = box.position.y + box.boundingBox.y/2;\n        y_intervals.push({ type: \"min\", value: y_min, object: box});\n        y_intervals.push({ type: \"max\", value: y_max, object: box});\n\n        const z_min = box.position.z - box.boundingBox.z/2;\n        const z_max = box.position.z + box.boundingBox.z/2;\n        z_intervals.push({ type: \"min\", value: z_min, object: box});\n        z_intervals.push({ type: \"max\", value: z_max, object: box});\n    }\n    // note to self: switch to insertion sort and use normal merge sort only during the initialization frame\n    x_intervals.sort((a, b) => a.value - b.value);\n    //y_intervals.sort((a, b) => a.value - b.value);\n    //z_intervals.sort((a, b) => a.value - b.value);\n\n    // create a list of active intervals\n    const activeIntervals = [];\n}*/\n\n/*\nexport class World2 {\n    private objects: any[] = [];\n    private currentLoopInterval: any = null;\n\n    private characterForce: Vector3;\n\n    constructor() {\n        this.objects = [];\n\n        this.characterForce = new Vector3(0, 0, 0);\n    }\n\n    startLoop(): void {\n        const currentInstance = this;\n\n        // stop current loop if it exits\n        this.stopCurrentLoop();\n\n        let lastTimeCalled = performance.now();\n        let fps = 0;\n        let times: any[] = [];\n\n        function step() {\n            // calculate fps\n            const now = performance.now();\n            while (times.length > 0 && times[0] <= now - 1000) {\n                times.shift();\n            }\n            times.push(now);\n            fps = times.length;\n            // console.log(\"fps: \", fps);\n\n            for (let i = 0; i < currentInstance.objects.length; i++) {\n                currentInstance.objects[i].integrate(dt);\n            }\n        }\n\n        this.currentLoopInterval = setInterval(step, dt * 1000);\n    }\n\n    // Stops current loop if it exists.\n    stopCurrentLoop(): void {\n        if (this.currentLoopInterval) {\n            clearInterval(this.currentLoopInterval);\n        }\n    }\n\n    addObject(obj: any): void {\n        this.objects.push(obj);\n    }\n\n    getObjects(): any[] {\n        return this.objects;\n    }\n\n    updateCharacterForce(f: Vector3) {\n        this.characterForce = f;\n    }\n\n    detectCollisions(): void {\n\n    }\n\n    checkCollisionSpheres(s1: Sphere, s2: Sphere) {\n        const d = (s1.position.clone().sub(s2.position)).length(); // distance between centers\n\n        // collision if distance between spheres is smaller than sub of radiuses\n        if (d < (s1.radius + s2.radius)) {\n            return true;\n        }\n        return false;\n    }\n\n    resolveCollisionSpheres(s1: Sphere, s2: Sphere) {\n        // find unit vectors from s1 to s2 and s2 to s1\n        const u12 = (s2.position.clone().sub(s1.position)).normalize();\n        const u21 = u12.clone().multiplyScalar(-1);\n\n        // find components of v1 and v2 along and perpendicular to u\n        const v1_along_u12 = u12.clone().multiplyScalar(u12.dot(s1.velocity));\n        const v2_along_u21 = u21.clone().multiplyScalar(u21.dot(s2.velocity));\n\n        const v1_perp_u12 = s1.velocity.clone().sub(v1_along_u12);\n        const v2_perp_u21 = s2.velocity.clone().sub(v2_along_u21);\n\n        // calculate new velocities along u, assuming elastic collision\n        const m1 = 1/s1.inverseMass;\n        const m2 = 1/s2.inverseMass;\n        const v1_along_u_new = (v1_along_u12.clone().multiplyScalar((m1-m2)/(m1+m2))).addScaledVector(v2_along_u21, (2*m2)/(m1+m2));\n        const v2_along_u_new = (v1_along_u12.clone().multiplyScalar((2*m1)/(m1+m2))).addScaledVector(v2_along_u21, -(m1-m2)/(m1+m2));\n\n        // calculate and set new velocities\n        const v1_new = v1_along_u_new.clone().add(v1_perp_u12);\n        const v2_new = v2_along_u_new.clone().add(v2_perp_u21);\n\n        console.log(\"u: \", u12);\n        console.log(\"v1_new: \", v1_new);\n        console.log(\"v2_new\", v2_new);\n    }\n\n    clearCurrentLoop(): void {\n        clearInterval(this.currentLoopInterval);\n    }\n}*/\n\n/*\nfunction getFacePlanes(box: Box) {\n    const x = box.position.x;\n    const y = box.position.y;\n    const z = box.position.z;\n    const v1 = new Vector3(x - box.width/2, y - box.length/2, z - box.height/2);\n    const v2 = new Vector3(x - box.width/2, y + box.length/2, z - box.height/2);\n    const v3 = new Vector3(x + box.width/2, y + box.length/2, z - box.height/2);\n    const v4 = new Vector3(x + box.width/2, y - box.length/2, z - box.height/2);\n    const v5 = new Vector3(x - box.width/2, y - box.length/2, z + box.height/2);\n    const v6 = new Vector3(x - box.width/2, y + box.length/2, z + box.height/2);\n    const v7 = new Vector3(x + box.width/2, y + box.length/2, z + box.height/2);\n    const v8 = new Vector3(x + box.width/2, y - box.length/2, z + box.height/2);\n    const vertices = [v1, v2, v3, v4, v5, v6, v7, v8];\n\n    // rotate vertices\n    for (let vertex of vertices) {\n        // convert to body space, apply rotation, convert back to world space\n        vertex.sub(box.position);\n        vertex.applyQuaternion(box.rotation);\n        vertex.add(box.position);\n    }\n    const face1 = { normal: ((v2.clone().sub(v1)).cross(v4.clone().sub(v1))).normalize(), point: v1 } // bottom plane\n    const face2 = { normal: ((v8.clone().sub(v5)).cross(v6.clone().sub(v5))).normalize(), point: v5 } // top plane\n    const face3 = { normal: ((v5.clone().sub(v1)).cross(v2.clone().sub(v1))).normalize(), point: v1 } // left plane\n    const face4 = { normal: ((v3.clone().sub(v4)).cross(v8.clone().sub(v4))).normalize(), point: v4 } // top plane\n    const face5 = { normal: ((v4.clone().sub(v1)).cross(v5.clone().sub(v1))).normalize(), point: v1 } // front plane\n    const face6 = { normal: ((v2.clone().sub(v3)).cross(v7.clone().sub(v3))).normalize(), point: v3 } // back plane\n    const facePlanes = [face1, face2, face3, face4, face5, face6];\n    return facePlanes;\n}*/","map":{"version":3,"names":["Matrix3","Vector3","Sphere","Box","Plane","World","constructor","objects","coefficient_of_restitution","dt","addObject","obj","push","getAllBoundingBoxIntersections","compareBoundingBoxes","a","b","a_min","position","x","boundingBox","b_min","objectsCopy","sort","intersections","i","length","j","i_max","j_min","checkBoundingBoxIntersection","tick","duration","object","integrateForceAccum","boundingBoxIntersections","contacts","getAllContacts","contact","resolveCollision","integrate","integrateForceAccumObjects","integrateObjects","contactData","normal","contactNormal","type","console","log","vertex","contactPoint","r_a","clone","sub","r_b","vertexVelocity_a","velocity","add","getAngularVelocity","cross","vertexVelocity_b","relativeVelocity","dot","I_inverse_a","getInertia","invert","I_inverse_b","term1","applyMatrix3","term2","inverseMass","impulse","multiplyScalar","impulse2","applyImpulse","edge_a","edge_b","getClosestPointBetweenTwoEdges","error","updateMeshes","updateMesh","updateBoundingBoxMesh","a_x_min","a_x_max","a_y_min","y","a_y_max","a_z_min","z","a_z_max","b_x_min","b_x_max","b_y_min","b_y_max","b_z_min","b_z_max","checkCollision","checkCollisionBoxes","checkCollisionBoxAndSphere","checkCollisionBoxAndPlane","checkCollisionSpheres","checkCollisionSphereAndPlane","a_coordinateAxes","getCoordinateAxes","b_coordinateAxes","faceAxis","separatingAxisPenetration","a_axis","b_axis","m","normalize","d","radius","sphere","plane","relativePosition","box","inverseRotation","rotation","sphereCenter","applyQuaternion","closestPoint","Math","max","min","width","height","distance","vertices","getVertices","v","relative_position","getContactData","getContactDataBoxes","getContactDataBoxAndSphere","getContactDataBoxAndPlane","getContactDataSpheres","getContactDataSphereAndPlane","penetration","vector_ab","smallestOverlap","Infinity","overlap","axis","getClosestVertex","getClosestEdge","v_ab","addScaledVector","edgeVector","separatingAxis","projectionMatrix","set","a_center","b_edges","getEdges","parallel_b_edges","b_edge","b_edgeVector","closestEdge","closestDistance","lineVector","a_vertices","b_vertices","a_radius","a_v","a_v_projection","r","b_center","smallestDistanceToA","b_v","b_v_projection","e1","e2","p1","p2","p3","p4","v12","v34","v13","s","t","R_1_squared","R_2_squared","D_4321","D_3121","D_4331","denominator","point_a","point_b","axes","v1","v2","v3","v4","v5","v6","v7","v8","edges"],"sources":["/Users/danny/Github/physics_engine_for_the_web/frontend/src/physics_engine/physics_engine.ts"],"sourcesContent":["import { Matrix3, Vector3 } from \"three\";\nimport * as THREE from \"three\";\nimport { Sphere } from \"./Sphere\";\nimport { Box } from \"./Box\";\nimport { Plane } from \"./Plane\";\n\nexport { Sphere } from \"./Sphere\";\nexport { Box } from \"./Box\";\nexport { Plane } from \"./Plane\";\n\nexport class World {\n    public objects: any[];\n    public coefficient_of_restitution: number = 0.8; // 0 is fully inelastic, 1 is fully elastic\n    public dt: number = 1/60; // time step in seconds\n\n    constructor() {\n        this.objects = [];\n    }\n\n    addObject(obj: any): void {\n        this.objects.push(obj);\n    }\n\n    getAllBoundingBoxIntersections() {\n        // for now just sort against x-axis. Slightly better is to update axis based on one with highest variance\n        // worst case is still O(n^2)\n    \n        function compareBoundingBoxes(a: any, b: any) {\n            const a_min = a.position.x - a.boundingBox.x/2;\n            const b_min = b.position.x - b.boundingBox.x/2;\n            return a_min - b_min;\n        }\n    \n        // sort objects along x-axis\n        const objectsCopy = [...this.objects];\n        objectsCopy.sort(compareBoundingBoxes);\n    \n        // sweep the array for collisions\n        const intersections = [];\n        for(let i = 0; i < objectsCopy.length - 1; i++) {\n            // test against all possible overlapping boxes following the current one.\n            for(let j = i + 1; j < objectsCopy.length; j++) {\n                // stop testing when AABBs are beyond the current AABB\n                const i_max = objectsCopy[i].position.x + objectsCopy[i].boundingBox.x/2;\n                const j_min = objectsCopy[j].position.x - objectsCopy[j].boundingBox.x/2;\n                if (j_min > i_max) {\n                    break;\n                }\n    \n                if (checkBoundingBoxIntersection(objectsCopy[i], objectsCopy[j])) {\n                    intersections.push({\n                        a: objectsCopy[i],\n                        b: objectsCopy[j]\n                    });\n                }\n            }\n        }\n        return intersections;\n    }\n\n    // applies the forceAccum, detects and resolves collisions, and finally updates the positions of all objects.\n    tick(duration: number): void {\n        for (let object of this.objects) {\n            if (object instanceof Plane) {\n                continue;\n            }\n\n            object.integrateForceAccum(duration);\n        }\n\n        const boundingBoxIntersections = this.getAllBoundingBoxIntersections();\n        const contacts = getAllContacts(boundingBoxIntersections);\n        \n        for (let contact of contacts) {\n            this.resolveCollision(contact);\n        }\n\n        for (let object of this.objects) {\n            if (object instanceof Plane) {\n                continue;\n            }\n\n            object.integrate(duration);\n        }\n    }\n\n    // integrates the forceAccum to update the velocity of each object\n    integrateForceAccumObjects(duration: number): void {\n        for(let object of this.objects) {\n            if (object instanceof Plane) {\n                continue;\n            }\n\n            object.integrateForceAccum(duration);\n        }\n    }\n\n    // integrates the velocities to update the position of each object\n    integrateObjects(duration: number): void {\n        for (let object of this.objects) {\n            if (object instanceof Plane) {\n                continue;\n            }\n\n            object.integrate(duration);\n        }\n    }\n\n    resolveCollision(contactData: any) {\n        const a = contactData.a;\n        const b = contactData.b;\n        const normal = contactData.contactNormal;\n        if (contactData.type === \"vertex-face\") {\n            console.log(\"resolving vertex-face contact\");\n            const vertex = contactData.contactPoint;\n            const r_a = vertex.clone().sub(a.position);\n            const r_b = vertex.clone().sub(b.position);\n            const vertexVelocity_a = a.velocity.clone().add(a.getAngularVelocity().cross(r_a));\n            const vertexVelocity_b = b.velocity.clone().add(b.getAngularVelocity().cross(r_b));\n            const relativeVelocity = normal.dot(vertexVelocity_a.clone().sub(vertexVelocity_b));\n            if (relativeVelocity < 0) {\n                console.log(\"colliding contact\");\n                \n                const I_inverse_a = a.getInertia().invert();\n                const I_inverse_b = b.getInertia().invert();\n    \n                const term1 = normal.dot(r_a.clone().cross(normal).applyMatrix3(I_inverse_a).cross(r_a));\n                const term2 = normal.dot(r_b.clone().cross(normal).applyMatrix3(I_inverse_b).cross(r_b));\n    \n                const j = -(1 + coefficient_of_restitution) * relativeVelocity / (a.inverseMass + b.inverseMass + term1 + term2);\n                console.log(\"relative Velocity: \", relativeVelocity);\n    \n                const impulse = normal.clone().multiplyScalar(j);\n                const impulse2 = normal.clone().multiplyScalar(-j);\n                a.applyImpulse(vertex, impulse);\n                b.applyImpulse(vertex, impulse2);\n            } else if (relativeVelocity === 0) {\n                console.log(\"resting contact\");\n            } else {\n                // ignore\n                console.log(\"leaving\");\n            }\n        } else if (contactData.type === \"edge-edge\") {\n            console.log(\"resolving edge-edge contact\");\n            console.log(\"edge_a\", contactData.edge_a);\n            console.log(\"edge_b\", contactData.edge_b);\n            console.log(\"contactNormal: \", contactData.contactNormal);\n    \n            const vertex = getClosestPointBetweenTwoEdges(contactData.edge_a, contactData.edge_b);\n            const r_a = vertex.clone().sub(a.position);\n            const r_b = vertex.clone().sub(b.position);\n            const vertexVelocity_a = a.velocity.clone().add(a.getAngularVelocity().cross(r_a));\n            const vertexVelocity_b = b.velocity.clone().add(b.getAngularVelocity().cross(r_b));\n            const relativeVelocity = normal.dot(vertexVelocity_a.clone().sub(vertexVelocity_b));\n            if (relativeVelocity < 0) {\n                console.log(\"colliding contact\");\n                \n                const I_inverse_a = a.getInertia().invert();\n                let I_inverse_b = b.getInertia().invert();\n    \n                const term1 = normal.dot(r_a.clone().cross(normal).applyMatrix3(I_inverse_a).cross(r_a));\n                const term2 = normal.dot(r_b.clone().cross(normal).applyMatrix3(I_inverse_b).cross(r_b));\n    \n                const j = -(1 + coefficient_of_restitution) * relativeVelocity / (a.inverseMass + b.inverseMass + term1 + term2);\n    \n                const impulse = normal.clone().multiplyScalar(j);\n                const impulse2 = normal.clone().multiplyScalar(-j);\n                a.applyImpulse(vertex, impulse);\n                b.applyImpulse(vertex, impulse2);\n            } else if (relativeVelocity === 0) {\n                console.log(\"resting contact\");\n            } else {\n                // ignore\n                console.log(\"leaving\");\n            }\n        } else {\n            console.error(\"contactData type not recognized.\");\n            console.log(\"contact data: \", contactData);\n        }\n    }\n\n    updateMeshes(): void {\n        for (let object of this.objects) {\n            if (object instanceof Plane) {\n                continue;\n            }\n\n            object.updateMesh();\n            object.updateBoundingBoxMesh();\n        }\n    }\n}\n\n/**\n * checks if the bounding box of two objects intersect\n * @param a the first object\n * @param b the other object\n */\nexport function checkBoundingBoxIntersection(a: any, b: any): boolean {\n    // create intervals\n    const a_x_min = a.position.x - a.boundingBox.x/2;\n    const a_x_max = a.position.x + a.boundingBox.x/2;\n    const a_y_min = a.position.y - a.boundingBox.y/2;\n    const a_y_max = a.position.y + a.boundingBox.y/2;\n    const a_z_min = a.position.z - a.boundingBox.z/2;\n    const a_z_max = a.position.z + a.boundingBox.z/2;\n    const b_x_min = b.position.x - b.boundingBox.x/2;\n    const b_x_max = b.position.x + b.boundingBox.x/2;\n    const b_y_min = b.position.y - b.boundingBox.y/2;\n    const b_y_max = b.position.y + b.boundingBox.y/2;\n    const b_z_min = b.position.z - b.boundingBox.z/2;\n    const b_z_max = b.position.z + b.boundingBox.z/2;\n\n    // intersecting if all intervals are intersecting\n    if ((a_x_min < b_x_max && b_x_min < a_x_max) &&\n        (a_y_min < b_y_max && b_y_min < a_y_max) &&\n        (a_z_min < b_z_max && b_z_min < a_z_max)) {\n        return true\n    }\n    return false;\n}\n\n// returns true if the two objects are intersecting\nexport function checkCollision(a: any, b: any): boolean {\n    if (a instanceof Box && b instanceof Box) {\n        return checkCollisionBoxes(a, b);\n    } else if (a instanceof Box && b instanceof Sphere) {\n        return checkCollisionBoxAndSphere(a, b);\n    } else if (a instanceof Box && b instanceof Plane) {\n        return checkCollisionBoxAndPlane(a, b);\n    } else if (a instanceof Sphere && b instanceof Box) {\n        return checkCollisionBoxAndSphere(b, a);\n    } else if (a instanceof Sphere && b instanceof Sphere) {\n        return checkCollisionSpheres(a, b);\n    } else if (a instanceof Sphere && b instanceof Plane) {\n        return checkCollisionSphereAndPlane(a, b);\n    } else if (a instanceof Plane && b instanceof Box) {\n        return checkCollisionBoxAndPlane(b, a);\n    } else if (a instanceof Plane && b instanceof Sphere) {\n        return checkCollisionSphereAndPlane(b, a);\n    } else {\n        console.error(\"checking collision between these types not implemented.\");\n    }\n}\n\nexport function checkCollisionBoxes(a: Box, b: Box): boolean {\n    // two convex objects don't collide iff there exists a separating plane between them\n\n    // search for separating plane.\n    // either its contain a face of one polyhedra or it contains an edge of one polyhedra and is parallel to the edge of the other polyhedra.\n\n    const a_coordinateAxes = getCoordinateAxes(a);\n    const b_coordinateAxes = getCoordinateAxes(b);\n\n    // check the 6 face axes\n    for (let faceAxis of a_coordinateAxes) {\n        if (separatingAxisPenetration(a, b, faceAxis) < 0) {\n            return false;\n        }\n    }\n    for (let faceAxis of b_coordinateAxes) {\n        if (separatingAxisPenetration(a, b, faceAxis) < 0) {\n            return false;\n        }\n    }\n\n    // check the 9 edge-edge axes\n    for (let a_axis of a_coordinateAxes) {\n        for (let b_axis of b_coordinateAxes) {\n            let m = a_axis.clone().cross(b_axis).normalize();\n            if (m.length() > 0) { // note to self: should use epsilon when checking for zero vector to  improve stability\n                if (separatingAxisPenetration(a, b, m) < 0) {\n                    return false;\n                }\n            } else {\n                // for now, ignore case where the corresponding edges are parallel.\n                continue;\n            }\n        }\n    }\n\n    return true;\n}\n\nexport function checkCollisionSpheres(a: Sphere, b: Sphere): boolean {\n    // two spheres intersect if the distance between their centers is not greater than the sum of their radii\n    const d = a.position.clone().sub(b.position).length();\n    return d <= a.radius + b.radius;\n}\n\nexport function checkCollisionSphereAndPlane(sphere: Sphere, plane: Plane) {\n    const relativePosition = sphere.position.clone().sub(plane.position);\n    const d = relativePosition.dot(plane.normal); // distance to center of sphere, negative if center is below plane.\n    return d <= sphere.radius;\n}\n\nexport function checkCollisionBoxAndSphere(box: Box, sphere: Sphere): boolean {\n    // convert sphere center to box coordinate space\n    const inverseRotation = box.rotation.clone();\n    let sphereCenter = sphere.position.clone().sub(box.position).applyQuaternion(inverseRotation);\n\n    // Clamp each coordinate to the box.\n    const closestPoint = sphereCenter.clone();\n    closestPoint.x = Math.max(Math.min(closestPoint.x, box.width/2), -box.width/2);\n    closestPoint.y = Math.max(Math.min(closestPoint.y, box.length/2), -box.length/2);\n    closestPoint.z = Math.max(Math.min(closestPoint.z, box.height/2), -box.height/2);\n\n    // check if they're in contact\n    const distance = sphereCenter.clone().sub(closestPoint).length();\n    return distance < sphere.radius;\n}\n\nexport function checkCollisionBoxAndPlane(box: Box, plane: Plane): boolean {\n    const vertices = getVertices(box);\n    for (let v of vertices) {\n        const relative_position = v.clone().sub(plane.position);\n        const d = relative_position.dot(plane.normal);\n        if (d < 0) {\n            return true;\n        }\n    }\n    return false;\n}\n\nexport function getAllContacts(boundingBoxIntersections: any[]) {\n    const contacts = [];\n    for(let i = 0; i < boundingBoxIntersections.length; i++) {\n        const a = boundingBoxIntersections[i].a;\n        const b = boundingBoxIntersections[i].b;\n\n        // check for collisions and color them\n        if (checkCollision(a, b)) {\n            const contact = getContactData(a, b);\n            contacts.push(contact);\n        }\n    }\n\n    return contacts;\n}\n\nexport function getContactData(a: any, b: any) {\n    if (a instanceof Box && b instanceof Box) {\n        return getContactDataBoxes(a, b);\n    } else if (a instanceof Box && b instanceof Sphere) {\n        return getContactDataBoxAndSphere(a, b);\n    } else if (a instanceof Box && b instanceof Plane) {\n        return getContactDataBoxAndPlane(a, b);\n    } else if (a instanceof Sphere && b instanceof Box) {\n        return getContactDataBoxAndSphere(b, a);\n    } else if (a instanceof Sphere && b instanceof Sphere) {\n        return getContactDataSpheres(a, b);\n    } else if (a instanceof Sphere && b instanceof Plane) {\n        return getContactDataSphereAndPlane(a, b);\n    } else if (a instanceof Plane && b instanceof Box) {\n        return getContactDataBoxAndPlane(b, a);\n    } else if (a instanceof Plane && b instanceof Sphere) {\n        return getContactDataSphereAndPlane(b, a);\n    } else {\n        console.error(\"getting contact data between these types not implemented.\");\n        return {\n            a: a,\n            b: b,\n            type: \"none\",\n            contactNormal: new Vector3(0, 0, 1),\n            penetration: 0,\n            contactPoint: new Vector3(0, 0, 0),\n            edge_a: { a: new Vector3(0, 0, 0), b: new Vector3(0, 0, 0) },\n            edge_b: { a: new Vector3(0, 0, 0), b: new Vector3(0, 0, 0) }\n        };\n    }\n}\n\n// note: all getContact functions assume the objects already intersect.\n\n// convention: contact data is of format {a, b, type, contactNormal, penetration, contactPoint, ...} where contactNormal points from b to a\n// get contact data for two colliding boxes, assuming collision\nfunction getContactDataBoxes(a: Box, b: Box) {\n    const vector_ab = b.position.clone().sub(a.position);\n    const a_coordinateAxes = getCoordinateAxes(a);\n    const b_coordinateAxes = getCoordinateAxes(b);\n    let smallestOverlap = Infinity;\n    let contact;\n\n    for (let a_axis of a_coordinateAxes) {\n        const overlap = separatingAxisPenetration(a, b, a_axis);\n        if (overlap < smallestOverlap) {\n            smallestOverlap = overlap;\n\n            // set contact\n            const axis = a_axis.clone();\n            if (vector_ab.dot(axis) < 0) { // orient axis to normal of the correct face.\n                axis.multiplyScalar(-1);\n            }\n            axis.normalize();\n            const vertex = getClosestVertex(a, b, axis);\n            contact = {\n                a: b,\n                b: a,\n                type: \"vertex-face\",\n                contactNormal: axis,\n                penetration: smallestOverlap,\n                contactPoint: vertex,\n                edge_a: { a: new Vector3(0, 0, 0), b: new Vector3(0, 0, 0) },\n                edge_b: { a: new Vector3(0, 0, 0), b: new Vector3(0, 0, 0) }\n            };\n        }\n    }\n    for (let b_axis of b_coordinateAxes) {\n        const overlap = separatingAxisPenetration(a, b, b_axis);\n        if (overlap < smallestOverlap) {\n            smallestOverlap = overlap;\n\n            // set contact\n            const axis = b_axis.clone();\n            if (vector_ab.clone().dot(axis) > 0) { // orient axis to normal of the correct face.\n                axis.multiplyScalar(-1);\n            }\n            axis.normalize();\n            const vertex = getClosestVertex(b, a, axis);\n            contact = {\n                a: a,\n                b: b, \n                type: \"vertex-face\",\n                contactNormal: axis,\n                penetration: smallestOverlap,\n                contactPoint: vertex,\n                edge_a: { a: new Vector3(0, 0, 0), b: new Vector3(0, 0, 0) },\n                edge_b: { a: new Vector3(0, 0, 0), b: new Vector3(0, 0, 0) }\n            };\n        }\n    }\n\n    for (let a_axis of a_coordinateAxes) {\n        for (let b_axis of b_coordinateAxes) {\n            let m = a_axis.clone().cross(b_axis).normalize();\n            if (m.length() > 0.005) { // check parallel edges\n                const overlap = separatingAxisPenetration(a, b, m);\n\n                if (overlap < smallestOverlap) {\n                    smallestOverlap = overlap;\n\n                    // set contact\n                    const axis = m.clone();\n                    if (vector_ab.clone().dot(axis) > 0) {\n                        axis.multiplyScalar(-1);\n                    }\n                    axis.normalize();\n                    const edge_a = getClosestEdge(b, a, a_axis, m);\n                    const edge_b = getClosestEdge(a, b, b_axis, m);\n                    contact = {\n                        a: a,\n                        b: b,\n                        type: \"edge-edge\",\n                        contactNormal: axis,\n                        penetration: smallestOverlap,\n                        contactPoint: getClosestPointBetweenTwoEdges(edge_a, edge_b),\n                        edge_a: edge_a,\n                        edge_b: edge_b\n                    };\n                }\n            } else {\n                // for now, ignore case where the corresponding edges are parallel.\n                continue;\n            }\n        }\n    }\n    \n    return contact;\n}\n\nfunction getContactDataBoxAndSphere(box: Box, sphere: Sphere) {\n    // convert sphere center to box coordinate space\n    const inverseRotation = box.rotation.clone();\n    let sphereCenter = sphere.position.clone().sub(box.position).applyQuaternion(inverseRotation);\n\n    // Clamp each coordinate to the box.\n    let closestPoint = sphereCenter.clone();\n    closestPoint.x = Math.max(Math.min(closestPoint.x, box.width/2), -box.width/2);\n    closestPoint.y = Math.max(Math.min(closestPoint.y, box.length/2), -box.length/2);\n    closestPoint.z = Math.max(Math.min(closestPoint.z, box.height/2), -box.height/2);\n\n    const distance = sphereCenter.clone().sub(closestPoint).length();\n    const penetration = sphere.radius - distance;\n\n    // convert back to world space\n    closestPoint.applyQuaternion(box.rotation).add(box.position);\n\n    const contactPoint = closestPoint;\n    const contactNormal = closestPoint.clone().sub(sphere.position.clone()).normalize();\n\n    const contact = {\n        a: box,\n        b: sphere,\n        type: \"vertex-face\",\n        contactNormal: contactNormal,\n        penetration: penetration,\n        contactPoint: contactPoint,\n        edge_a: { a: new Vector3(0, 0, 0), b: new Vector3(0, 0, 0) },\n        edge_b: { a: new Vector3(0, 0, 0), b: new Vector3(0, 0, 0) }\n    }\n    return contact;\n}\n\nfunction getContactDataSpheres(a: Sphere, b: Sphere) {\n    const v_ab = b.position.clone().sub(a.position);\n    const contactPoint = a.position.clone().add(v_ab.clone().multiplyScalar(a.radius).sub(v_ab.clone().multiplyScalar(b.radius)).multiplyScalar(0.5));\n    const penetration = a.radius - b.radius - v_ab.length()\n    const contactNormal = v_ab.clone().multiplyScalar(-1).normalize();\n    const contact = {\n        a: a,\n        b: b,\n        type: \"vertex-face\",\n        contactNormal: contactNormal,\n        penetration: penetration,\n        contactPoint: contactPoint,\n        edge_a: { a: new Vector3(0, 0, 0), b: new Vector3(0, 0, 0) },\n        edge_b: { a: new Vector3(0, 0, 0), b: new Vector3(0, 0, 0) }\n    }\n    return contact;\n}\n\nfunction getContactDataBoxAndPlane(box: Box, plane: Plane) {\n    const vertices = getVertices(box);\n    let contactPoint = vertices[0];\n    let penetration = 0;\n    \n    for (let v of vertices) {\n        const relative_position = v.clone().sub(plane.position);\n        const d = relative_position.dot(plane.normal);\n        if (d < penetration) {\n            contactPoint = v;\n            penetration = d;\n        }\n    }\n\n    const contact = {\n        a: box,\n        b: plane,\n        type: \"vertex-face\",\n        contactNormal: plane.normal.clone(),\n        penetration: penetration,\n        contactPoint: contactPoint,\n        edge_a: { a: new Vector3(0, 0, 0), b: new Vector3(0, 0, 0) },\n        edge_b: { a: new Vector3(0, 0, 0), b: new Vector3(0, 0, 0) }\n    };\n    return contact;\n}\n\nfunction getContactDataSphereAndPlane(sphere: Sphere, plane: Plane) {\n    const relativePosition = sphere.position.clone().sub(plane.position);\n    const d = relativePosition.dot(plane.normal); // distance to center of sphere, negative if center is below plane.\n    const penetration = sphere.radius - d;\n\n    const contactPoint = sphere.position.clone().addScaledVector(plane.normal, -sphere.radius);\n\n    const contact = {\n        a: sphere,\n        b: plane,\n        type: \"vertex-face\",\n        contactNormal: plane.normal.clone(),\n        penetration: penetration,\n        contactPoint: contactPoint,\n        edge_a: { a: new Vector3(0, 0, 0), b: new Vector3(0, 0, 0) },\n        edge_b: { a: new Vector3(0, 0, 0), b: new Vector3(0, 0, 0) }\n    };\n    return contact;\n}\n\nconst coefficient_of_restitution = 0.8;\nexport function resolveCollision(contactData: any) {\n    const a = contactData.a;\n    const b = contactData.b;\n    const normal = contactData.contactNormal;\n    if (contactData.type === \"vertex-face\") {\n        console.log(\"resolving vertex-face contact\");\n        const vertex = contactData.contactPoint;\n        const r_a = vertex.clone().sub(a.position);\n        const r_b = vertex.clone().sub(b.position);\n        const vertexVelocity_a = a.velocity.clone().add(a.getAngularVelocity().cross(r_a));\n        const vertexVelocity_b = b.velocity.clone().add(b.getAngularVelocity().cross(r_b));\n        const relativeVelocity = normal.dot(vertexVelocity_a.clone().sub(vertexVelocity_b));\n        if (relativeVelocity < 0) {\n            console.log(\"colliding contact\");\n            \n            const I_inverse_a = a.getInertia().invert();\n            const I_inverse_b = b.getInertia().invert();\n\n            const term1 = normal.dot(r_a.clone().cross(normal).applyMatrix3(I_inverse_a).cross(r_a));\n            const term2 = normal.dot(r_b.clone().cross(normal).applyMatrix3(I_inverse_b).cross(r_b));\n\n            const j = -(1 + coefficient_of_restitution) * relativeVelocity / (a.inverseMass + b.inverseMass + term1 + term2);\n            console.log(\"relative Velocity: \", relativeVelocity);\n\n            const impulse = normal.clone().multiplyScalar(j);\n            const impulse2 = normal.clone().multiplyScalar(-j);\n            a.applyImpulse(vertex, impulse);\n            b.applyImpulse(vertex, impulse2);\n        } else if (relativeVelocity === 0) {\n            console.log(\"resting contact\");\n        } else {\n            // ignore\n            console.log(\"leaving\");\n        }\n    } else if (contactData.type === \"edge-edge\") {\n        console.log(\"resolving edge-edge contact\");\n        console.log(\"edge_a\", contactData.edge_a);\n        console.log(\"edge_b\", contactData.edge_b);\n        console.log(\"contactNormal: \", contactData.contactNormal);\n\n        const vertex = getClosestPointBetweenTwoEdges(contactData.edge_a, contactData.edge_b);\n        const r_a = vertex.clone().sub(a.position);\n        const r_b = vertex.clone().sub(b.position);\n        const vertexVelocity_a = a.velocity.clone().add(a.getAngularVelocity().cross(r_a));\n        const vertexVelocity_b = b.velocity.clone().add(b.getAngularVelocity().cross(r_b));\n        const relativeVelocity = normal.dot(vertexVelocity_a.clone().sub(vertexVelocity_b));\n        if (relativeVelocity < 0) {\n            console.log(\"colliding contact\");\n            \n            const I_inverse_a = a.getInertia().invert();\n            let I_inverse_b = b.getInertia().invert();\n\n            const term1 = normal.dot(r_a.clone().cross(normal).applyMatrix3(I_inverse_a).cross(r_a));\n            const term2 = normal.dot(r_b.clone().cross(normal).applyMatrix3(I_inverse_b).cross(r_b));\n\n            const j = -(1 + coefficient_of_restitution) * relativeVelocity / (a.inverseMass + b.inverseMass + term1 + term2);\n\n            const impulse = normal.clone().multiplyScalar(j);\n            const impulse2 = normal.clone().multiplyScalar(-j);\n            a.applyImpulse(vertex, impulse);\n            b.applyImpulse(vertex, impulse2);\n        } else if (relativeVelocity === 0) {\n            console.log(\"resting contact\");\n        } else {\n            // ignore\n            console.log(\"leaving\");\n        }\n    } else {\n        console.error(\"contactData type not recognized.\");\n        console.log(\"contact data: \", contactData);\n    }\n}\n\n// returns closest edge of box b\n// edge should be parallel to input edgeVector\nfunction getClosestEdge(a: Box, b: Box, edgeVector: Vector3, separatingAxis: Vector3) {\n    const x = separatingAxis.x;\n    const y = separatingAxis.y;\n    const z = separatingAxis.z;\n    const projectionMatrix = new Matrix3();\n    projectionMatrix.set(\n        x*x, x*y, x*z,\n        x*y, y*y, y*z,\n        x*z, y*z, z*z\n    );\n\n    const a_center = a.position.clone().applyMatrix3(projectionMatrix);\n\n    const b_edges = getEdges(b);\n    const parallel_b_edges = [];\n    for (let b_edge of b_edges) {\n        const b_edgeVector = b_edge.b.clone().sub(b_edge.a);\n        if (b_edgeVector.clone().cross(edgeVector).length() < 0.005) {\n            parallel_b_edges.push(b_edge);\n        }\n    }\n\n    let closestEdge = parallel_b_edges[0];\n    let closestDistance = closestEdge.a.clone().sub(a_center).length();\n    for (let b_edge of parallel_b_edges) {\n        const d = b_edge.a.clone().sub(a_center).length();\n        if (d < closestDistance) {\n            closestDistance = d;\n            closestEdge = b_edge;\n        }\n    }\n\n    return closestEdge;\n}\n\n// returns closest vertex of box b to face of box a\nfunction getClosestVertex(a: Box, b: Box, lineVector: Vector3): Vector3 {\n    const a_vertices = getVertices(a);\n    const b_vertices = getVertices(b);\n\n    const x = lineVector.x;\n    const y = lineVector.y;\n    const z = lineVector.z;\n    const projectionMatrix = new Matrix3();\n    projectionMatrix.set(\n        x*x, x*y, x*z,\n        x*y, y*y, y*z,\n        x*z, y*z, z*z\n    );\n\n    const a_center = a.position.clone().applyMatrix3(projectionMatrix);\n\n    let a_radius = 0;\n\n    for (let a_v of a_vertices) {\n        const a_v_projection = a_v.clone().applyMatrix3(projectionMatrix);\n        const r = a_v_projection.clone().sub(a_center).length();\n        if (r > a_radius) {\n            a_radius = r;\n        }\n    }\n\n    const b_center = b.position.clone().applyMatrix3(projectionMatrix);\n    let vertex = b_vertices[0];\n    let smallestDistanceToA = b_center.clone().sub(a_center).length() - a_radius;\n\n    for (let b_v of b_vertices) {\n        const b_v_projection = b_v.clone().applyMatrix3(projectionMatrix);\n        const d = b_v_projection.clone().sub(a_center).length() - a_radius;\n        if (d < smallestDistanceToA) {\n            smallestDistanceToA = d;\n            vertex = b_v;\n        }\n    }\n\n    return vertex;\n}\n\nfunction separatingAxisPenetration(a: Box, b: Box, lineVector: Vector3): number {\n    const x = lineVector.x;\n    const y = lineVector.y;\n    const z = lineVector.z;\n    const projectionMatrix = new Matrix3();\n    projectionMatrix.set(\n        x*x, x*y, x*z,\n        x*y, y*y, y*z,\n        x*z, y*z, z*z\n    );\n\n    const a_center = a.position.clone().applyMatrix3(projectionMatrix);\n    const b_center = b.position.clone().applyMatrix3(projectionMatrix);\n    const d = b_center.clone().sub(a_center).length();\n\n    const a_vertices = getVertices(a);\n    const b_vertices = getVertices(b);\n\n    let r_a = 0, r_b = 0;\n    for (let a_v of a_vertices) {\n        const a_v_projection = a_v.applyMatrix3(projectionMatrix);\n        const r = a_center.clone().sub(a_v_projection).length()\n        if (r > r_a) {\n            r_a = r;\n        }\n    }\n    for (let b_v of b_vertices) {\n        const b_v_projection = b_v.applyMatrix3(projectionMatrix);\n        const r = b_center.clone().sub(b_v_projection).length()\n        if (r > r_b) {\n            r_b = r;\n        }\n    }\n\n    // returns the overlap. positive indicates overlap, negative indicates separation.\n    return r_a + r_b - d;\n}\n\nfunction getClosestPointBetweenTwoEdges(e1: any, e2: any) {\n    const p1 = e1.a;\n    const p2 = e1.b;\n    const p3 = e2.a;\n    const p4 = e2.b;\n\n    const v12 = p2.clone().sub(p1);\n    const v34 = p4.clone().sub(p3);\n    const v13 = p3.clone().sub(p1);\n\n    let s, t;\n\n    // terms\n    const R_1_squared = v12.dot(v12);\n    const R_2_squared = v34.dot(v34);\n    const D_4321 = v12.dot(v34);\n    const D_3121 = v12.dot(v13);\n    const D_4331 = v13.dot(v34);\n    const denominator = D_4321*D_4321 - R_1_squared*R_2_squared;\n\n    s = (D_4321*D_4331 - R_2_squared*D_3121) / denominator;\n    t = (R_1_squared*D_4331 - D_4321*D_3121) / denominator;\n\n    s = Math.max(Math.min(s, 1), 0);\n    t = Math.max(Math.min(t, 1), 0);\n\n    const point_a = e1.a.clone().add(v12.clone().multiplyScalar(s));\n    const point_b = e2.a.clone().add(v34.clone().multiplyScalar(t));\n\n    return point_a.clone().add(point_b).multiplyScalar(1/2);\n}\n\nfunction getCoordinateAxes(box: Box) {\n    const x = new Vector3(1, 0, 0), y = new Vector3(0, 1, 0), z = new Vector3(0, 0, 1);\n\n    const axes = [x, y, z];\n\n    for (let axis of axes) {\n        axis.applyQuaternion(box.rotation);\n    }\n    return axes;\n}\n\nfunction getVertices(box: Box) {\n    const x = box.position.x;\n    const y = box.position.y;\n    const z = box.position.z;\n    const v1 = new Vector3(x - box.width/2, y - box.length/2, z - box.height/2);\n    const v2 = new Vector3(x - box.width/2, y + box.length/2, z - box.height/2);\n    const v3 = new Vector3(x + box.width/2, y + box.length/2, z - box.height/2);\n    const v4 = new Vector3(x + box.width/2, y - box.length/2, z - box.height/2);\n    const v5 = new Vector3(x - box.width/2, y - box.length/2, z + box.height/2);\n    const v6 = new Vector3(x - box.width/2, y + box.length/2, z + box.height/2);\n    const v7 = new Vector3(x + box.width/2, y + box.length/2, z + box.height/2);\n    const v8 = new Vector3(x + box.width/2, y - box.length/2, z + box.height/2);\n    const vertices = [v1, v2, v3, v4, v5, v6, v7, v8];\n\n    // rotate vertices\n    for (let vertex of vertices) {\n        // convert to body space, apply rotation, convert back to world space\n        vertex.sub(box.position);\n        vertex.applyQuaternion(box.rotation);\n        vertex.add(box.position);\n    }\n\n    return vertices;\n}\n\nfunction getEdges(box: Box) {\n    const x = box.position.x;\n    const y = box.position.y;\n    const z = box.position.z;\n    const v1 = new Vector3(x - box.width/2, y - box.length/2, z - box.height/2);\n    const v2 = new Vector3(x - box.width/2, y + box.length/2, z - box.height/2);\n    const v3 = new Vector3(x + box.width/2, y + box.length/2, z - box.height/2);\n    const v4 = new Vector3(x + box.width/2, y - box.length/2, z - box.height/2);\n    const v5 = new Vector3(x - box.width/2, y - box.length/2, z + box.height/2);\n    const v6 = new Vector3(x - box.width/2, y + box.length/2, z + box.height/2);\n    const v7 = new Vector3(x + box.width/2, y + box.length/2, z + box.height/2);\n    const v8 = new Vector3(x + box.width/2, y - box.length/2, z + box.height/2);\n    const vertices = [v1, v2, v3, v4, v5, v6, v7, v8];\n\n    // rotate vertices\n    for (let vertex of vertices) {\n        // convert to body space, apply rotation, convert back to world space\n        vertex.sub(box.position);\n        vertex.applyQuaternion(box.rotation);\n        vertex.add(box.position);\n    }\n\n    const edges = [];\n    edges.push({a: v1, b: v2});\n    edges.push({a: v1, b: v4});\n    edges.push({a: v1, b: v5});\n    edges.push({a: v2, b: v3});\n    edges.push({a: v2, b: v6});\n    edges.push({a: v3, b: v4});\n    edges.push({a: v3, b: v7});\n    edges.push({a: v4, b: v8});\n    edges.push({a: v5, b: v6});\n    edges.push({a: v5, b: v8});\n    edges.push({a: v6, b: v7});\n    edges.push({a: v7, b: v8});\n\n    return edges;\n}\n\nexport function getAllBoundingBoxIntersections(objects: any[]) {\n    // for now just sort against x-axis. Slightly better is to update axis based on one with highest variance\n    // worst case is still O(n^2)\n\n    function compareBoundingBoxes(a: any, b: any) {\n        const a_min = a.position.x - a.boundingBox.x/2;\n        const b_min = b.position.x - b.boundingBox.x/2;\n        return a_min - b_min;\n    }\n\n    // sort objects along x-axis\n    const objectsCopy = [...objects];\n    objectsCopy.sort(compareBoundingBoxes);\n\n    // sweep the array for collisions\n    const intersections = [];\n    for(let i = 0; i < objectsCopy.length - 1; i++) {\n        // test against all possible overlapping boxes following the current one.\n        for(let j = i + 1; j < objectsCopy.length; j++) {\n            // stop testing when AABBs are beyond the current AABB\n            const i_max = objectsCopy[i].position.x + objectsCopy[i].boundingBox.x/2;\n            const j_min = objectsCopy[j].position.x - objectsCopy[j].boundingBox.x/2;\n            if (j_min > i_max) {\n                break;\n            }\n\n            if (checkBoundingBoxIntersection(objectsCopy[i], objectsCopy[j])) {\n                intersections.push({\n                    a: objectsCopy[i],\n                    b: objectsCopy[j]\n                });\n            }\n        }\n    }\n    return intersections;\n}\n\n/**\n * for symmetrical objects, valid separating axis iff sum the radii (half_widths) of the projected intervals is less than the distance between the centers\n * @param a \n * @param b \n * @param lineVector a unit vector describing the direction of the line\n * @returns true if the lineVector is a separating axis\n */\n/*export function testSeparatingAxis(a: Box, b: Box, lineVector: Vector3): boolean {\n    const x = lineVector.x;\n    const y = lineVector.y;\n    const z = lineVector.z;\n    const projectionMatrix = new Matrix3();\n    projectionMatrix.set(\n        x*x, x*y, x*z,\n        x*y, y*y, y*z,\n        x*z, y*z, z*z\n    );\n\n    const a_center = a.position.clone().applyMatrix3(projectionMatrix);\n    const b_center = b.position.clone().applyMatrix3(projectionMatrix);\n    const d = b_center.clone().sub(a_center).length();\n\n    const a_vertices = getVertices(a);\n    const b_vertices = getVertices(b);\n    \n    let r_a = 0, r_b = 0;\n    for (let a_v of a_vertices) {\n        const a_v_projection = a_v.applyMatrix3(projectionMatrix);\n        const r = a_center.clone().sub(a_v_projection).length()\n        if (r > r_a) {\n            r_a = r;\n        }\n    }\n    for (let b_v of b_vertices) {\n        const b_v_projection = b_v.applyMatrix3(projectionMatrix);\n        const r = b_center.clone().sub(b_v_projection).length()\n        if (r > r_b) {\n            r_b = r;\n        }\n    }\n    if (r_a + r_b < d) {\n        return true;\n    }\n\n    return false;\n}*/\n\n/*\nexport function checkCollisionBoxes(a: Box, b: Box): boolean {\n    // two convex objects don't collide iff there exists a separating plane between them\n\n    // search for separating plane.\n    // either its contain a face of one polyhedra or it contains an edge of one polyhedra and is parallel to the edge of the other polyhedra.\n    \n    const a_facePlanes = getFacePlanes(a);\n    for (let facePlane of a_facePlanes) {\n        if (testSeparatingAxis(a, b, facePlane.normal)) {\n            return false;\n        };\n    }\n    const b_facePlanes = getFacePlanes(b);\n    for (let facePlane of b_facePlanes) {\n        if (testSeparatingAxis(a, b, facePlane.normal)) {\n            return false;\n        }\n    }\n\n    const a_edges = getEdges(a);\n    const b_edges = getEdges(b);\n\n    for (let i = 0; i < a_edges.length; i++) {\n        for (let j = 0; j < b_edges.length; j++) {\n            const edge_i = a_edges[i].b.clone().sub(a_edges[i].a);\n            const edge_j = b_edges[j].b.clone().sub(b_edges[j].a);\n            let m = edge_i.clone().cross(edge_j);\n            if (m.length() !== 0) { // note to self: should use epsilon when checking for zero vector to improve stability\n                if (testSeparatingAxis(a, b, m)) {\n                    return false;\n                }\n            } else {\n                const edge_n = b_edges[j].b.clone().sub(a_edges[i].a);\n                m = edge_i.clone().cross(edge_n);\n                if (m.length() !== 0) {\n                    testSeparatingAxis(a, b, m);\n                } else {\n                    return true; // since edge_i and edge_2 are colinear\n                }\n            }\n        }\n    }\n\n    return true;\n}*/\n\n/*\nfunction getFaces(box: Box) {\n    const x = box.position.x;\n    const y = box.position.y;\n    const z = box.position.z;\n    const v1 = new Vector3(x - box.width/2, y - box.length/2, z - box.height/2);\n    const v2 = new Vector3(x - box.width/2, y + box.length/2, z - box.height/2);\n    const v3 = new Vector3(x + box.width/2, y + box.length/2, z - box.height/2);\n    const v4 = new Vector3(x + box.width/2, y - box.length/2, z - box.height/2);\n    const v5 = new Vector3(x - box.width/2, y - box.length/2, z + box.height/2);\n    const v6 = new Vector3(x - box.width/2, y + box.length/2, z + box.height/2);\n    const v7 = new Vector3(x + box.width/2, y + box.length/2, z + box.height/2);\n    const v8 = new Vector3(x + box.width/2, y - box.length/2, z + box.height/2);\n    const vertices = [v1, v2, v3, v4, v5, v6, v7, v8];\n\n    // rotate vertices\n    for (let vertex of vertices) {\n        // convert to body space, apply rotation, convert back to world space\n        vertex.sub(box.position);\n        vertex.applyQuaternion(box.rotation);\n        vertex.add(box.position);\n    }\n    \n    const f1 = { edges: [{a: v1, b: v2}, {a: v1, b: v4}, {a: v2, b: v3}, {a: v3, b: v4}] }; // bottom\n    const f2 = { edges: [{a: v5, b: v6}, {a: v5, b: v8}, {a: v6, b: v7}, {a: v7, b: v8}] }; // top\n    const f3 = { edges: [{a: v1, b: v2}, {a: v1, b: v5}, {a: v5, b: v6}, {a: v6, b: v2}] }; // left\n    const f4 = { edges: [{a: v4, b: v8}, {a: v4, b: v3}, {a: v8, b: v7}, {a: v7, b: v3}] }; // right\n    const f5 = { edges: [{a: v1, b: v4}, {a: v1, b: v5}, {a: v5, b: v8}, {a: v8, b: v4}] }; // front\n    const f6 = { edges: [{a: v2, b: v3}, {a: v2, b: v6}, {a: v6, b: v7}, {a: v7, b: v3}] }; // back\n    const faces = [f1, f2, f3, f4, f5, f6];\n    return faces;\n}*/\n\n/*\nexport function getAllBoundingBoxIntersections(boxes: Box[]) {\n    // create and sort intervals along x, y, and z\n    const x_intervals = [];\n    const y_intervals = [];\n    const z_intervals = [];\n    for(let box of boxes) {\n        const x_min = box.position.x - box.boundingBox.x/2;\n        const x_max = box.position.x + box.boundingBox.x/2;\n        x_intervals.push({ type: \"min\", value: x_min, object: box});\n        x_intervals.push({ type: \"max\", value: x_max, object: box});\n\n        \n        const y_min = box.position.y - box.boundingBox.y/2;\n        const y_max = box.position.y + box.boundingBox.y/2;\n        y_intervals.push({ type: \"min\", value: y_min, object: box});\n        y_intervals.push({ type: \"max\", value: y_max, object: box});\n\n        const z_min = box.position.z - box.boundingBox.z/2;\n        const z_max = box.position.z + box.boundingBox.z/2;\n        z_intervals.push({ type: \"min\", value: z_min, object: box});\n        z_intervals.push({ type: \"max\", value: z_max, object: box});\n    }\n    // note to self: switch to insertion sort and use normal merge sort only during the initialization frame\n    x_intervals.sort((a, b) => a.value - b.value);\n    //y_intervals.sort((a, b) => a.value - b.value);\n    //z_intervals.sort((a, b) => a.value - b.value);\n\n    // create a list of active intervals\n    const activeIntervals = [];\n}*/\n\n/*\nexport class World2 {\n    private objects: any[] = [];\n    private currentLoopInterval: any = null;\n\n    private characterForce: Vector3;\n\n    constructor() {\n        this.objects = [];\n\n        this.characterForce = new Vector3(0, 0, 0);\n    }\n\n    startLoop(): void {\n        const currentInstance = this;\n\n        // stop current loop if it exits\n        this.stopCurrentLoop();\n\n        let lastTimeCalled = performance.now();\n        let fps = 0;\n        let times: any[] = [];\n\n        function step() {\n            // calculate fps\n            const now = performance.now();\n            while (times.length > 0 && times[0] <= now - 1000) {\n                times.shift();\n            }\n            times.push(now);\n            fps = times.length;\n            // console.log(\"fps: \", fps);\n\n            for (let i = 0; i < currentInstance.objects.length; i++) {\n                currentInstance.objects[i].integrate(dt);\n            }\n        }\n\n        this.currentLoopInterval = setInterval(step, dt * 1000);\n    }\n\n    // Stops current loop if it exists.\n    stopCurrentLoop(): void {\n        if (this.currentLoopInterval) {\n            clearInterval(this.currentLoopInterval);\n        }\n    }\n\n    addObject(obj: any): void {\n        this.objects.push(obj);\n    }\n\n    getObjects(): any[] {\n        return this.objects;\n    }\n\n    updateCharacterForce(f: Vector3) {\n        this.characterForce = f;\n    }\n\n    detectCollisions(): void {\n\n    }\n\n    checkCollisionSpheres(s1: Sphere, s2: Sphere) {\n        const d = (s1.position.clone().sub(s2.position)).length(); // distance between centers\n\n        // collision if distance between spheres is smaller than sub of radiuses\n        if (d < (s1.radius + s2.radius)) {\n            return true;\n        }\n        return false;\n    }\n\n    resolveCollisionSpheres(s1: Sphere, s2: Sphere) {\n        // find unit vectors from s1 to s2 and s2 to s1\n        const u12 = (s2.position.clone().sub(s1.position)).normalize();\n        const u21 = u12.clone().multiplyScalar(-1);\n\n        // find components of v1 and v2 along and perpendicular to u\n        const v1_along_u12 = u12.clone().multiplyScalar(u12.dot(s1.velocity));\n        const v2_along_u21 = u21.clone().multiplyScalar(u21.dot(s2.velocity));\n\n        const v1_perp_u12 = s1.velocity.clone().sub(v1_along_u12);\n        const v2_perp_u21 = s2.velocity.clone().sub(v2_along_u21);\n\n        // calculate new velocities along u, assuming elastic collision\n        const m1 = 1/s1.inverseMass;\n        const m2 = 1/s2.inverseMass;\n        const v1_along_u_new = (v1_along_u12.clone().multiplyScalar((m1-m2)/(m1+m2))).addScaledVector(v2_along_u21, (2*m2)/(m1+m2));\n        const v2_along_u_new = (v1_along_u12.clone().multiplyScalar((2*m1)/(m1+m2))).addScaledVector(v2_along_u21, -(m1-m2)/(m1+m2));\n\n        // calculate and set new velocities\n        const v1_new = v1_along_u_new.clone().add(v1_perp_u12);\n        const v2_new = v2_along_u_new.clone().add(v2_perp_u21);\n\n        console.log(\"u: \", u12);\n        console.log(\"v1_new: \", v1_new);\n        console.log(\"v2_new\", v2_new);\n    }\n\n    clearCurrentLoop(): void {\n        clearInterval(this.currentLoopInterval);\n    }\n}*/\n\n/*\nfunction getFacePlanes(box: Box) {\n    const x = box.position.x;\n    const y = box.position.y;\n    const z = box.position.z;\n    const v1 = new Vector3(x - box.width/2, y - box.length/2, z - box.height/2);\n    const v2 = new Vector3(x - box.width/2, y + box.length/2, z - box.height/2);\n    const v3 = new Vector3(x + box.width/2, y + box.length/2, z - box.height/2);\n    const v4 = new Vector3(x + box.width/2, y - box.length/2, z - box.height/2);\n    const v5 = new Vector3(x - box.width/2, y - box.length/2, z + box.height/2);\n    const v6 = new Vector3(x - box.width/2, y + box.length/2, z + box.height/2);\n    const v7 = new Vector3(x + box.width/2, y + box.length/2, z + box.height/2);\n    const v8 = new Vector3(x + box.width/2, y - box.length/2, z + box.height/2);\n    const vertices = [v1, v2, v3, v4, v5, v6, v7, v8];\n\n    // rotate vertices\n    for (let vertex of vertices) {\n        // convert to body space, apply rotation, convert back to world space\n        vertex.sub(box.position);\n        vertex.applyQuaternion(box.rotation);\n        vertex.add(box.position);\n    }\n    const face1 = { normal: ((v2.clone().sub(v1)).cross(v4.clone().sub(v1))).normalize(), point: v1 } // bottom plane\n    const face2 = { normal: ((v8.clone().sub(v5)).cross(v6.clone().sub(v5))).normalize(), point: v5 } // top plane\n    const face3 = { normal: ((v5.clone().sub(v1)).cross(v2.clone().sub(v1))).normalize(), point: v1 } // left plane\n    const face4 = { normal: ((v3.clone().sub(v4)).cross(v8.clone().sub(v4))).normalize(), point: v4 } // top plane\n    const face5 = { normal: ((v4.clone().sub(v1)).cross(v5.clone().sub(v1))).normalize(), point: v1 } // front plane\n    const face6 = { normal: ((v2.clone().sub(v3)).cross(v7.clone().sub(v3))).normalize(), point: v3 } // back plane\n    const facePlanes = [face1, face2, face3, face4, face5, face6];\n    return facePlanes;\n}*/"],"mappings":"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CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA"},"metadata":{},"sourceType":"module"}