{"ast":null,"code":"import { Vector3 } from \"three\";\n// import { Sphere } from \"three\";\nconst dt = 1 / 60; // time step in seconds\n\nexport class World {\n  constructor() {\n    this.objects = [];\n    this.currentLoopInterval = null;\n    this.characterForce = void 0;\n    this.objects = [];\n    this.characterForce = new Vector3(0, 0, 0);\n  }\n\n  startLoop() {\n    const currentInstance = this; // stop current loop if it exits\n\n    this.stopCurrentLoop();\n    let lastTimeCalled = performance.now();\n    let fps = 0;\n    let times = [];\n\n    function step() {\n      // calculate fps\n      const now = performance.now();\n\n      while (times.length > 0 && times[0] <= now - 1000) {\n        times.shift();\n      }\n\n      times.push(now);\n      fps = times.length; // console.log(\"fps: \", fps);\n\n      for (let i = 0; i < currentInstance.objects.length; i++) {\n        currentInstance.objects[i].integrate(dt);\n      }\n    }\n\n    this.currentLoopInterval = setInterval(step, dt * 1000);\n  }\n  /** Stops current loop if it exists. */\n\n\n  stopCurrentLoop() {\n    if (this.currentLoopInterval) {\n      clearInterval(this.currentLoopInterval);\n    }\n  }\n\n  addObject(obj) {\n    this.objects.push(obj);\n  }\n\n  getObjects() {\n    return this.objects;\n  }\n\n  updateCharacterForce(f) {\n    this.characterForce = f;\n  }\n\n  detectCollisions() {}\n\n  checkCollisionSpheres(s1, s2) {\n    const d = s1.position.clone().sub(s2.position).length(); // distance between centers\n    // collision if distance between spheres is smaller than sub of radiuses\n\n    if (d < s1.radius + s2.radius) {\n      return true;\n    }\n\n    return false;\n  }\n\n  resolveCollisionSpheres(s1, s2) {\n    // find unit vectors from s1 to s2 and s2 to s1\n    const u12 = s2.position.clone().sub(s1.position).normalize();\n    const u21 = u12.clone().multiplyScalar(-1); // find components of v1 and v2 along and perpendicular to u\n\n    const v1_along_u12 = u12.clone().multiplyScalar(u12.dot(s1.velocity));\n    const v2_along_u21 = u21.clone().multiplyScalar(u21.dot(s2.velocity));\n    const v1_perp_u12 = s1.velocity.clone().sub(v1_along_u12);\n    const v2_perp_u21 = s2.velocity.clone().sub(v2_along_u21); // calculate new velocities along u, assuming elastic collision\n\n    const m1 = 1 / s1.inverseMass;\n    const m2 = 1 / s2.inverseMass;\n    const v1_along_u_new = v1_along_u12.clone().multiplyScalar((m1 - m2) / (m1 + m2)).addScaledVector(v2_along_u21, 2 * m2 / (m1 + m2));\n    const v2_along_u_new = v1_along_u12.clone().multiplyScalar(2 * m1 / (m1 + m2)).addScaledVector(v2_along_u21, -(m1 - m2) / (m1 + m2)); // calculate and set new velocities\n\n    const v1_new = v1_along_u_new.clone().add(v1_perp_u12);\n    const v2_new = v2_along_u_new.clone().add(v2_perp_u21);\n    console.log(\"u: \", u12);\n    console.log(\"v1_new: \", v1_new);\n    console.log(\"v2_new\", v2_new);\n  }\n\n  clearCurrentLoop() {\n    clearInterval(this.currentLoopInterval);\n  }\n\n}\n/**\n * checks if the bounding box of two objects intersect\n * @param a the first object\n * @param b the other object\n */\n\nexport function checkBoundingBoxIntersection(a, b) {\n  // create intervals\n  const a_x_min = a.position.x - a.boundingBox.x / 2;\n  const a_x_max = a.position.x + a.boundingBox.x / 2;\n  const a_y_min = a.position.y - a.boundingBox.y / 2;\n  const a_y_max = a.position.y + a.boundingBox.y / 2;\n  const a_z_min = a.position.z - a.boundingBox.z / 2;\n  const a_z_max = a.position.z + a.boundingBox.z / 2;\n  const b_x_min = b.position.x - b.boundingBox.x / 2;\n  const b_x_max = b.position.x + b.boundingBox.x / 2;\n  const b_y_min = b.position.y - b.boundingBox.y / 2;\n  const b_y_max = b.position.y + b.boundingBox.y / 2;\n  const b_z_min = b.position.z - b.boundingBox.z / 2;\n  const b_z_max = b.position.z + b.boundingBox.z / 2; // intersecting if all intervals are intersecting\n\n  if (a_x_min < b_x_max && b_x_min < a_x_max && a_y_min < b_y_max && b_y_min < a_y_max && a_z_min < b_z_max && b_z_min < a_z_max) {\n    return true;\n  }\n\n  return false;\n}\nexport function getAllBoundingBoxIntersections(boxes) {\n  // for now just sort against x-axis. Slightly better is to update axis based on one with highest variance\n  // worst case is still O(n^2)\n  function compareBoundingBoxes(a, b) {\n    const a_min = a.position.x - a.boundingBox.x / 2;\n    const b_min = b.position.x - b.boundingBox.x / 2;\n    return a_min - b_min;\n  } // sort objects along x-axis\n\n\n  const boxesCopy = [...boxes];\n  boxesCopy.sort(compareBoundingBoxes); // sweep the array for collisions\n\n  const intersections = [];\n\n  for (let i = 0; i < boxesCopy.length - 1; i++) {\n    // test against all possible overlapping boxes following the current one.\n    for (let j = i + 1; j < boxesCopy.length; j++) {\n      // stop testing when AABBs are beyond the current AABB\n      const i_max = boxesCopy[i].position.x + boxesCopy[i].boundingBox.x / 2;\n      const j_min = boxesCopy[j].position.x - boxesCopy[j].boundingBox.x / 2;\n\n      if (j_min > i_max) {\n        break;\n      }\n\n      if (checkBoundingBoxIntersection) {\n        intersections.push({\n          a: boxesCopy[i],\n          b: boxesCopy[j]\n        });\n      }\n    }\n  }\n\n  return intersections;\n}\n/*\nexport function getAllBoundingBoxIntersections(boxes: Box[]) {\n    // create and sort intervals along x, y, and z\n    const x_intervals = [];\n    const y_intervals = [];\n    const z_intervals = [];\n    for(let box of boxes) {\n        const x_min = box.position.x - box.boundingBox.x/2;\n        const x_max = box.position.x + box.boundingBox.x/2;\n        x_intervals.push({ type: \"min\", value: x_min, object: box});\n        x_intervals.push({ type: \"max\", value: x_max, object: box});\n\n        \n        const y_min = box.position.y - box.boundingBox.y/2;\n        const y_max = box.position.y + box.boundingBox.y/2;\n        y_intervals.push({ type: \"min\", value: y_min, object: box});\n        y_intervals.push({ type: \"max\", value: y_max, object: box});\n\n        const z_min = box.position.z - box.boundingBox.z/2;\n        const z_max = box.position.z + box.boundingBox.z/2;\n        z_intervals.push({ type: \"min\", value: z_min, object: box});\n        z_intervals.push({ type: \"max\", value: z_max, object: box});\n    }\n    // note to self: switch to insertion sort and use normal merge sort only during the initialization frame\n    x_intervals.sort((a, b) => a.value - b.value);\n    //y_intervals.sort((a, b) => a.value - b.value);\n    //z_intervals.sort((a, b) => a.value - b.value);\n\n    // create a list of active intervals\n    const activeIntervals = [];\n}*/","map":{"version":3,"names":["Vector3","dt","World","constructor","objects","currentLoopInterval","characterForce","startLoop","currentInstance","stopCurrentLoop","lastTimeCalled","performance","now","fps","times","step","length","shift","push","i","integrate","setInterval","clearInterval","addObject","obj","getObjects","updateCharacterForce","f","detectCollisions","checkCollisionSpheres","s1","s2","d","position","clone","sub","radius","resolveCollisionSpheres","u12","normalize","u21","multiplyScalar","v1_along_u12","dot","velocity","v2_along_u21","v1_perp_u12","v2_perp_u21","m1","inverseMass","m2","v1_along_u_new","addScaledVector","v2_along_u_new","v1_new","add","v2_new","console","log","clearCurrentLoop","checkBoundingBoxIntersection","a","b","a_x_min","x","boundingBox","a_x_max","a_y_min","y","a_y_max","a_z_min","z","a_z_max","b_x_min","b_x_max","b_y_min","b_y_max","b_z_min","b_z_max","getAllBoundingBoxIntersections","boxes","compareBoundingBoxes","a_min","b_min","boxesCopy","sort","intersections","j","i_max","j_min"],"sources":["/Users/danny/Github/physics_engine_for_the_web/frontend/src/physics_engine/physics_engine.ts"],"sourcesContent":["import { Vector3 } from \"three\";\nimport * as THREE from \"three\";\nimport { Sphere } from \"./Sphere\";\nimport { Box } from \"./Box\";\n// import { Sphere } from \"three\";\n\nconst dt = 1/60; // time step in seconds\n\nexport class World {\n    private objects: any[] = [];\n    private currentLoopInterval: any = null;\n\n    private characterForce: Vector3;\n\n    constructor() {\n        this.objects = [];\n\n        this.characterForce = new Vector3(0, 0, 0);\n    }\n\n    startLoop(): void {\n        const currentInstance = this;\n\n        // stop current loop if it exits\n        this.stopCurrentLoop();\n\n        let lastTimeCalled = performance.now();\n        let fps = 0;\n        let times: any[] = [];\n\n        function step() {\n            // calculate fps\n            const now = performance.now();\n            while (times.length > 0 && times[0] <= now - 1000) {\n                times.shift();\n            }\n            times.push(now);\n            fps = times.length;\n            // console.log(\"fps: \", fps);\n\n            for (let i = 0; i < currentInstance.objects.length; i++) {\n                currentInstance.objects[i].integrate(dt);\n            }\n        }\n\n        this.currentLoopInterval = setInterval(step, dt * 1000);\n    }\n\n    /** Stops current loop if it exists. */\n    stopCurrentLoop(): void {\n        if (this.currentLoopInterval) {\n            clearInterval(this.currentLoopInterval);\n        }\n    }\n\n    addObject(obj: any): void {\n        this.objects.push(obj);\n    }\n\n    getObjects(): any[] {\n        return this.objects;\n    }\n\n    updateCharacterForce(f: Vector3) {\n        this.characterForce = f;\n    }\n\n    detectCollisions(): void {\n\n    }\n\n    checkCollisionSpheres(s1: Sphere, s2: Sphere) {\n        const d = (s1.position.clone().sub(s2.position)).length(); // distance between centers\n\n        // collision if distance between spheres is smaller than sub of radiuses\n        if (d < (s1.radius + s2.radius)) {\n            return true;\n        }\n        return false;\n    }\n\n    resolveCollisionSpheres(s1: Sphere, s2: Sphere) {\n        // find unit vectors from s1 to s2 and s2 to s1\n        const u12 = (s2.position.clone().sub(s1.position)).normalize();\n        const u21 = u12.clone().multiplyScalar(-1);\n\n        // find components of v1 and v2 along and perpendicular to u\n        const v1_along_u12 = u12.clone().multiplyScalar(u12.dot(s1.velocity));\n        const v2_along_u21 = u21.clone().multiplyScalar(u21.dot(s2.velocity));\n\n        const v1_perp_u12 = s1.velocity.clone().sub(v1_along_u12);\n        const v2_perp_u21 = s2.velocity.clone().sub(v2_along_u21);\n\n        // calculate new velocities along u, assuming elastic collision\n        const m1 = 1/s1.inverseMass;\n        const m2 = 1/s2.inverseMass;\n        const v1_along_u_new = (v1_along_u12.clone().multiplyScalar((m1-m2)/(m1+m2))).addScaledVector(v2_along_u21, (2*m2)/(m1+m2));\n        const v2_along_u_new = (v1_along_u12.clone().multiplyScalar((2*m1)/(m1+m2))).addScaledVector(v2_along_u21, -(m1-m2)/(m1+m2));\n\n        // calculate and set new velocities\n        const v1_new = v1_along_u_new.clone().add(v1_perp_u12);\n        const v2_new = v2_along_u_new.clone().add(v2_perp_u21);\n\n        console.log(\"u: \", u12);\n        console.log(\"v1_new: \", v1_new);\n        console.log(\"v2_new\", v2_new);\n    }\n\n    clearCurrentLoop(): void {\n        clearInterval(this.currentLoopInterval);\n    }\n}\n\n/**\n * checks if the bounding box of two objects intersect\n * @param a the first object\n * @param b the other object\n */\nexport function checkBoundingBoxIntersection(a: Box, b: Box): boolean {\n    // create intervals\n    const a_x_min = a.position.x - a.boundingBox.x/2;\n    const a_x_max = a.position.x + a.boundingBox.x/2;\n    const a_y_min = a.position.y - a.boundingBox.y/2;\n    const a_y_max = a.position.y + a.boundingBox.y/2;\n    const a_z_min = a.position.z - a.boundingBox.z/2;\n    const a_z_max = a.position.z + a.boundingBox.z/2;\n    const b_x_min = b.position.x - b.boundingBox.x/2;\n    const b_x_max = b.position.x + b.boundingBox.x/2;\n    const b_y_min = b.position.y - b.boundingBox.y/2;\n    const b_y_max = b.position.y + b.boundingBox.y/2;\n    const b_z_min = b.position.z - b.boundingBox.z/2;\n    const b_z_max = b.position.z + b.boundingBox.z/2;\n\n    // intersecting if all intervals are intersecting\n    if ((a_x_min < b_x_max && b_x_min < a_x_max) &&\n        (a_y_min < b_y_max && b_y_min < a_y_max) &&\n        (a_z_min < b_z_max && b_z_min < a_z_max)) {\n        return true\n    }\n    return false;\n}\n\nexport function getAllBoundingBoxIntersections(boxes: Box[]) {\n    // for now just sort against x-axis. Slightly better is to update axis based on one with highest variance\n    // worst case is still O(n^2)\n\n    function compareBoundingBoxes(a: Box, b: Box) {\n        const a_min = a.position.x - a.boundingBox.x/2;\n        const b_min = b.position.x - b.boundingBox.x/2;\n        return a_min - b_min;\n    }\n\n    // sort objects along x-axis\n    const boxesCopy = [...boxes];\n    boxesCopy.sort(compareBoundingBoxes);\n\n    // sweep the array for collisions\n    const intersections = [];\n    for(let i = 0; i < boxesCopy.length - 1; i++) {\n        // test against all possible overlapping boxes following the current one.\n        for(let j = i + 1; j < boxesCopy.length; j++) {\n            // stop testing when AABBs are beyond the current AABB\n            const i_max = boxesCopy[i].position.x + boxesCopy[i].boundingBox.x/2;\n            const j_min = boxesCopy[j].position.x - boxesCopy[j].boundingBox.x/2;\n            if (j_min > i_max) {\n                break;\n            }\n\n            if (checkBoundingBoxIntersection) {\n                intersections.push({\n                    a: boxesCopy[i],\n                    b: boxesCopy[j]\n                });\n            }\n        }\n    }\n    return intersections;\n}\n\n/*\nexport function getAllBoundingBoxIntersections(boxes: Box[]) {\n    // create and sort intervals along x, y, and z\n    const x_intervals = [];\n    const y_intervals = [];\n    const z_intervals = [];\n    for(let box of boxes) {\n        const x_min = box.position.x - box.boundingBox.x/2;\n        const x_max = box.position.x + box.boundingBox.x/2;\n        x_intervals.push({ type: \"min\", value: x_min, object: box});\n        x_intervals.push({ type: \"max\", value: x_max, object: box});\n\n        \n        const y_min = box.position.y - box.boundingBox.y/2;\n        const y_max = box.position.y + box.boundingBox.y/2;\n        y_intervals.push({ type: \"min\", value: y_min, object: box});\n        y_intervals.push({ type: \"max\", value: y_max, object: box});\n\n        const z_min = box.position.z - box.boundingBox.z/2;\n        const z_max = box.position.z + box.boundingBox.z/2;\n        z_intervals.push({ type: \"min\", value: z_min, object: box});\n        z_intervals.push({ type: \"max\", value: z_max, object: box});\n    }\n    // note to self: switch to insertion sort and use normal merge sort only during the initialization frame\n    x_intervals.sort((a, b) => a.value - b.value);\n    //y_intervals.sort((a, b) => a.value - b.value);\n    //z_intervals.sort((a, b) => a.value - b.value);\n\n    // create a list of active intervals\n    const activeIntervals = [];\n}*/"],"mappings":"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"},"metadata":{},"sourceType":"module"}