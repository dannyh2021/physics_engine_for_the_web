{"ast":null,"code":"import * as THREE from \"three\";\nimport { Vector3 } from \"three\";\nconst DAMPING = 0.999; // should add rotation at some point?\n\nexport class Sphere {\n  // holds the accumulated force to be applied to the next simulation iteration only.\n  // width, length, and height of bounding box\n  // for graphics\n  constructor(position, radius) {\n    this.inverseMass = void 0;\n    this.radius = void 0;\n    this.position = void 0;\n    this.velocity = void 0;\n    this.forceAccum = void 0;\n    this.boundingBox = void 0;\n    this.mesh = void 0;\n    this.boundingBoxMesh = void 0;\n    this.inverseMass = 1 / (4 / 3 * Math.PI * Math.pow(radius, 3));\n    this.radius = radius;\n    this.position = position;\n    this.velocity = new Vector3(0, 0, 0);\n    this.forceAccum = new Vector3(0, 0, 0);\n    this.boundingBox = new Vector3(2 * radius, 2 * radius, 2 * radius); // for graphics\n\n    this.createMesh();\n    this.updateMesh();\n    this.createBoundingBoxMesh();\n    this.updateBoundingBoxMesh();\n  }\n\n  integrate(duration) {\n    // Don't integrate if mass is infinite or duration <= 0.\n    if (this.inverseMass <= 0 || duration <= 0) return; // update velocity based on force and then clear forces\n\n    this.velocity.addScaledVector(this.forceAccum, duration * this.inverseMass);\n    this.clearAccumulator(); // update the linear position.\n\n    this.position.addScaledVector(this.velocity, duration); // impose drag.\n    // this.velocity.multiplyScalar(Math.pow(DAMPING, duration));\n    // update the velocity from the acceleration.\n    // this.velocity.addScaledVector(this.acceleration, duration);\n  }\n\n  applyImpulse(point, impulse) {\n    this.velocity.add(impulse.clone().multiplyScalar(this.inverseMass));\n  } // Clears the forces applied to the particle.\n\n\n  clearAccumulator() {\n    this.forceAccum = new Vector3(0, 0, 0);\n  }\n\n  createMesh() {\n    const sphereGeometry = new THREE.SphereGeometry(this.radius);\n    const material = new THREE.MeshPhongMaterial({\n      color: 0x00bcd6\n    });\n    this.mesh = new THREE.Mesh(sphereGeometry, material);\n  } // updates mesh to current position and orientation\n\n\n  updateMesh() {\n    this.mesh.position.set(this.position.x, this.position.y, this.position.z);\n  }\n\n  createBoundingBoxMesh() {\n    const boxGeometry = new THREE.BoxGeometry(this.boundingBox.x, this.boundingBox.y, this.boundingBox.z);\n    const wireframe = new THREE.WireframeGeometry(boxGeometry);\n    this.boundingBoxMesh = new THREE.LineSegments(wireframe);\n    this.boundingBoxMesh.material = new THREE.LineBasicMaterial({\n      color: 0xffffff\n    });\n  }\n\n  updateBoundingBoxMesh() {\n    this.boundingBoxMesh.position.set(this.position.x, this.position.y, this.position.z);\n  }\n\n}","map":{"version":3,"names":["THREE","Vector3","DAMPING","Sphere","constructor","position","radius","inverseMass","velocity","forceAccum","boundingBox","mesh","boundingBoxMesh","Math","PI","pow","createMesh","updateMesh","createBoundingBoxMesh","updateBoundingBoxMesh","integrate","duration","addScaledVector","clearAccumulator","applyImpulse","point","impulse","add","clone","multiplyScalar","sphereGeometry","SphereGeometry","material","MeshPhongMaterial","color","Mesh","set","x","y","z","boxGeometry","BoxGeometry","wireframe","WireframeGeometry","LineSegments","LineBasicMaterial"],"sources":["/Users/danny/Github/physics_engine_for_the_web/frontend/src/physics_engine/Sphere.ts"],"sourcesContent":["import * as THREE from \"three\";\nimport { LineSegments, Mesh, Vector3 } from \"three\";\n\nconst DAMPING = 0.999;\n\n// should add rotation at some point?\nexport class Sphere {\n    public inverseMass: number;\n\n    public radius: number;\n    \n    public position: Vector3;\n    public velocity: Vector3;\n\n    // holds the accumulated force to be applied to the next simulation iteration only.\n    public forceAccum: Vector3;\n\n    public boundingBox: Vector3; // width, length, and height of bounding box\n\n    // for graphics\n    public mesh: Mesh;\n    public boundingBoxMesh: LineSegments;\n\n    constructor(position: Vector3, radius: number) {\n        this.inverseMass = 1 / (4/3*Math.PI*Math.pow(radius, 3));\n        this.radius = radius;\n\n        this.position = position;\n        this.velocity = new Vector3(0, 0, 0);\n\n        this.forceAccum = new Vector3(0, 0, 0);\n\n        this.boundingBox = new Vector3(2*radius, 2*radius, 2*radius);\n\n        // for graphics\n        this.createMesh();\n        this.updateMesh();\n        this.createBoundingBoxMesh();\n        this.updateBoundingBoxMesh();\n    }\n\n    integrate(duration: number): void {\n        // Don't integrate if mass is infinite or duration <= 0.\n        if (this.inverseMass <= 0 || duration <= 0)\n            return;\n\n        // update velocity based on force and then clear forces\n        this.velocity.addScaledVector(this.forceAccum, duration*this.inverseMass);\n        this.clearAccumulator();\n\n        // update the linear position.\n        this.position.addScaledVector(this.velocity, duration);\n\n        // impose drag.\n        // this.velocity.multiplyScalar(Math.pow(DAMPING, duration));\n\n        // update the velocity from the acceleration.\n        // this.velocity.addScaledVector(this.acceleration, duration);\n    }\n\n    applyImpulse(point: Vector3, impulse: Vector3) {\n        this.velocity.add(impulse.clone().multiplyScalar(this.inverseMass));\n    }\n\n    // Clears the forces applied to the particle.\n    clearAccumulator(): void {\n        this.forceAccum = new Vector3(0, 0, 0);\n    }\n\n    private createMesh(): void {\n        const sphereGeometry = new THREE.SphereGeometry(this.radius);\n        const material = new THREE.MeshPhongMaterial({ color: 0x00bcd6 });\n        this.mesh = new THREE.Mesh(sphereGeometry, material);\n    }\n\n    // updates mesh to current position and orientation\n    updateMesh(): void {\n        this.mesh.position.set(this.position.x, this.position.y, this.position.z);\n    }\n\n    private createBoundingBoxMesh(): void {\n        const boxGeometry = new THREE.BoxGeometry(this.boundingBox.x, this.boundingBox.y, this.boundingBox.z);\n        const wireframe = new THREE.WireframeGeometry(boxGeometry);\n        this.boundingBoxMesh = new THREE.LineSegments( wireframe );\n        this.boundingBoxMesh.material = new THREE.LineBasicMaterial({ color: 0xffffff });\n    }\n\n    updateBoundingBoxMesh(): void {\n        this.boundingBoxMesh.position.set(this.position.x, this.position.y, this.position.z);\n    }\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}