{"ast":null,"code":"/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nlet firstInputEvent;\nlet firstInputDelay;\nlet firstInputTimeStamp;\nlet callbacks;\nconst listenerOpts = {\n  passive: true,\n  capture: true\n};\nconst startTimeStamp = new Date();\n/**\n * Accepts a callback to be invoked once the first input delay and event\n * are known.\n */\n\nexport const firstInputPolyfill = onFirstInput => {\n  callbacks.push(onFirstInput);\n  reportFirstInputDelayIfRecordedAndValid();\n};\nexport const resetFirstInputPolyfill = () => {\n  callbacks = [];\n  firstInputDelay = -1;\n  firstInputEvent = null;\n  eachEventType(addEventListener);\n};\n/**\n * Records the first input delay and event, so subsequent events can be\n * ignored. All added event listeners are then removed.\n */\n\nconst recordFirstInputDelay = (delay, event) => {\n  if (!firstInputEvent) {\n    firstInputEvent = event;\n    firstInputDelay = delay;\n    firstInputTimeStamp = new Date();\n    eachEventType(removeEventListener);\n    reportFirstInputDelayIfRecordedAndValid();\n  }\n};\n/**\n * Reports the first input delay and event (if they're recorded and valid)\n * by running the array of callback functions.\n */\n\n\nconst reportFirstInputDelayIfRecordedAndValid = () => {\n  // In some cases the recorded delay is clearly wrong, e.g. it's negative\n  // or it's larger than the delta between now and initialization.\n  // - https://github.com/GoogleChromeLabs/first-input-delay/issues/4\n  // - https://github.com/GoogleChromeLabs/first-input-delay/issues/6\n  // - https://github.com/GoogleChromeLabs/first-input-delay/issues/7\n  if (firstInputDelay >= 0 && // @ts-ignore (subtracting two dates always returns a number)\n  firstInputDelay < firstInputTimeStamp - startTimeStamp) {\n    const entry = {\n      entryType: 'first-input',\n      name: firstInputEvent.type,\n      target: firstInputEvent.target,\n      cancelable: firstInputEvent.cancelable,\n      startTime: firstInputEvent.timeStamp,\n      processingStart: firstInputEvent.timeStamp + firstInputDelay\n    };\n    callbacks.forEach(function (callback) {\n      callback(entry);\n    });\n    callbacks = [];\n  }\n};\n/**\n * Handles pointer down events, which are a special case.\n * Pointer events can trigger main or compositor thread behavior.\n * We differentiate these cases based on whether or not we see a\n * 'pointercancel' event, which are fired when we scroll. If we're scrolling\n * we don't need to report input delay since FID excludes scrolling and\n * pinch/zooming.\n */\n\n\nconst onPointerDown = (delay, event) => {\n  /**\n   * Responds to 'pointerup' events and records a delay. If a pointer up event\n   * is the next event after a pointerdown event, then it's not a scroll or\n   * a pinch/zoom.\n   */\n  const onPointerUp = () => {\n    recordFirstInputDelay(delay, event);\n    removePointerEventListeners();\n  };\n  /**\n   * Responds to 'pointercancel' events and removes pointer listeners.\n   * If a 'pointercancel' is the next event to fire after a pointerdown event,\n   * it means this is a scroll or pinch/zoom interaction.\n   */\n\n\n  const onPointerCancel = () => {\n    removePointerEventListeners();\n  };\n  /**\n   * Removes added pointer event listeners.\n   */\n\n\n  const removePointerEventListeners = () => {\n    removeEventListener('pointerup', onPointerUp, listenerOpts);\n    removeEventListener('pointercancel', onPointerCancel, listenerOpts);\n  };\n\n  addEventListener('pointerup', onPointerUp, listenerOpts);\n  addEventListener('pointercancel', onPointerCancel, listenerOpts);\n};\n/**\n * Handles all input events and records the time between when the event\n * was received by the operating system and when it's JavaScript listeners\n * were able to run.\n */\n\n\nconst onInput = event => {\n  // Only count cancelable events, which should trigger behavior\n  // important to the user.\n  if (event.cancelable) {\n    // In some browsers `event.timeStamp` returns a `DOMTimeStamp` value\n    // (epoch time) instead of the newer `DOMHighResTimeStamp`\n    // (document-origin time). To check for that we assume any timestamp\n    // greater than 1 trillion is a `DOMTimeStamp`, and compare it using\n    // the `Date` object rather than `performance.now()`.\n    // - https://github.com/GoogleChromeLabs/first-input-delay/issues/4\n    const isEpochTime = event.timeStamp > 1e12;\n    const now = isEpochTime ? new Date() : performance.now(); // Input delay is the delta between when the system received the event\n    // (e.g. event.timeStamp) and when it could run the callback (e.g. `now`).\n\n    const delay = now - event.timeStamp;\n\n    if (event.type == 'pointerdown') {\n      onPointerDown(delay, event);\n    } else {\n      recordFirstInputDelay(delay, event);\n    }\n  }\n};\n/**\n * Invokes the passed callback const for =  each event type with t =>he\n * `onInput` const and =  `listenerOpts =>`.\n */\n\n\nconst eachEventType = callback => {\n  const eventTypes = ['mousedown', 'keydown', 'touchstart', 'pointerdown'];\n  eventTypes.forEach(type => callback(type, onInput, listenerOpts));\n};","map":{"version":3,"names":["firstInputEvent","firstInputDelay","firstInputTimeStamp","callbacks","listenerOpts","passive","capture","startTimeStamp","Date","firstInputPolyfill","onFirstInput","push","reportFirstInputDelayIfRecordedAndValid","resetFirstInputPolyfill","eachEventType","addEventListener","recordFirstInputDelay","delay","event","removeEventListener","entry","entryType","name","type","target","cancelable","startTime","timeStamp","processingStart","forEach","callback","onPointerDown","onPointerUp","removePointerEventListeners","onPointerCancel","onInput","isEpochTime","now","performance","eventTypes"],"sources":["/Users/danny/Github/physics_engine_for_the_web/frontend/node_modules/web-vitals/dist/modules/lib/polyfills/firstInputPolyfill.js"],"sourcesContent":["/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nlet firstInputEvent;\nlet firstInputDelay;\nlet firstInputTimeStamp;\nlet callbacks;\nconst listenerOpts = { passive: true, capture: true };\nconst startTimeStamp = new Date();\n/**\n * Accepts a callback to be invoked once the first input delay and event\n * are known.\n */\nexport const firstInputPolyfill = (onFirstInput) => {\n    callbacks.push(onFirstInput);\n    reportFirstInputDelayIfRecordedAndValid();\n};\nexport const resetFirstInputPolyfill = () => {\n    callbacks = [];\n    firstInputDelay = -1;\n    firstInputEvent = null;\n    eachEventType(addEventListener);\n};\n/**\n * Records the first input delay and event, so subsequent events can be\n * ignored. All added event listeners are then removed.\n */\nconst recordFirstInputDelay = (delay, event) => {\n    if (!firstInputEvent) {\n        firstInputEvent = event;\n        firstInputDelay = delay;\n        firstInputTimeStamp = new Date;\n        eachEventType(removeEventListener);\n        reportFirstInputDelayIfRecordedAndValid();\n    }\n};\n/**\n * Reports the first input delay and event (if they're recorded and valid)\n * by running the array of callback functions.\n */\nconst reportFirstInputDelayIfRecordedAndValid = () => {\n    // In some cases the recorded delay is clearly wrong, e.g. it's negative\n    // or it's larger than the delta between now and initialization.\n    // - https://github.com/GoogleChromeLabs/first-input-delay/issues/4\n    // - https://github.com/GoogleChromeLabs/first-input-delay/issues/6\n    // - https://github.com/GoogleChromeLabs/first-input-delay/issues/7\n    if (firstInputDelay >= 0 &&\n        // @ts-ignore (subtracting two dates always returns a number)\n        firstInputDelay < firstInputTimeStamp - startTimeStamp) {\n        const entry = {\n            entryType: 'first-input',\n            name: firstInputEvent.type,\n            target: firstInputEvent.target,\n            cancelable: firstInputEvent.cancelable,\n            startTime: firstInputEvent.timeStamp,\n            processingStart: firstInputEvent.timeStamp + firstInputDelay,\n        };\n        callbacks.forEach(function (callback) {\n            callback(entry);\n        });\n        callbacks = [];\n    }\n};\n/**\n * Handles pointer down events, which are a special case.\n * Pointer events can trigger main or compositor thread behavior.\n * We differentiate these cases based on whether or not we see a\n * 'pointercancel' event, which are fired when we scroll. If we're scrolling\n * we don't need to report input delay since FID excludes scrolling and\n * pinch/zooming.\n */\nconst onPointerDown = (delay, event) => {\n    /**\n     * Responds to 'pointerup' events and records a delay. If a pointer up event\n     * is the next event after a pointerdown event, then it's not a scroll or\n     * a pinch/zoom.\n     */\n    const onPointerUp = () => {\n        recordFirstInputDelay(delay, event);\n        removePointerEventListeners();\n    };\n    /**\n     * Responds to 'pointercancel' events and removes pointer listeners.\n     * If a 'pointercancel' is the next event to fire after a pointerdown event,\n     * it means this is a scroll or pinch/zoom interaction.\n     */\n    const onPointerCancel = () => {\n        removePointerEventListeners();\n    };\n    /**\n     * Removes added pointer event listeners.\n     */\n    const removePointerEventListeners = () => {\n        removeEventListener('pointerup', onPointerUp, listenerOpts);\n        removeEventListener('pointercancel', onPointerCancel, listenerOpts);\n    };\n    addEventListener('pointerup', onPointerUp, listenerOpts);\n    addEventListener('pointercancel', onPointerCancel, listenerOpts);\n};\n/**\n * Handles all input events and records the time between when the event\n * was received by the operating system and when it's JavaScript listeners\n * were able to run.\n */\nconst onInput = (event) => {\n    // Only count cancelable events, which should trigger behavior\n    // important to the user.\n    if (event.cancelable) {\n        // In some browsers `event.timeStamp` returns a `DOMTimeStamp` value\n        // (epoch time) instead of the newer `DOMHighResTimeStamp`\n        // (document-origin time). To check for that we assume any timestamp\n        // greater than 1 trillion is a `DOMTimeStamp`, and compare it using\n        // the `Date` object rather than `performance.now()`.\n        // - https://github.com/GoogleChromeLabs/first-input-delay/issues/4\n        const isEpochTime = event.timeStamp > 1e12;\n        const now = isEpochTime ? new Date : performance.now();\n        // Input delay is the delta between when the system received the event\n        // (e.g. event.timeStamp) and when it could run the callback (e.g. `now`).\n        const delay = now - event.timeStamp;\n        if (event.type == 'pointerdown') {\n            onPointerDown(delay, event);\n        }\n        else {\n            recordFirstInputDelay(delay, event);\n        }\n    }\n};\n/**\n * Invokes the passed callback const for =  each event type with t =>he\n * `onInput` const and =  `listenerOpts =>`.\n */\nconst eachEventType = (callback) => {\n    const eventTypes = [\n        'mousedown',\n        'keydown',\n        'touchstart',\n        'pointerdown',\n    ];\n    eventTypes.forEach((type) => callback(type, onInput, listenerOpts));\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}