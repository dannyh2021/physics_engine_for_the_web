{"ast":null,"code":"import _classCallCheck from\"/Users/danny/Github/physics_engine_for_the_web/frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";import _createClass from\"/Users/danny/Github/physics_engine_for_the_web/frontend/node_modules/@babel/runtime/helpers/esm/createClass.js\";import*as THREE from\"three\";import{Matrix3,Vector3}from\"three\";var DAMPING=0.999;// should add rotation at some point?\nexport var Sphere=/*#__PURE__*/function(){// holds the accumulated force to be applied to the next simulation iteration only.\n// width, length, and height of bounding box\n// for graphics\nfunction Sphere(position,radius){_classCallCheck(this,Sphere);this.inverseMass=void 0;this.radius=void 0;this.position=void 0;this.velocity=void 0;this.forceAccum=void 0;this.boundingBox=void 0;this.mesh=void 0;this.boundingBoxMesh=void 0;this.inverseMass=1/(4/3*Math.PI*Math.pow(radius,3));this.radius=radius;this.position=position;this.velocity=new Vector3(0,0,0);this.forceAccum=new Vector3(0,0,0);this.boundingBox=new Vector3(2*radius,2*radius,2*radius);// for graphics\nthis.createMesh();this.updateMesh();this.createBoundingBoxMesh();this.updateBoundingBoxMesh();}_createClass(Sphere,[{key:\"getInertia\",value:function getInertia(){var term=2/5*(1/this.inverseMass)*this.radius*this.radius;var inertia=new Matrix3();inertia.set(term,0,0,0,term,0,0,0,term);return inertia;}},{key:\"getAngularVelocity\",value:function getAngularVelocity(){var angularVelocity=new Vector3(0,0,0);return angularVelocity;}// update velocity based on forceAccum and clear forceAccum\n},{key:\"integrateForceAccum\",value:function integrateForceAccum(duration){// Don't integrate if mass is infinite or duration <= 0.\nif(this.inverseMass<=0||duration<=0){return;}this.velocity.addScaledVector(this.forceAccum,duration*this.inverseMass);this.clearAccumulator();}},{key:\"integrate\",value:function integrate(duration){// Don't integrate if mass is infinite or duration <= 0.\nif(this.inverseMass<=0||duration<=0)return;// update velocity based on force and then clear forces\n// this.velocity.addScaledVector(this.forceAccum, duration*this.inverseMass);\n// this.clearAccumulator();\n// update the linear position.\nthis.position.addScaledVector(this.velocity,duration);// impose drag.\n// this.velocity.multiplyScalar(Math.pow(DAMPING, duration));\n// update the velocity from the acceleration.\n// this.velocity.addScaledVector(this.acceleration, duration);\n}},{key:\"applyImpulse\",value:function applyImpulse(point,impulse){this.velocity.add(impulse.clone().multiplyScalar(this.inverseMass));}// Clears the forces applied to the particle.\n},{key:\"clearAccumulator\",value:function clearAccumulator(){this.forceAccum=new Vector3(0,0,0);}},{key:\"createMesh\",value:function createMesh(){var sphereGeometry=new THREE.SphereGeometry(this.radius);var material=new THREE.MeshPhongMaterial({color:0x00bcd6});this.mesh=new THREE.Mesh(sphereGeometry,material);}// updates mesh to current position and orientation\n},{key:\"updateMesh\",value:function updateMesh(){this.mesh.position.set(this.position.x,this.position.y,this.position.z);}},{key:\"createBoundingBoxMesh\",value:function createBoundingBoxMesh(){var boxGeometry=new THREE.BoxGeometry(this.boundingBox.x,this.boundingBox.y,this.boundingBox.z);var wireframe=new THREE.WireframeGeometry(boxGeometry);this.boundingBoxMesh=new THREE.LineSegments(wireframe);this.boundingBoxMesh.material=new THREE.LineBasicMaterial({color:0xffffff});}},{key:\"updateBoundingBoxMesh\",value:function updateBoundingBoxMesh(){this.boundingBoxMesh.position.set(this.position.x,this.position.y,this.position.z);}}]);return Sphere;}();","map":{"version":3,"names":["THREE","Matrix3","Vector3","DAMPING","Sphere","position","radius","inverseMass","velocity","forceAccum","boundingBox","mesh","boundingBoxMesh","Math","PI","pow","createMesh","updateMesh","createBoundingBoxMesh","updateBoundingBoxMesh","term","inertia","set","angularVelocity","duration","addScaledVector","clearAccumulator","point","impulse","add","clone","multiplyScalar","sphereGeometry","SphereGeometry","material","MeshPhongMaterial","color","Mesh","x","y","z","boxGeometry","BoxGeometry","wireframe","WireframeGeometry","LineSegments","LineBasicMaterial"],"sources":["/Users/danny/Github/physics_engine_for_the_web/frontend/src/physics_engine/Sphere.ts"],"sourcesContent":["import * as THREE from \"three\";\nimport { LineSegments, Matrix3, Mesh, Vector3 } from \"three\";\n\nconst DAMPING = 0.999;\n\n// should add rotation at some point?\nexport class Sphere {\n    public inverseMass: number;\n\n    public radius: number;\n    \n    public position: Vector3;\n    public velocity: Vector3;\n\n    // holds the accumulated force to be applied to the next simulation iteration only.\n    public forceAccum: Vector3;\n\n    public boundingBox: Vector3; // width, length, and height of bounding box\n\n    // for graphics\n    public mesh: Mesh;\n    public boundingBoxMesh: LineSegments;\n\n    constructor(position: Vector3, radius: number) {\n        this.inverseMass = 1 / (4/3*Math.PI*Math.pow(radius, 3));\n        this.radius = radius;\n\n        this.position = position;\n        this.velocity = new Vector3(0, 0, 0);\n\n        this.forceAccum = new Vector3(0, 0, 0);\n\n        this.boundingBox = new Vector3(2*radius, 2*radius, 2*radius);\n\n        // for graphics\n        this.createMesh();\n        this.updateMesh();\n        this.createBoundingBoxMesh();\n        this.updateBoundingBoxMesh();\n    }\n\n    getInertia(): Matrix3 {\n        const term = 2/5 * (1/this.inverseMass) * this.radius * this.radius;\n        const inertia = new Matrix3;\n        inertia.set(\n            term, 0, 0,\n            0, term, 0,\n            0, 0, term\n        );\n        return inertia;\n    }\n\n    getAngularVelocity(): Vector3 {\n        const angularVelocity = new Vector3(0, 0, 0);\n        return angularVelocity;\n    }\n\n    // update velocity based on forceAccum and clear forceAccum\n    integrateForceAccum(duration: number): void {\n        // Don't integrate if mass is infinite or duration <= 0.\n        if (this.inverseMass <= 0 || duration <= 0) {\n            return;\n        }\n\n        this.velocity.addScaledVector(this.forceAccum, duration*this.inverseMass);\n        this.clearAccumulator();\n    }\n\n    integrate(duration: number): void {\n        // Don't integrate if mass is infinite or duration <= 0.\n        if (this.inverseMass <= 0 || duration <= 0)\n            return;\n\n        // update velocity based on force and then clear forces\n        // this.velocity.addScaledVector(this.forceAccum, duration*this.inverseMass);\n        // this.clearAccumulator();\n\n        // update the linear position.\n        this.position.addScaledVector(this.velocity, duration);\n\n        // impose drag.\n        // this.velocity.multiplyScalar(Math.pow(DAMPING, duration));\n\n        // update the velocity from the acceleration.\n        // this.velocity.addScaledVector(this.acceleration, duration);\n    }\n\n    applyImpulse(point: Vector3, impulse: Vector3) {\n        this.velocity.add(impulse.clone().multiplyScalar(this.inverseMass));\n    }\n\n    // Clears the forces applied to the particle.\n    clearAccumulator(): void {\n        this.forceAccum = new Vector3(0, 0, 0);\n    }\n\n    private createMesh(): void {\n        const sphereGeometry = new THREE.SphereGeometry(this.radius);\n        const material = new THREE.MeshPhongMaterial({ color: 0x00bcd6 });\n        this.mesh = new THREE.Mesh(sphereGeometry, material);\n    }\n\n    // updates mesh to current position and orientation\n    updateMesh(): void {\n        this.mesh.position.set(this.position.x, this.position.y, this.position.z);\n    }\n\n    private createBoundingBoxMesh(): void {\n        const boxGeometry = new THREE.BoxGeometry(this.boundingBox.x, this.boundingBox.y, this.boundingBox.z);\n        const wireframe = new THREE.WireframeGeometry(boxGeometry);\n        this.boundingBoxMesh = new THREE.LineSegments( wireframe );\n        this.boundingBoxMesh.material = new THREE.LineBasicMaterial({ color: 0xffffff });\n    }\n\n    updateBoundingBoxMesh(): void {\n        this.boundingBoxMesh.position.set(this.position.x, this.position.y, this.position.z);\n    }\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}