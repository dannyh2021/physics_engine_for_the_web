{"ast":null,"code":"import { Matrix3, Matrix4 } from \"three\";\n/**\n* R = R_z(phi) R_y(theta) R_x(psi)\n* @param rotationMatrix assumes valid rotation matrix\n* @return JSON of euler angles psi, theta, and phi {psi: number, theta: number, phi: number}\n*/\n\nexport function getEulerAngles(rotationMatrix) {\n  const elements = rotationMatrix.elements;\n  const r_11 = elements[0];\n  const r_12 = elements[3];\n  const r_13 = elements[6];\n  const r_21 = elements[1];\n  const r_31 = elements[2];\n  const r_32 = elements[5];\n  const r_33 = elements[8];\n  let psi;\n  let theta;\n  let phi;\n\n  if (!(r_31 === 1 || r_31 === -1)) {\n    theta = -Math.asin(r_31);\n    psi = Math.atan2(r_32 / Math.cos(theta), r_33 / Math.cos(theta));\n    phi = Math.atan2(r_21 / Math.cos(theta), r_11 / Math.cos(theta));\n  } else {\n    phi = 0;\n\n    if (r_31 === -1) {\n      theta = Math.PI / 2;\n      psi = phi + Math.atan2(r_12, r_13);\n    } else {\n      theta = -Math.PI / 2;\n      psi = -phi + Math.atan2(-r_12, -r_13);\n    }\n  }\n\n  const angles = {\n    psi: psi,\n    theta: theta,\n    phi: phi\n  };\n  return angles;\n}\nexport function xRotationMatrix3(angle) {\n  const c = Math.cos(angle);\n  const s = Math.sin(angle);\n  const m = new Matrix3();\n  m.set(1, 0, 0, 0, c, -s, 0, s, c);\n  return m;\n}\nexport function yRotationMatrix3(angle) {\n  const c = Math.cos(angle);\n  const s = Math.sin(angle);\n  const m = new Matrix3();\n  m.set(c, 0, s, 0, 1, 0, -s, 0, c);\n  return m;\n}\nexport function zRotationMatrix3(angle) {\n  const c = Math.cos(angle);\n  const s = Math.sin(angle);\n  const m = new Matrix3();\n  m.set(c, -s, 0, s, c, 0, 0, 0, 1);\n  return m;\n}\nexport function convertMatrix3ToMatrix4(matrix) {\n  const elements = matrix.elements;\n  const m = new Matrix4();\n  m.set(elements[0], elements[3], elements[6], 0, elements[1], elements[4], elements[7], 0, elements[2], elements[5], elements[8], 0, 0, 0, 0, 1);\n  return m;\n}\n/**\n * Not sure what it's called but suppose you have vectors a and b.\n * Then this function will return a matrix a_star, where a_star(b) = a x b\n * In other words, a_star is a linear map that acts returns the cross product of a with its input.\n * Derived in chapter 4.8 of Goldstein's Classical Mechanics book.\n * @param vector the vector\n */\n\nexport function getVectorCrossMatrix(v) {\n  const m = new Matrix3();\n  m.set(0, -v.z, v.y, v.z, 0, -v.x, -v.y, v.x, 0);\n  return m;\n}\nexport function addMatrices(a, b) {\n  const aElements = a.elements;\n  const bElements = b.elements;\n  const m = new Matrix3();\n  const elements = [];\n\n  for (let i = 0; i < 9; i++) {\n    elements.push(aElements[i] + bElements[i]);\n  }\n\n  m.elements = elements;\n  return m;\n}\n;","map":{"version":3,"names":["Matrix3","Matrix4","getEulerAngles","rotationMatrix","elements","r_11","r_12","r_13","r_21","r_31","r_32","r_33","psi","theta","phi","Math","asin","atan2","cos","PI","angles","xRotationMatrix3","angle","c","s","sin","m","set","yRotationMatrix3","zRotationMatrix3","convertMatrix3ToMatrix4","matrix","getVectorCrossMatrix","v","z","y","x","addMatrices","a","b","aElements","bElements","i","push"],"sources":["/Users/danny/Github/physics_engine_for_the_web/frontend/src/physics_engine/math_library.ts"],"sourcesContent":["import { Matrix3, Matrix4, Vector3 } from \"three\";\n\n/**\n* R = R_z(phi) R_y(theta) R_x(psi)\n* @param rotationMatrix assumes valid rotation matrix\n* @return JSON of euler angles psi, theta, and phi {psi: number, theta: number, phi: number}\n*/\nexport function getEulerAngles(rotationMatrix: Matrix3) {\n   const elements = rotationMatrix.elements;\n   const r_11 = elements[0];\n   const r_12 = elements[3];\n   const r_13 = elements[6];\n   const r_21 = elements[1];\n   const r_31 = elements[2];\n   const r_32 = elements[5];\n   const r_33 = elements[8];\n\n   let psi: number;\n   let theta: number;\n   let phi: number;\n\n   if (!(r_31 === 1 || r_31 === -1)) {\n       theta = - Math.asin(r_31);\n\n       psi = Math.atan2(r_32/Math.cos(theta), r_33/Math.cos(theta));\n\n       phi = Math.atan2(r_21/Math.cos(theta), r_11/Math.cos(theta));\n   } else {\n       phi = 0;\n\n       if (r_31 === -1) {\n           theta = Math.PI/2;\n           psi = phi + Math.atan2(r_12, r_13);\n       } else {\n           theta = -Math.PI/2;\n           psi = -phi + Math.atan2(-r_12, -r_13);\n       }\n   }\n\n   const angles = {psi: psi, theta: theta, phi: phi};\n   return angles;\n}\n\nexport function xRotationMatrix3(angle: number) {\n    const c = Math.cos(angle);\n    const s = Math.sin(angle);\n\n    const m = new Matrix3()\n    m.set(\n        1, 0, 0,\n        0, c, -s,\n        0, s, c\n    );\n    return m;\n}\n\nexport function yRotationMatrix3(angle: number) {\n    const c = Math.cos(angle);\n    const s = Math.sin(angle);\n\n    const m = new Matrix3();\n    m.set(\n        c, 0, s,\n        0, 1, 0,\n        -s, 0, c,\n    );\n    return m;\n}\n\nexport function zRotationMatrix3(angle: number) {\n    const c = Math.cos(angle);\n    const s = Math.sin(angle);\n\n    const m = new Matrix3();\n    m.set(\n        c, -s, 0,\n        s, c, 0,\n        0, 0, 1,\n    );\n    return m;\n}\n\nexport function convertMatrix3ToMatrix4(matrix: Matrix3) {\n    const elements = matrix.elements;\n    \n    const m = new Matrix4();\n    m.set(\n        elements[0], elements[3], elements[6], 0,\n        elements[1], elements[4], elements[7], 0,\n        elements[2], elements[5], elements[8], 0,\n        0, 0, 0, 1\n    );\n\n    return m;\n}\n\n/**\n * Not sure what it's called but suppose you have vectors a and b.\n * Then this function will return a matrix a_star, where a_star(b) = a x b\n * In other words, a_star is a linear map that acts returns the cross product of a with its input.\n * Derived in chapter 4.8 of Goldstein's Classical Mechanics book.\n * @param vector the vector\n */\nexport function getVectorCrossMatrix(v: Vector3) {\n    const m = new Matrix3();\n    m.set(\n        0, -v.z, v.y,\n        v.z, 0, -v.x,\n        -v.y, v.x, 0\n    );\n    return m;\n}\n\nexport function addMatrices(a: Matrix3, b: Matrix3) {\n    const aElements = a.elements;\n    const bElements = b.elements;\n    const m = new Matrix3();\n    const elements = [];\n    for (let i = 0; i < 9; i++) {\n        elements.push(aElements[i] + bElements[i]);\n    }\n    m.elements = elements;\n    return m;\n};"],"mappings":"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"},"metadata":{},"sourceType":"module"}