{"ast":null,"code":"import _classCallCheck from\"/Users/danny/Github/physics_engine_for_the_web/frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";import _createClass from\"/Users/danny/Github/physics_engine_for_the_web/frontend/node_modules/@babel/runtime/helpers/esm/createClass.js\";import*as THREE from\"three\";import{Vector3,Matrix3,Quaternion}from\"three\";import{convertQuaternionToMatrix,addQuaternions,scaleQuaternion}from\"./math_library\";export var Box=/*#__PURE__*/function(){// inertia tensor in body space\n// public momentum: Vector3;\n// the orientation\n// holds the accumulated force to be applied to the next simulation iteration only.\n// width, length, and height of the bounding box\n// for graphics\nfunction Box(position,width,length,height){_classCallCheck(this,Box);this.inverseMass=void 0;this.width=void 0;this.length=void 0;this.height=void 0;this.inertia_body=void 0;this.position=void 0;this.velocity=void 0;this.rotation=void 0;this.angularMomentum=void 0;this.forceAccum=void 0;this.boundingBox=void 0;this.mesh=void 0;this.boundingBoxMesh=void 0;this.inverseMass=1/(width*length*height);this.width=width;this.length=length;this.height=height;this.inertia_body=new Matrix3();this.setInertia();this.position=position;this.velocity=new Vector3(0,0,0);// this.momentum = (new Vector3(1, 0, 0)).multiplyScalar(1/this.inverseMass);\nthis.rotation=new Quaternion(0,0,0,1);this.angularMomentum=new Vector3(0,0,0).applyMatrix3(this.getInertia());this.forceAccum=new Vector3(0,0,0);this.setBoundingBox();// for graphics\nthis.createMesh();this.updateMesh();this.createBoundingBoxMesh();this.updateBoundingBoxMesh();}_createClass(Box,[{key:\"setInertia\",value:function setInertia(){var mass=1/this.inverseMass;var I_xx=1/12*mass*(this.length*this.length+this.height*this.height);var I_yy=1/12*mass*(this.width*this.width+this.height*this.height);var I_zz=1/12*mass*(this.width*this.width+this.length*this.length);this.inertia_body.set(I_xx,0,0,0,I_yy,0,0,0,I_zz);}},{key:\"getInertia\",value:function getInertia(){var rotationMatrix=convertQuaternionToMatrix(this.rotation);var inertia=rotationMatrix.clone().multiply(this.inertia_body).multiply(rotationMatrix.clone().transpose());return inertia;}},{key:\"getI_inverse\",value:function getI_inverse(){var I_body_inverse=this.inertia_body.clone().invert();var rotationMatrix=convertQuaternionToMatrix(this.rotation);var I_inverse=rotationMatrix.clone().multiply(I_body_inverse).multiply(rotationMatrix.clone().transpose());return I_inverse;}},{key:\"getAngularVelocity\",value:function getAngularVelocity(){var I_inverse=this.getInertia().invert();var angularVelocity=this.angularMomentum.clone().applyMatrix3(I_inverse);return angularVelocity;}// update velocity based on forceAccum and clear forceAccum\n},{key:\"integrateForceAccum\",value:function integrateForceAccum(duration){// Don't integrate if mass is infinite or duration <= 0.\nif(this.inverseMass<=0||duration<=0){return;}this.velocity.addScaledVector(this.forceAccum,duration*this.inverseMass);this.clearAccumulator();}},{key:\"integrate\",value:function integrate(duration){// Don't integrate if mass is infinite or duration <= 0.\nif(this.inverseMass<=0||duration<=0){return;}// update velocity based on force and then clear forces\n// this.velocity.addScaledVector(this.forceAccum, duration*this.inverseMass);\n// this.clearAccumulator();\n// update position\nthis.position.addScaledVector(this.velocity,duration);// this.position.addScaledVector(this.momentum, this.inverseMass * duration);\n// update rotation\nvar angularVelocity=this.getAngularVelocity();// ddt_q = (1/2) * w(t) * q(t)\nvar ddt_Rotation=new Quaternion(angularVelocity.x/2,angularVelocity.y/2,angularVelocity.z/2,0).multiply(this.rotation);this.rotation=addQuaternions(this.rotation,scaleQuaternion(ddt_Rotation,duration));this.rotation.normalize();}// Clears the forces applied to the particle.\n},{key:\"clearAccumulator\",value:function clearAccumulator(){this.forceAccum=new Vector3(0,0,0);}},{key:\"applyImpulse\",value:function applyImpulse(point,impulse){// const linearComponent = this.position.clone().sub(point).normalize().dot(impulse);\n// const linearImpulse = this.position.clone().sub(point).normalize().multiplyScalar(linearComponent);\n// this.velocity.addScaledVector(linearImpulse, this.inverseMass);\nthis.velocity.addScaledVector(impulse,this.inverseMass);var r=point.clone().sub(this.position);/*\n        const angularUnitVector = impulse.clone().cross(this.position.sub(point)).cross(r).normalize();\n        const angularImpulse = angularUnitVector.clone().multiplyScalar(impulse.dot(angularUnitVector));*/ // this.angularMomentum.add(r.clone().cross(angularImpulse));\nthis.angularMomentum.add(r.clone().cross(impulse));}// for now, set to big enough bounding box so that we don't need to update it.\n},{key:\"setBoundingBox\",value:function setBoundingBox(){var radius=Math.sqrt(this.width/2*(this.width/2)+this.length/2*(this.length/2)+this.height/2*(this.height/2));this.boundingBox=new Vector3(radius*2,radius*2,radius*2);}},{key:\"createMesh\",value:function createMesh(){var boxGeometry=new THREE.BoxGeometry(this.width,this.length,this.height);var material=new THREE.MeshPhongMaterial({color:0x00bcd6});this.mesh=new THREE.Mesh(boxGeometry,material);}// updates mesh to current position and orientation\n},{key:\"updateMesh\",value:function updateMesh(){this.mesh.position.set(this.position.x,this.position.y,this.position.z);this.mesh.setRotationFromQuaternion(this.rotation);}},{key:\"createBoundingBoxMesh\",value:function createBoundingBoxMesh(){var boxGeometry=new THREE.BoxGeometry(this.boundingBox.x,this.boundingBox.y,this.boundingBox.z);var wireframe=new THREE.WireframeGeometry(boxGeometry);this.boundingBoxMesh=new THREE.LineSegments(wireframe);this.boundingBoxMesh.material=new THREE.LineBasicMaterial({color:0xffffff});}},{key:\"updateBoundingBoxMesh\",value:function updateBoundingBoxMesh(){this.boundingBoxMesh.position.set(this.position.x,this.position.y,this.position.z);}}]);return Box;}();","map":{"version":3,"names":["THREE","Vector3","Matrix3","Quaternion","convertQuaternionToMatrix","addQuaternions","scaleQuaternion","Box","position","width","length","height","inverseMass","inertia_body","velocity","rotation","angularMomentum","forceAccum","boundingBox","mesh","boundingBoxMesh","setInertia","applyMatrix3","getInertia","setBoundingBox","createMesh","updateMesh","createBoundingBoxMesh","updateBoundingBoxMesh","mass","I_xx","I_yy","I_zz","set","rotationMatrix","inertia","clone","multiply","transpose","I_body_inverse","invert","I_inverse","angularVelocity","duration","addScaledVector","clearAccumulator","getAngularVelocity","ddt_Rotation","x","y","z","normalize","point","impulse","r","sub","add","cross","radius","Math","sqrt","boxGeometry","BoxGeometry","material","MeshPhongMaterial","color","Mesh","setRotationFromQuaternion","wireframe","WireframeGeometry","LineSegments","LineBasicMaterial"],"sources":["/Users/danny/Github/physics_engine_for_the_web/frontend/src/physics_engine/Box.ts"],"sourcesContent":["import * as THREE from \"three\";\nimport { Vector3, Matrix3, Quaternion, Mesh, LineSegments } from \"three\";\nimport { getVectorCrossMatrix, addMatrices, convertQuaternionToMatrix, addQuaternions, scaleQuaternion, getEulerAngles, printEulerAngles } from \"./math_library\";\n\nexport class Box {\n    public inverseMass: number;\n\n    public width: number;\n    public length: number;\n    public height: number;\n\n    public inertia_body: Matrix3; // inertia tensor in body space\n\n    public position: Vector3;\n    public velocity: Vector3;\n    // public momentum: Vector3;\n\n    public rotation: Quaternion // the orientation\n    public angularMomentum: Vector3;\n\n    // holds the accumulated force to be applied to the next simulation iteration only.\n    public forceAccum: Vector3;\n\n    public boundingBox: Vector3 // width, length, and height of the bounding box\n\n    // for graphics\n    public mesh: Mesh;\n    public boundingBoxMesh: LineSegments;\n\n    constructor(position: Vector3, width: number, length: number, height: number) {\n        this.inverseMass = 1 / (width * length * height);\n\n        this.width = width;\n        this.length = length;\n        this.height = height;\n\n        this.inertia_body = new Matrix3();\n        this.setInertia();\n        \n        this.position = position;\n        this.velocity = new Vector3(0, 0, 0);\n        // this.momentum = (new Vector3(1, 0, 0)).multiplyScalar(1/this.inverseMass);\n\n        this.rotation = new Quaternion(0, 0, 0, 1);\n        this.angularMomentum = new Vector3(0, 0, 0).applyMatrix3(this.getInertia());\n\n        this.forceAccum = new Vector3(0, 0, 0);\n\n        this.setBoundingBox();\n\n        // for graphics\n        this.createMesh();\n        this.updateMesh();\n        this.createBoundingBoxMesh();\n        this.updateBoundingBoxMesh();\n    }\n\n    private setInertia(): void {\n        const mass = 1 / this.inverseMass;\n        const I_xx = (1/12) * mass * (this.length*this.length + this.height*this.height);\n        const I_yy = (1/12) * mass * (this.width*this.width + this.height*this.height);\n        const I_zz = (1/12) * mass * (this.width*this.width + this.length*this.length);\n\n        this.inertia_body.set(\n            I_xx, 0, 0,\n            0, I_yy, 0,\n            0, 0, I_zz\n        );\n    }\n\n    getInertia(): Matrix3 {\n        const rotationMatrix = convertQuaternionToMatrix(this.rotation);\n        const inertia = rotationMatrix.clone().multiply(this.inertia_body).multiply(rotationMatrix.clone().transpose());\n        return inertia;\n    }\n\n    getI_inverse(): Matrix3 {\n        const I_body_inverse = this.inertia_body.clone().invert();\n        const rotationMatrix = convertQuaternionToMatrix(this.rotation);\n        const I_inverse = rotationMatrix.clone().multiply(I_body_inverse).multiply(rotationMatrix.clone().transpose());\n        return I_inverse;\n    }\n\n    getAngularVelocity(): Vector3 {\n        const I_inverse = this.getInertia().invert();\n        const angularVelocity = this.angularMomentum.clone().applyMatrix3(I_inverse);\n        return angularVelocity;\n    }\n\n    // update velocity based on forceAccum and clear forceAccum\n    integrateForceAccum(duration: number): void {\n        // Don't integrate if mass is infinite or duration <= 0.\n        if (this.inverseMass <= 0 || duration <= 0) {\n            return;\n        }\n\n        this.velocity.addScaledVector(this.forceAccum, duration*this.inverseMass);\n        this.clearAccumulator();\n    }\n\n    integrate(duration: number): void {\n        // Don't integrate if mass is infinite or duration <= 0.\n        if (this.inverseMass <= 0 || duration <= 0) {\n            return;\n        }\n\n        // update velocity based on force and then clear forces\n        // this.velocity.addScaledVector(this.forceAccum, duration*this.inverseMass);\n        // this.clearAccumulator();\n\n        // update position\n        this.position.addScaledVector(this.velocity, duration);\n\n        // this.position.addScaledVector(this.momentum, this.inverseMass * duration);\n\n        // update rotation\n        const angularVelocity = this.getAngularVelocity();\n\n        // ddt_q = (1/2) * w(t) * q(t)\n        const ddt_Rotation = (new Quaternion(angularVelocity.x/2, angularVelocity.y/2, angularVelocity.z/2, 0)).multiply(this.rotation);\n        this.rotation = addQuaternions(this.rotation, scaleQuaternion(ddt_Rotation, duration));\n        this.rotation.normalize();\n    }\n\n    // Clears the forces applied to the particle.\n    clearAccumulator(): void {\n        this.forceAccum = new Vector3(0, 0, 0);\n    }\n\n    applyImpulse(point: Vector3, impulse: Vector3) {\n        // const linearComponent = this.position.clone().sub(point).normalize().dot(impulse);\n        // const linearImpulse = this.position.clone().sub(point).normalize().multiplyScalar(linearComponent);\n        // this.velocity.addScaledVector(linearImpulse, this.inverseMass);\n        this.velocity.addScaledVector(impulse, this.inverseMass);\n        \n\n\n        const r = point.clone().sub(this.position);\n        /*\n        const angularUnitVector = impulse.clone().cross(this.position.sub(point)).cross(r).normalize();\n        const angularImpulse = angularUnitVector.clone().multiplyScalar(impulse.dot(angularUnitVector));*/\n        // this.angularMomentum.add(r.clone().cross(angularImpulse));\n        this.angularMomentum.add(r.clone().cross(impulse));\n    }\n\n    // for now, set to big enough bounding box so that we don't need to update it.\n    private setBoundingBox(): void {\n        const radius = Math.sqrt((this.width/2)*(this.width/2) + (this.length/2)*(this.length/2) + (this.height/2)*(this.height/2));\n        this.boundingBox = new Vector3(radius * 2, radius * 2, radius * 2);\n    };\n\n    private createMesh(): void {\n        const boxGeometry = new THREE.BoxGeometry(this.width, this.length, this.height);\n        const material = new THREE.MeshPhongMaterial({ color: 0x00bcd6 });\n        this.mesh = new THREE.Mesh(boxGeometry, material);\n    }\n\n    // updates mesh to current position and orientation\n    updateMesh(): void {\n        this.mesh.position.set(this.position.x, this.position.y, this.position.z);\n        this.mesh.setRotationFromQuaternion(this.rotation);\n    }\n\n    private createBoundingBoxMesh(): void {\n        const boxGeometry = new THREE.BoxGeometry(this.boundingBox.x, this.boundingBox.y, this.boundingBox.z);\n        const wireframe = new THREE.WireframeGeometry(boxGeometry);\n        this.boundingBoxMesh = new THREE.LineSegments( wireframe );\n        this.boundingBoxMesh.material = new THREE.LineBasicMaterial({ color: 0xffffff });\n    }\n\n    updateBoundingBoxMesh(): void {\n        this.boundingBoxMesh.position.set(this.position.x, this.position.y, this.position.z);\n    }\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}