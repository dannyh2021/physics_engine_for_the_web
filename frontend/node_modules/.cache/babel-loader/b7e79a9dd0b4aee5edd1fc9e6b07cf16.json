{"ast":null,"code":"import { Vector3, Matrix3, Quaternion } from \"three\";\nimport { convertQuaternionToMatrix, addQuaternions, scaleQuaternion } from \"./math_library\";\nexport class Box {\n  // inertia tensor in body space\n  // the orientation\n  //public rotation: Matrix3; // the orientation\n  constructor(position, width, length, height) {\n    this.inverseMass = void 0;\n    this.width = void 0;\n    this.length = void 0;\n    this.height = void 0;\n    this.inertia = void 0;\n    this.position = void 0;\n    this.momentum = void 0;\n    this.rotation = void 0;\n    this.angularMomentum = void 0;\n    this.inverseMass = 1 / (width * length * height);\n    this.width = width;\n    this.length = length;\n    this.height = height;\n    this.inertia = new Matrix3();\n    this.setInertia();\n    this.position = position;\n    this.momentum = new Vector3(1, 0, 0).multiplyScalar(1 / this.inverseMass);\n    this.rotation = new Quaternion(0, 0, 0, 1); //this.rotation = new Matrix3();\n\n    this.angularMomentum = new Vector3(0, 0, 1).applyMatrix3(this.inertia);\n  }\n\n  setInertia() {\n    const I_xx = 1 / 12 * (this.length * this.length + this.height * this.height);\n    const I_yy = 1 / 12 * (this.width * this.width + this.height * this.height);\n    const I_zz = 1 / 12 * (this.width * this.width + this.length * this.length);\n    const I_xy = -1 / 16 * (this.width * this.length);\n    const I_yx = I_xy;\n    const I_xz = -1 / 16 * (this.width * this.height);\n    const I_zx = I_xz;\n    const I_yz = -1 / 16 * (this.length * this.height);\n    const I_zy = I_yz;\n    this.inertia.set(I_xx, I_xy, I_xz, I_yx, I_yy, I_yz, I_zx, I_zy, I_zz);\n  }\n\n  integrate(duration) {\n    // Don't integrate if mass is infinite or duration <= 0.\n    if (this.inverseMass <= 0 || duration <= 0) {\n      return;\n    }\n\n    this.position.addScaledVector(this.momentum, this.inverseMass * duration); // update rotation matrix\n  }\n\n  testIntegrate(duration) {\n    const I_b_inverse = this.inertia.clone().invert();\n    const rotationMatrix = convertQuaternionToMatrix(this.rotation);\n    const I_inverse = rotationMatrix.clone().multiply(I_b_inverse).multiply(rotationMatrix.clone().transpose());\n    const angularVelocity = this.angularMomentum.clone().applyMatrix3(I_inverse); // ddt_q = (1/2) * w(t) * q(t)\n\n    const ddt_Rotation = new Quaternion(0, angularVelocity.x / 2, angularVelocity.y / 2, angularVelocity.z / 2).multiply(this.rotation);\n    this.rotation = addQuaternions(this.rotation, scaleQuaternion(ddt_Rotation, duration));\n    this.rotation.normalize();\n    console.log(\"angular_velocity: \", angularVelocity);\n    console.log(\"scaled ddt_Rotation: \", scaleQuaternion(ddt_Rotation, duration));\n    console.log(\"rotation: \", this.rotation);\n    console.log(\"test quaternion identity\", new Quaternion().identity);\n  }\n  /*testIntegrate(duration: number): void {\n      // update rotation matrix\n       const I_b_inverse = this.inertia.clone().invert();\n      const I_inverse = this.rotation.clone().multiply(I_b_inverse).multiply(this.rotation.clone().transpose());\n      const angularVelocity = this.angularMomentum.clone().applyMatrix3(I_inverse);\n      const angularVelocity_star = getVectorCrossMatrix(angularVelocity);\n       const ddt_Rotation = angularVelocity_star.clone().multiply(this.rotation);\n      this.rotation = addMatrices(this.rotation, ddt_Rotation.clone().multiplyScalar(duration));\n       console.log(\"angularVelocity: \", angularVelocity);\n      console.log(\"angularVelocity_star\", angularVelocity_star);\n      console.log(\"ddt_Rotation: \", ddt_Rotation);\n      console.log(\"ddt_Rotation * duration: \", ddt_Rotation.multiplyScalar(1/60));\n      console.log(\"this.rotation: \", this.rotation);\n      console.log(\"this.rotation * this.rotation transpose: \", this.rotation.clone().multiply(this.rotation.clone().transpose()));\n  }*/\n\n\n}","map":{"version":3,"names":["Vector3","Matrix3","Quaternion","convertQuaternionToMatrix","addQuaternions","scaleQuaternion","Box","constructor","position","width","length","height","inverseMass","inertia","momentum","rotation","angularMomentum","setInertia","multiplyScalar","applyMatrix3","I_xx","I_yy","I_zz","I_xy","I_yx","I_xz","I_zx","I_yz","I_zy","set","integrate","duration","addScaledVector","testIntegrate","I_b_inverse","clone","invert","rotationMatrix","I_inverse","multiply","transpose","angularVelocity","ddt_Rotation","x","y","z","normalize","console","log","identity"],"sources":["/Users/danny/Github/physics_engine_for_the_web/frontend/src/physics_engine/Box.ts"],"sourcesContent":["import * as THREE from \"three\";\nimport { Vector3, Matrix3, Quaternion } from \"three\";\nimport { getVectorCrossMatrix, addMatrices, convertQuaternionToMatrix, addQuaternions, scaleQuaternion } from \"./math_library\";\n\nexport class Box {\n    public inverseMass: number;\n\n    public width: number;\n    public length: number;\n    public height: number;\n\n    public inertia: Matrix3; // inertia tensor in body space\n\n    public position: Vector3;\n    public momentum: Vector3;\n\n    public rotation: Quaternion // the orientation\n    //public rotation: Matrix3; // the orientation\n    public angularMomentum: Vector3;\n\n    constructor(position: Vector3, width: number, length: number, height: number) {\n        this.inverseMass = 1 / (width * length * height);\n\n        this.width = width;\n        this.length = length;\n        this.height = height;\n\n        this.inertia = new Matrix3();\n        this.setInertia();\n        \n        this.position = position;\n        this.momentum = (new Vector3(1, 0, 0)).multiplyScalar(1/this.inverseMass);\n\n        this.rotation = new Quaternion(0, 0, 0, 1);\n        //this.rotation = new Matrix3();\n        this.angularMomentum = new Vector3(0, 0, 1).applyMatrix3(this.inertia);\n    }\n\n    private setInertia(): void {\n        const I_xx = (1/12) * (this.length*this.length + this.height*this.height);\n        const I_yy = (1/12) * (this.width*this.width + this.height*this.height);\n        const I_zz = (1/12) * (this.width*this.width + this.length*this.length);\n        const I_xy = (-1/16) * (this.width*this.length);\n        const I_yx = I_xy;\n        const I_xz = (-1/16) * (this.width*this.height);\n        const I_zx = I_xz;\n        const I_yz = (-1/16) * (this.length*this.height);\n        const I_zy = I_yz;\n\n        this.inertia.set(\n            I_xx, I_xy, I_xz,\n            I_yx, I_yy, I_yz,\n            I_zx, I_zy, I_zz\n        );\n    }\n\n    integrate(duration: number): void {\n        // Don't integrate if mass is infinite or duration <= 0.\n        if (this.inverseMass <= 0 || duration <= 0) {\n            return;\n        }\n\n        this.position.addScaledVector(this.momentum, this.inverseMass * duration);\n\n        // update rotation matrix\n    }\n\n    testIntegrate(duration: number): void {\n        const I_b_inverse = this.inertia.clone().invert();\n        const rotationMatrix = convertQuaternionToMatrix(this.rotation);\n        const I_inverse = rotationMatrix.clone().multiply(I_b_inverse).multiply(rotationMatrix.clone().transpose());\n        const angularVelocity = this.angularMomentum.clone().applyMatrix3(I_inverse);\n\n        // ddt_q = (1/2) * w(t) * q(t)\n        const ddt_Rotation = (new Quaternion(0, angularVelocity.x/2, angularVelocity.y/2, angularVelocity.z/2)).multiply(this.rotation);\n        this.rotation = addQuaternions(this.rotation, scaleQuaternion(ddt_Rotation, duration));\n        this.rotation.normalize();\n\n        console.log(\"angular_velocity: \", angularVelocity);\n        console.log(\"scaled ddt_Rotation: \", scaleQuaternion(ddt_Rotation, duration));\n        console.log(\"rotation: \", this.rotation);\n        console.log(\"test quaternion identity\", new Quaternion().identity);\n    }\n\n    /*testIntegrate(duration: number): void {\n        // update rotation matrix\n\n        const I_b_inverse = this.inertia.clone().invert();\n        const I_inverse = this.rotation.clone().multiply(I_b_inverse).multiply(this.rotation.clone().transpose());\n        const angularVelocity = this.angularMomentum.clone().applyMatrix3(I_inverse);\n        const angularVelocity_star = getVectorCrossMatrix(angularVelocity);\n\n        const ddt_Rotation = angularVelocity_star.clone().multiply(this.rotation);\n        this.rotation = addMatrices(this.rotation, ddt_Rotation.clone().multiplyScalar(duration));\n\n        console.log(\"angularVelocity: \", angularVelocity);\n        console.log(\"angularVelocity_star\", angularVelocity_star);\n        console.log(\"ddt_Rotation: \", ddt_Rotation);\n        console.log(\"ddt_Rotation * duration: \", ddt_Rotation.multiplyScalar(1/60));\n        console.log(\"this.rotation: \", this.rotation);\n        console.log(\"this.rotation * this.rotation transpose: \", this.rotation.clone().multiply(this.rotation.clone().transpose()));\n    }*/\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}