{"ast":null,"code":"import * as THREE from \"three\";\nimport { Vector3 } from \"three\";\nconst DAMPING = 0.999; // should add rotation at some point?\n\nexport class Sphere {\n  // holds the accumulated force to be applied to the next simulation iteration only.\n  // width, length, and height of bounding box\n  // for graphics\n  constructor(position, radius) {\n    this.inverseMass = void 0;\n    this.radius = void 0;\n    this.position = void 0;\n    this.velocity = void 0;\n    this.forceAccum = void 0;\n    this.boundingBox = void 0;\n    this.mesh = void 0;\n    this.boundingBoxMesh = void 0;\n    this.inverseMass = 1 / (4 / 3 * Math.PI * Math.pow(radius, 3));\n    this.radius = radius;\n    this.position = position;\n    this.velocity = new Vector3(0, 0, 0);\n    this.forceAccum = new Vector3(0, 0, 0);\n    this.boundingBox = new Vector3(radius, radius, radius);\n  }\n\n  integrate(duration) {\n    // Don't integrate if mass is infinite or duration <= 0.\n    if (this.inverseMass <= 0 || duration <= 0) return; // Work out the acceleration from the force.\n    // this.acceleration = this.forceAccum.clone().multiplyScalar(this.inverseMass);\n    // update the linear position.\n\n    this.position.addScaledVector(this.velocity, duration); // Clear the forces.\n\n    this.clearAccumulator(); // impose drag.\n    // this.velocity.multiplyScalar(Math.pow(DAMPING, duration));\n    // update the velocity from the acceleration.\n    // this.velocity.addScaledVector(this.acceleration, duration);\n  }\n\n  applyImpulse(point, impulse) {\n    this.velocity.add(impulse.clone().multiplyScalar(this.inverseMass));\n  } // Clears the forces applied to the particle.\n\n\n  clearAccumulator() {\n    this.forceAccum = new Vector3(0, 0, 0);\n  }\n\n  createMesh() {\n    const sphereGeometry = new THREE.SphereGeometry(this.radius);\n    const material = new THREE.MeshPhongMaterial({\n      color: 0x00bcd6\n    });\n    this.mesh = new THREE.Mesh(sphereGeometry, material);\n  } // updates mesh to current position and orientation\n\n\n  updateMesh() {\n    this.mesh.position.set(this.position.x, this.position.y, this.position.z);\n  }\n\n  createBoundingBoxMesh() {\n    const boxGeometry = new THREE.BoxGeometry(this.boundingBox.x, this.boundingBox.y, this.boundingBox.z);\n    const wireframe = new THREE.WireframeGeometry(boxGeometry);\n    this.boundingBoxMesh = new THREE.LineSegments(wireframe);\n    this.boundingBoxMesh.material = new THREE.LineBasicMaterial({\n      color: 0xffffff\n    });\n  }\n\n  updateBoundingBoxMesh() {\n    this.boundingBoxMesh.position.set(this.position.x, this.position.y, this.position.z);\n  }\n\n}","map":{"version":3,"names":["THREE","Vector3","DAMPING","Sphere","constructor","position","radius","inverseMass","velocity","forceAccum","boundingBox","mesh","boundingBoxMesh","Math","PI","pow","integrate","duration","addScaledVector","clearAccumulator","applyImpulse","point","impulse","add","clone","multiplyScalar","createMesh","sphereGeometry","SphereGeometry","material","MeshPhongMaterial","color","Mesh","updateMesh","set","x","y","z","createBoundingBoxMesh","boxGeometry","BoxGeometry","wireframe","WireframeGeometry","LineSegments","LineBasicMaterial","updateBoundingBoxMesh"],"sources":["/Users/danny/Github/physics_engine_for_the_web/frontend/src/physics_engine/Sphere.ts"],"sourcesContent":["import * as THREE from \"three\";\nimport { Line, LineSegments, Mesh, Vector3 } from \"three\";\n\nconst DAMPING = 0.999;\n\n// should add rotation at some point?\nexport class Sphere {\n    public inverseMass: number;\n\n    public radius: number;\n    \n    public position: Vector3;\n    public velocity: Vector3;\n\n    // holds the accumulated force to be applied to the next simulation iteration only.\n    public forceAccum: Vector3;\n\n    public boundingBox: Vector3; // width, length, and height of bounding box\n\n    // for graphics\n    public mesh: Mesh;\n    public boundingBoxMesh: LineSegments;\n\n    constructor(position: Vector3, radius: number) {\n        this.inverseMass = 1 / (4/3*Math.PI*Math.pow(radius, 3));\n        this.radius = radius;\n\n        this.position = position;\n        this.velocity = new Vector3(0, 0, 0);\n\n        this.forceAccum = new Vector3(0, 0, 0);\n\n        this.boundingBox = new Vector3(radius, radius, radius);\n    }\n\n    integrate(duration: number): void {\n        // Don't integrate if mass is infinite or duration <= 0.\n        if (this.inverseMass <= 0 || duration <= 0)\n            return;\n\n        // Work out the acceleration from the force.\n        // this.acceleration = this.forceAccum.clone().multiplyScalar(this.inverseMass);\n\n        // update the linear position.\n        this.position.addScaledVector(this.velocity, duration);\n\n        // Clear the forces.\n        this.clearAccumulator();\n\n        // impose drag.\n        // this.velocity.multiplyScalar(Math.pow(DAMPING, duration));\n\n        // update the velocity from the acceleration.\n        // this.velocity.addScaledVector(this.acceleration, duration);\n    }\n\n    applyImpulse(point: Vector3, impulse: Vector3) {\n        this.velocity.add(impulse.clone().multiplyScalar(this.inverseMass));\n    }\n\n    // Clears the forces applied to the particle.\n    clearAccumulator(): void {\n        this.forceAccum = new Vector3(0, 0, 0);\n    }\n\n    private createMesh(): void {\n        const sphereGeometry = new THREE.SphereGeometry(this.radius);\n        const material = new THREE.MeshPhongMaterial({ color: 0x00bcd6 });\n        this.mesh = new THREE.Mesh(sphereGeometry, material);\n    }\n\n    // updates mesh to current position and orientation\n    updateMesh(): void {\n        this.mesh.position.set(this.position.x, this.position.y, this.position.z);\n    }\n\n    private createBoundingBoxMesh(): void {\n        const boxGeometry = new THREE.BoxGeometry(this.boundingBox.x, this.boundingBox.y, this.boundingBox.z);\n        const wireframe = new THREE.WireframeGeometry(boxGeometry);\n        this.boundingBoxMesh = new THREE.LineSegments( wireframe );\n        this.boundingBoxMesh.material = new THREE.LineBasicMaterial({ color: 0xffffff });\n    }\n\n    updateBoundingBoxMesh(): void {\n        this.boundingBoxMesh.position.set(this.position.x, this.position.y, this.position.z);\n    }\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}