{"ast":null,"code":"import { Matrix3, Vector3 } from \"three\";\n// import { Sphere } from \"three\";\nconst dt = 1 / 60; // time step in seconds\n\nexport class World {\n  constructor() {\n    this.objects = [];\n    this.currentLoopInterval = null;\n    this.characterForce = void 0;\n    this.objects = [];\n    this.characterForce = new Vector3(0, 0, 0);\n  }\n\n  startLoop() {\n    const currentInstance = this; // stop current loop if it exits\n\n    this.stopCurrentLoop();\n    let lastTimeCalled = performance.now();\n    let fps = 0;\n    let times = [];\n\n    function step() {\n      // calculate fps\n      const now = performance.now();\n\n      while (times.length > 0 && times[0] <= now - 1000) {\n        times.shift();\n      }\n\n      times.push(now);\n      fps = times.length; // console.log(\"fps: \", fps);\n\n      for (let i = 0; i < currentInstance.objects.length; i++) {\n        currentInstance.objects[i].integrate(dt);\n      }\n    }\n\n    this.currentLoopInterval = setInterval(step, dt * 1000);\n  }\n  /** Stops current loop if it exists. */\n\n\n  stopCurrentLoop() {\n    if (this.currentLoopInterval) {\n      clearInterval(this.currentLoopInterval);\n    }\n  }\n\n  addObject(obj) {\n    this.objects.push(obj);\n  }\n\n  getObjects() {\n    return this.objects;\n  }\n\n  updateCharacterForce(f) {\n    this.characterForce = f;\n  }\n\n  detectCollisions() {}\n\n  checkCollisionSpheres(s1, s2) {\n    const d = s1.position.clone().sub(s2.position).length(); // distance between centers\n    // collision if distance between spheres is smaller than sub of radiuses\n\n    if (d < s1.radius + s2.radius) {\n      return true;\n    }\n\n    return false;\n  }\n\n  resolveCollisionSpheres(s1, s2) {\n    // find unit vectors from s1 to s2 and s2 to s1\n    const u12 = s2.position.clone().sub(s1.position).normalize();\n    const u21 = u12.clone().multiplyScalar(-1); // find components of v1 and v2 along and perpendicular to u\n\n    const v1_along_u12 = u12.clone().multiplyScalar(u12.dot(s1.velocity));\n    const v2_along_u21 = u21.clone().multiplyScalar(u21.dot(s2.velocity));\n    const v1_perp_u12 = s1.velocity.clone().sub(v1_along_u12);\n    const v2_perp_u21 = s2.velocity.clone().sub(v2_along_u21); // calculate new velocities along u, assuming elastic collision\n\n    const m1 = 1 / s1.inverseMass;\n    const m2 = 1 / s2.inverseMass;\n    const v1_along_u_new = v1_along_u12.clone().multiplyScalar((m1 - m2) / (m1 + m2)).addScaledVector(v2_along_u21, 2 * m2 / (m1 + m2));\n    const v2_along_u_new = v1_along_u12.clone().multiplyScalar(2 * m1 / (m1 + m2)).addScaledVector(v2_along_u21, -(m1 - m2) / (m1 + m2)); // calculate and set new velocities\n\n    const v1_new = v1_along_u_new.clone().add(v1_perp_u12);\n    const v2_new = v2_along_u_new.clone().add(v2_perp_u21);\n    console.log(\"u: \", u12);\n    console.log(\"v1_new: \", v1_new);\n    console.log(\"v2_new\", v2_new);\n  }\n\n  clearCurrentLoop() {\n    clearInterval(this.currentLoopInterval);\n  }\n\n}\n/**\n * checks if the bounding box of two objects intersect\n * @param a the first object\n * @param b the other object\n */\n\nexport function checkBoundingBoxIntersection(a, b) {\n  // create intervals\n  const a_x_min = a.position.x - a.boundingBox.x / 2;\n  const a_x_max = a.position.x + a.boundingBox.x / 2;\n  const a_y_min = a.position.y - a.boundingBox.y / 2;\n  const a_y_max = a.position.y + a.boundingBox.y / 2;\n  const a_z_min = a.position.z - a.boundingBox.z / 2;\n  const a_z_max = a.position.z + a.boundingBox.z / 2;\n  const b_x_min = b.position.x - b.boundingBox.x / 2;\n  const b_x_max = b.position.x + b.boundingBox.x / 2;\n  const b_y_min = b.position.y - b.boundingBox.y / 2;\n  const b_y_max = b.position.y + b.boundingBox.y / 2;\n  const b_z_min = b.position.z - b.boundingBox.z / 2;\n  const b_z_max = b.position.z + b.boundingBox.z / 2; // intersecting if all intervals are intersecting\n\n  if (a_x_min < b_x_max && b_x_min < a_x_max && a_y_min < b_y_max && b_y_min < a_y_max && a_z_min < b_z_max && b_z_min < a_z_max) {\n    return true;\n  }\n\n  return false;\n}\nexport function getAllBoundingBoxIntersections(boxes) {\n  // for now just sort against x-axis. Slightly better is to update axis based on one with highest variance\n  // worst case is still O(n^2)\n  function compareBoundingBoxes(a, b) {\n    const a_min = a.position.x - a.boundingBox.x / 2;\n    const b_min = b.position.x - b.boundingBox.x / 2;\n    return a_min - b_min;\n  } // sort objects along x-axis\n\n\n  const boxesCopy = [...boxes];\n  boxesCopy.sort(compareBoundingBoxes); // sweep the array for collisions\n\n  const intersections = [];\n\n  for (let i = 0; i < boxesCopy.length - 1; i++) {\n    // test against all possible overlapping boxes following the current one.\n    for (let j = i + 1; j < boxesCopy.length; j++) {\n      // stop testing when AABBs are beyond the current AABB\n      const i_max = boxesCopy[i].position.x + boxesCopy[i].boundingBox.x / 2;\n      const j_min = boxesCopy[j].position.x - boxesCopy[j].boundingBox.x / 2;\n\n      if (j_min > i_max) {\n        break;\n      }\n\n      if (checkBoundingBoxIntersection(boxesCopy[i], boxesCopy[j])) {\n        intersections.push({\n          a: boxesCopy[i],\n          b: boxesCopy[j]\n        });\n      }\n    }\n  }\n\n  return intersections;\n}\nexport function checkCollision(a, b) {\n  // two convex objects don't collide iff there exists a separating plane between them\n  // search for separating plane.\n  // either its contain a face of one polyhedra or it contains an edge of one polyhedra and is parallel to the edge of the other polyhedra.\n  const a_facePlanes = getFacePlanes(a);\n\n  for (let facePlane of a_facePlanes) {\n    if (testSeparatingAxis(a, b, facePlane.normal)) {\n      return false;\n    }\n\n    ;\n  }\n\n  const b_facePlanes = getFacePlanes(b);\n\n  for (let facePlane of b_facePlanes) {\n    if (testSeparatingAxis(a, b, facePlane.normal)) {\n      return false;\n    }\n  }\n\n  const a_edges = getEdges(a);\n  const b_edges = getEdges(b);\n\n  for (let i = 0; i < a_edges.length; i++) {\n    for (let j = 0; j < b_edges.length; j++) {\n      const edge_i = a_edges[i].b.clone().sub(a_edges[i].a);\n      const edge_j = b_edges[j].b.clone().sub(b_edges[j].a);\n      let m = edge_i.clone().cross(edge_j);\n\n      if (m.length() !== 0) {\n        // note to self: should use epsilon when checking for zero vector to improve stability\n        if (testSeparatingAxis(a, b, m)) {\n          return false;\n        }\n      } else {\n        const edge_n = b_edges[j].b.clone().sub(a_edges[i].a);\n        m = edge_i.clone().cross(edge_n);\n\n        if (m.length() !== 0) {\n          testSeparatingAxis(a, b, m);\n        } else {\n          return true; // since edge_i and edge_2 are colinear\n        }\n      }\n    }\n  }\n\n  return true;\n}\nexport function getContacts(boundingBoxIntersections) {\n  const contacts = [];\n\n  for (let i = 0; i < boundingBoxIntersections.length; i++) {\n    const a = boundingBoxIntersections[i].a;\n    const b = boundingBoxIntersections[i].b; // check for collisions and color them\n\n    if (checkCollision(a, b)) {\n      const contact = getContactData(a, b);\n      contacts.push(contact);\n    }\n  }\n\n  return contacts;\n} // returns all contacts of two colliding boxes, assuming collision\n\n/*export function getAllContacts(a: Box, b: Box) {\n    const epsilon = 0.005;  // allowable penetration to be considered a contact\n    const vector_ab = a.position.clone().sub(b.position);\n\n    const a_x = new Vector3(a.width, 0, 0);\n    const a_y = new Vector3(0, a.length, 0);\n    const a_z = new Vector3(0, 0, a.height);\n    a_x.applyQuaternion(a.rotation);\n    a_y.applyQuaternion(a.rotation);\n    a_z.applyQuaternion(a.rotation);\n    const a_vectors = [a_x, a_y, a_z];\n    const contacts = [];\n    for (let i = 0; i < a_vectors.length; i++) {\n        // flip axis to be normal of contacting face\n        let axis = a_vectors[i];\n        if (vector_ab.clone().dot(axis) < 0) { // set axis to normal of the correct face.\n            axis.multiplyScalar(-1);\n        }\n    }\n}*/\n// get contact data for two colliding boxes, assuming collision\n\nexport function getContactData(a, b) {\n  const vector_ab = a.position.clone().sub(b.position);\n  const a_facePlanes = getFacePlanes(a);\n  let smallestOverlap = Infinity;\n  let contact;\n\n  for (let facePlane of a_facePlanes) {\n    const overlap = separatingAxisPenetration(a, b, facePlane.normal);\n\n    if (overlap < smallestOverlap) {\n      smallestOverlap = overlap; // set contact\n\n      let axis = facePlane.normal.clone();\n\n      if (vector_ab.clone().dot(axis) > 0) {\n        // set axis to normal of the correct face.\n        axis.multiplyScalar(-1);\n      }\n\n      axis.normalize();\n      const vertex = getClosestVertex(a, b, axis);\n      contact = {\n        a: a,\n        b: b,\n        type: \"vertex-face\",\n        contactNormal: axis,\n        penetration: smallestOverlap,\n        contactPoint: vertex\n      };\n    }\n  }\n\n  const b_facePlanes = getFacePlanes(b);\n\n  for (let facePlane of b_facePlanes) {\n    const overlap = separatingAxisPenetration(a, b, facePlane.normal);\n\n    if (overlap < smallestOverlap) {\n      smallestOverlap = overlap; // set contact\n      // set contact\n\n      let axis = facePlane.normal.clone();\n\n      if (vector_ab.clone().dot(axis) < 0) {\n        // set axis to normal of the correct face.\n        axis.multiplyScalar(-1);\n      }\n\n      axis.normalize();\n      const vertex = getClosestVertex(b, a, axis);\n      contact = {\n        a: a,\n        b: b,\n        type: \"vertex-face\",\n        contactNormal: axis,\n        penetration: smallestOverlap,\n        contactPoint: vertex\n      };\n    }\n  }\n\n  const a_edges = getEdges(a);\n  const b_edges = getEdges(b);\n\n  for (let i = 0; i < a_edges.length; i++) {\n    for (let j = 0; j < b_edges.length; j++) {\n      const edge_i = a_edges[i].b.clone().sub(a_edges[i].a);\n      const edge_j = b_edges[j].b.clone().sub(b_edges[j].a);\n      let m = edge_i.clone().cross(edge_j);\n\n      if (m.length() !== 0) {\n        // note to self: should use epsilon when checking for zero vector to improve stability\n        const overlap = separatingAxisPenetration(a, b, m);\n\n        if (overlap < smallestOverlap) {\n          smallestOverlap = overlap; // set contact\n\n          const edge_i_points = getClosestEdge(b, a, edge_i, m);\n          const edge_j_points = getClosestEdge(a, b, edge_j, m);\n          m.normalize();\n          contact = {\n            a: a,\n            b: b,\n            type: \"edge-edge\",\n            contactNormal: m,\n            penetration: smallestOverlap,\n            edge_a: edge_i_points,\n            edge_b: edge_j_points\n          };\n        }\n      } else {\n        const edge_n = b_edges[j].b.clone().sub(a_edges[i].a);\n        m = edge_i.clone().cross(edge_n);\n\n        if (m.length() !== 0) {\n          const overlap = separatingAxisPenetration(a, b, m);\n\n          if (overlap < smallestOverlap) {\n            smallestOverlap = overlap;\n          } // set contact\n\n\n          const edge_i_points = getClosestEdge(b, a, edge_i, m);\n          const edge_j_points = getClosestEdge(a, b, edge_j, m);\n          m.normalize();\n          contact = {\n            a: a,\n            b: b,\n            type: \"edge-edge\",\n            contactNormal: m,\n            penetration: smallestOverlap,\n            edge_a: edge_i_points,\n            edge_b: edge_j_points\n          };\n        } else {\n          continue;\n        }\n      }\n    }\n  }\n\n  return contact;\n}\nexport function resolveCollision(contactData) {\n  const a = contactData.a;\n  const b = contactData.b;\n\n  if (contactData.type === \"vertex-face\") {\n    const vertex = contactData.contactPoint;\n    const vertexVelocity_a = a.velocity.clone().add(a.getAngularVelocity.cross(vertex.clone().sub(a.position)));\n    const vertexVelocity_b = b.velocity.clone().add(b.getAngularVelocity.cross(vertex.clone().sub(b.position)));\n    const relativeVelocity = contactData.normal.dot(vertexVelocity_a.clone().sub(vertexVelocity_b));\n\n    if (relativeVelocity < 0) {\n      console.log(\"colliding contact\");\n    } else if (relativeVelocity === 0) {\n      console.log(\"resting contact\");\n    } else {// ignore\n    }\n  } else if (contactData.type === \"edge-edge\") {} else {\n    console.error(\"contactData type not recognized.\");\n  }\n} // returns closest edge of box b\n// edge should be parallel to input edgeVector\n\nfunction getClosestEdge(a, b, edgeVector, separatingAxis) {\n  const x = separatingAxis.x;\n  const y = separatingAxis.y;\n  const z = separatingAxis.z;\n  const projectionMatrix = new Matrix3();\n  projectionMatrix.set(x * x, x * y, x * z, x * y, y * y, y * z, x * z, y * z, z * z);\n  const a_center = a.position.clone().applyMatrix3(projectionMatrix);\n  const b_edges = getEdges(b);\n  const parallel_b_edges = [];\n\n  for (let b_edge of b_edges) {\n    const b_edgeVector = b_edge.b.clone().sub(b_edge.a);\n\n    if (b_edgeVector.clone().cross(edgeVector).length() === 0) {\n      parallel_b_edges.push(b_edge);\n    }\n  }\n\n  let closestEdge = parallel_b_edges[0];\n  let closestDistance = closestEdge.a.clone().sub(a_center).length();\n\n  for (let b_edge of parallel_b_edges) {\n    const d = b_edge.a.clone().sub(a_center).length();\n\n    if (d < closestDistance) {\n      closestDistance = d;\n      closestEdge = b_edge;\n    }\n  }\n\n  return closestEdge;\n} // returns closest vertex of box b to face of box a\n\n\nfunction getClosestVertex(a, b, lineVector) {\n  const b_vertices = getVertices(b);\n  let vertex = b_vertices[0];\n  const x = lineVector.x;\n  const y = lineVector.y;\n  const z = lineVector.z;\n  const projectionMatrix = new Matrix3();\n  projectionMatrix.set(x * x, x * y, x * z, x * y, y * y, y * z, x * z, y * z, z * z);\n  const a_center = a.position.clone().applyMatrix3(projectionMatrix);\n  const b_center = b.position.clone().applyMatrix3(projectionMatrix);\n  let smallestDistanceToA = b_center.clone().sub(a_center).length();\n\n  for (let b_v of b_vertices) {\n    const b_v_projection = b_v.applyMatrix3(projectionMatrix);\n    const d = b_v_projection.clone().sub(a_center).length();\n\n    if (d < smallestDistanceToA) {\n      smallestDistanceToA = d;\n      vertex = b_v;\n    }\n  }\n\n  return vertex;\n}\n\nfunction separatingAxisPenetration(a, b, lineVector) {\n  const x = lineVector.x;\n  const y = lineVector.y;\n  const z = lineVector.z;\n  const projectionMatrix = new Matrix3();\n  projectionMatrix.set(x * x, x * y, x * z, x * y, y * y, y * z, x * z, y * z, z * z);\n  const a_center = a.position.clone().applyMatrix3(projectionMatrix);\n  const b_center = b.position.clone().applyMatrix3(projectionMatrix);\n  const d = b_center.clone().sub(a_center).length();\n  const a_vertices = getVertices(a);\n  const b_vertices = getVertices(b);\n  let r_a = 0,\n      r_b = 0;\n\n  for (let a_v of a_vertices) {\n    const a_v_projection = a_v.applyMatrix3(projectionMatrix);\n    const r = a_center.clone().sub(a_v_projection).length();\n\n    if (r > r_a) {\n      r_a = r;\n    }\n  }\n\n  for (let b_v of b_vertices) {\n    const b_v_projection = b_v.applyMatrix3(projectionMatrix);\n    const r = b_center.clone().sub(b_v_projection).length();\n\n    if (r > r_b) {\n      r_b = r;\n    }\n  } // returns the overlap. positive indicates overlap, negative indicates separation.\n\n\n  return r_a + r_b - d;\n}\n/**\n * for symmetrical objects, valid separating axis iff sum the radii (half_widths) of the projected intervals is less than the distance between the centers\n * @param a \n * @param b \n * @param lineVector a unit vector describing the direction of the line\n * @returns true if the lineVector is a separating axis\n */\n\n\nexport function testSeparatingAxis(a, b, lineVector) {\n  const x = lineVector.x;\n  const y = lineVector.y;\n  const z = lineVector.z;\n  const projectionMatrix = new Matrix3();\n  projectionMatrix.set(x * x, x * y, x * z, x * y, y * y, y * z, x * z, y * z, z * z);\n  const a_center = a.position.clone().applyMatrix3(projectionMatrix);\n  const b_center = b.position.clone().applyMatrix3(projectionMatrix);\n  const d = b_center.clone().sub(a_center).length();\n  const a_vertices = getVertices(a);\n  const b_vertices = getVertices(b);\n  let r_a = 0,\n      r_b = 0;\n\n  for (let a_v of a_vertices) {\n    const a_v_projection = a_v.applyMatrix3(projectionMatrix);\n    const r = a_center.clone().sub(a_v_projection).length();\n\n    if (r > r_a) {\n      r_a = r;\n    }\n  }\n\n  for (let b_v of b_vertices) {\n    const b_v_projection = b_v.applyMatrix3(projectionMatrix);\n    const r = b_center.clone().sub(b_v_projection).length();\n\n    if (r > r_b) {\n      r_b = r;\n    }\n  }\n\n  if (r_a + r_b < d) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction getVertices(box) {\n  const x = box.position.x;\n  const y = box.position.y;\n  const z = box.position.z;\n  const v1 = new Vector3(x - box.width / 2, y - box.length / 2, z - box.height / 2);\n  const v2 = new Vector3(x - box.width / 2, y + box.length / 2, z - box.height / 2);\n  const v3 = new Vector3(x + box.width / 2, y + box.length / 2, z - box.height / 2);\n  const v4 = new Vector3(x + box.width / 2, y - box.length / 2, z - box.height / 2);\n  const v5 = new Vector3(x - box.width / 2, y - box.length / 2, z + box.height / 2);\n  const v6 = new Vector3(x - box.width / 2, y + box.length / 2, z + box.height / 2);\n  const v7 = new Vector3(x + box.width / 2, y + box.length / 2, z + box.height / 2);\n  const v8 = new Vector3(x + box.width / 2, y - box.length / 2, z + box.height / 2);\n  const vertices = [v1, v2, v3, v4, v5, v6, v7, v8]; // rotate vertices\n\n  for (let vertex of vertices) {\n    // convert to body space, apply rotation, convert back to world space\n    vertex.sub(box.position);\n    vertex.applyQuaternion(box.rotation);\n    vertex.add(box.position);\n  }\n\n  return vertices;\n}\n\nfunction getEdges(box) {\n  const x = box.position.x;\n  const y = box.position.y;\n  const z = box.position.z;\n  const v1 = new Vector3(x - box.width / 2, y - box.length / 2, z - box.height / 2);\n  const v2 = new Vector3(x - box.width / 2, y + box.length / 2, z - box.height / 2);\n  const v3 = new Vector3(x + box.width / 2, y + box.length / 2, z - box.height / 2);\n  const v4 = new Vector3(x + box.width / 2, y - box.length / 2, z - box.height / 2);\n  const v5 = new Vector3(x - box.width / 2, y - box.length / 2, z + box.height / 2);\n  const v6 = new Vector3(x - box.width / 2, y + box.length / 2, z + box.height / 2);\n  const v7 = new Vector3(x + box.width / 2, y + box.length / 2, z + box.height / 2);\n  const v8 = new Vector3(x + box.width / 2, y - box.length / 2, z + box.height / 2);\n  const vertices = [v1, v2, v3, v4, v5, v6, v7, v8]; // rotate vertices\n\n  for (let vertex of vertices) {\n    // convert to body space, apply rotation, convert back to world space\n    vertex.sub(box.position);\n    vertex.applyQuaternion(box.rotation);\n    vertex.add(box.position);\n  }\n\n  const edges = [];\n  edges.push({\n    a: v1,\n    b: v2\n  });\n  edges.push({\n    a: v1,\n    b: v4\n  });\n  edges.push({\n    a: v1,\n    b: v5\n  });\n  edges.push({\n    a: v2,\n    b: v3\n  });\n  edges.push({\n    a: v2,\n    b: v6\n  });\n  edges.push({\n    a: v3,\n    b: v4\n  });\n  edges.push({\n    a: v3,\n    b: v7\n  });\n  edges.push({\n    a: v4,\n    b: v8\n  });\n  edges.push({\n    a: v5,\n    b: v6\n  });\n  edges.push({\n    a: v5,\n    b: v8\n  });\n  edges.push({\n    a: v6,\n    b: v7\n  });\n  edges.push({\n    a: v7,\n    b: v8\n  });\n  return edges;\n}\n\nfunction getFacePlanes(box) {\n  const x = box.position.x;\n  const y = box.position.y;\n  const z = box.position.z;\n  const v1 = new Vector3(x - box.width / 2, y - box.length / 2, z - box.height / 2);\n  const v2 = new Vector3(x - box.width / 2, y + box.length / 2, z - box.height / 2);\n  const v3 = new Vector3(x + box.width / 2, y + box.length / 2, z - box.height / 2);\n  const v4 = new Vector3(x + box.width / 2, y - box.length / 2, z - box.height / 2);\n  const v5 = new Vector3(x - box.width / 2, y - box.length / 2, z + box.height / 2);\n  const v6 = new Vector3(x - box.width / 2, y + box.length / 2, z + box.height / 2);\n  const v7 = new Vector3(x + box.width / 2, y + box.length / 2, z + box.height / 2);\n  const v8 = new Vector3(x + box.width / 2, y - box.length / 2, z + box.height / 2);\n  const vertices = [v1, v2, v3, v4, v5, v6, v7, v8]; // rotate vertices\n\n  for (let vertex of vertices) {\n    // convert to body space, apply rotation, convert back to world space\n    vertex.sub(box.position);\n    vertex.applyQuaternion(box.rotation);\n    vertex.add(box.position);\n  }\n\n  const face1 = {\n    normal: v2.clone().sub(v1).cross(v4.clone().sub(v1)).normalize(),\n    point: v1\n  }; // bottom plane\n\n  const face2 = {\n    normal: v8.clone().sub(v5).cross(v6.clone().sub(v5)).normalize(),\n    point: v5\n  }; // top plane\n\n  const face3 = {\n    normal: v5.clone().sub(v1).cross(v2.clone().sub(v1)).normalize(),\n    point: v1\n  }; // left plane\n\n  const face4 = {\n    normal: v3.clone().sub(v4).cross(v8.clone().sub(v4)).normalize(),\n    point: v4\n  }; // top plane\n\n  const face5 = {\n    normal: v4.clone().sub(v1).cross(v5.clone().sub(v1)).normalize(),\n    point: v1\n  }; // front plane\n\n  const face6 = {\n    normal: v2.clone().sub(v3).cross(v7.clone().sub(v3)).normalize(),\n    point: v3\n  }; // back plane\n\n  const facePlanes = [face1, face2, face3, face4, face5, face6];\n  return facePlanes;\n}\n/*\nfunction getFaces(box: Box) {\n    const x = box.position.x;\n    const y = box.position.y;\n    const z = box.position.z;\n    const v1 = new Vector3(x - box.width/2, y - box.length/2, z - box.height/2);\n    const v2 = new Vector3(x - box.width/2, y + box.length/2, z - box.height/2);\n    const v3 = new Vector3(x + box.width/2, y + box.length/2, z - box.height/2);\n    const v4 = new Vector3(x + box.width/2, y - box.length/2, z - box.height/2);\n    const v5 = new Vector3(x - box.width/2, y - box.length/2, z + box.height/2);\n    const v6 = new Vector3(x - box.width/2, y + box.length/2, z + box.height/2);\n    const v7 = new Vector3(x + box.width/2, y + box.length/2, z + box.height/2);\n    const v8 = new Vector3(x + box.width/2, y - box.length/2, z + box.height/2);\n    const vertices = [v1, v2, v3, v4, v5, v6, v7, v8];\n\n    // rotate vertices\n    for (let vertex of vertices) {\n        // convert to body space, apply rotation, convert back to world space\n        vertex.sub(box.position);\n        vertex.applyQuaternion(box.rotation);\n        vertex.add(box.position);\n    }\n    \n    const f1 = { edges: [{a: v1, b: v2}, {a: v1, b: v4}, {a: v2, b: v3}, {a: v3, b: v4}] }; // bottom\n    const f2 = { edges: [{a: v5, b: v6}, {a: v5, b: v8}, {a: v6, b: v7}, {a: v7, b: v8}] }; // top\n    const f3 = { edges: [{a: v1, b: v2}, {a: v1, b: v5}, {a: v5, b: v6}, {a: v6, b: v2}] }; // left\n    const f4 = { edges: [{a: v4, b: v8}, {a: v4, b: v3}, {a: v8, b: v7}, {a: v7, b: v3}] }; // right\n    const f5 = { edges: [{a: v1, b: v4}, {a: v1, b: v5}, {a: v5, b: v8}, {a: v8, b: v4}] }; // front\n    const f6 = { edges: [{a: v2, b: v3}, {a: v2, b: v6}, {a: v6, b: v7}, {a: v7, b: v3}] }; // back\n    const faces = [f1, f2, f3, f4, f5, f6];\n    return faces;\n}*/\n\n/*\nexport function getAllBoundingBoxIntersections(boxes: Box[]) {\n    // create and sort intervals along x, y, and z\n    const x_intervals = [];\n    const y_intervals = [];\n    const z_intervals = [];\n    for(let box of boxes) {\n        const x_min = box.position.x - box.boundingBox.x/2;\n        const x_max = box.position.x + box.boundingBox.x/2;\n        x_intervals.push({ type: \"min\", value: x_min, object: box});\n        x_intervals.push({ type: \"max\", value: x_max, object: box});\n\n        \n        const y_min = box.position.y - box.boundingBox.y/2;\n        const y_max = box.position.y + box.boundingBox.y/2;\n        y_intervals.push({ type: \"min\", value: y_min, object: box});\n        y_intervals.push({ type: \"max\", value: y_max, object: box});\n\n        const z_min = box.position.z - box.boundingBox.z/2;\n        const z_max = box.position.z + box.boundingBox.z/2;\n        z_intervals.push({ type: \"min\", value: z_min, object: box});\n        z_intervals.push({ type: \"max\", value: z_max, object: box});\n    }\n    // note to self: switch to insertion sort and use normal merge sort only during the initialization frame\n    x_intervals.sort((a, b) => a.value - b.value);\n    //y_intervals.sort((a, b) => a.value - b.value);\n    //z_intervals.sort((a, b) => a.value - b.value);\n\n    // create a list of active intervals\n    const activeIntervals = [];\n}*/","map":{"version":3,"names":["Matrix3","Vector3","dt","World","constructor","objects","currentLoopInterval","characterForce","startLoop","currentInstance","stopCurrentLoop","lastTimeCalled","performance","now","fps","times","step","length","shift","push","i","integrate","setInterval","clearInterval","addObject","obj","getObjects","updateCharacterForce","f","detectCollisions","checkCollisionSpheres","s1","s2","d","position","clone","sub","radius","resolveCollisionSpheres","u12","normalize","u21","multiplyScalar","v1_along_u12","dot","velocity","v2_along_u21","v1_perp_u12","v2_perp_u21","m1","inverseMass","m2","v1_along_u_new","addScaledVector","v2_along_u_new","v1_new","add","v2_new","console","log","clearCurrentLoop","checkBoundingBoxIntersection","a","b","a_x_min","x","boundingBox","a_x_max","a_y_min","y","a_y_max","a_z_min","z","a_z_max","b_x_min","b_x_max","b_y_min","b_y_max","b_z_min","b_z_max","getAllBoundingBoxIntersections","boxes","compareBoundingBoxes","a_min","b_min","boxesCopy","sort","intersections","j","i_max","j_min","checkCollision","a_facePlanes","getFacePlanes","facePlane","testSeparatingAxis","normal","b_facePlanes","a_edges","getEdges","b_edges","edge_i","edge_j","m","cross","edge_n","getContacts","boundingBoxIntersections","contacts","contact","getContactData","vector_ab","smallestOverlap","Infinity","overlap","separatingAxisPenetration","axis","vertex","getClosestVertex","type","contactNormal","penetration","contactPoint","edge_i_points","getClosestEdge","edge_j_points","edge_a","edge_b","resolveCollision","contactData","vertexVelocity_a","getAngularVelocity","vertexVelocity_b","relativeVelocity","error","edgeVector","separatingAxis","projectionMatrix","set","a_center","applyMatrix3","parallel_b_edges","b_edge","b_edgeVector","closestEdge","closestDistance","lineVector","b_vertices","getVertices","b_center","smallestDistanceToA","b_v","b_v_projection","a_vertices","r_a","r_b","a_v","a_v_projection","r","box","v1","width","height","v2","v3","v4","v5","v6","v7","v8","vertices","applyQuaternion","rotation","edges","face1","point","face2","face3","face4","face5","face6","facePlanes"],"sources":["/Users/danny/Github/physics_engine_for_the_web/frontend/src/physics_engine/physics_engine.ts"],"sourcesContent":["import { Matrix3, Vector3 } from \"three\";\nimport * as THREE from \"three\";\nimport { Sphere } from \"./Sphere\";\nimport { Box } from \"./Box\";\n// import { Sphere } from \"three\";\n\nconst dt = 1/60; // time step in seconds\n\nexport class World {\n    private objects: any[] = [];\n    private currentLoopInterval: any = null;\n\n    private characterForce: Vector3;\n\n    constructor() {\n        this.objects = [];\n\n        this.characterForce = new Vector3(0, 0, 0);\n    }\n\n    startLoop(): void {\n        const currentInstance = this;\n\n        // stop current loop if it exits\n        this.stopCurrentLoop();\n\n        let lastTimeCalled = performance.now();\n        let fps = 0;\n        let times: any[] = [];\n\n        function step() {\n            // calculate fps\n            const now = performance.now();\n            while (times.length > 0 && times[0] <= now - 1000) {\n                times.shift();\n            }\n            times.push(now);\n            fps = times.length;\n            // console.log(\"fps: \", fps);\n\n            for (let i = 0; i < currentInstance.objects.length; i++) {\n                currentInstance.objects[i].integrate(dt);\n            }\n        }\n\n        this.currentLoopInterval = setInterval(step, dt * 1000);\n    }\n\n    /** Stops current loop if it exists. */\n    stopCurrentLoop(): void {\n        if (this.currentLoopInterval) {\n            clearInterval(this.currentLoopInterval);\n        }\n    }\n\n    addObject(obj: any): void {\n        this.objects.push(obj);\n    }\n\n    getObjects(): any[] {\n        return this.objects;\n    }\n\n    updateCharacterForce(f: Vector3) {\n        this.characterForce = f;\n    }\n\n    detectCollisions(): void {\n\n    }\n\n    checkCollisionSpheres(s1: Sphere, s2: Sphere) {\n        const d = (s1.position.clone().sub(s2.position)).length(); // distance between centers\n\n        // collision if distance between spheres is smaller than sub of radiuses\n        if (d < (s1.radius + s2.radius)) {\n            return true;\n        }\n        return false;\n    }\n\n    resolveCollisionSpheres(s1: Sphere, s2: Sphere) {\n        // find unit vectors from s1 to s2 and s2 to s1\n        const u12 = (s2.position.clone().sub(s1.position)).normalize();\n        const u21 = u12.clone().multiplyScalar(-1);\n\n        // find components of v1 and v2 along and perpendicular to u\n        const v1_along_u12 = u12.clone().multiplyScalar(u12.dot(s1.velocity));\n        const v2_along_u21 = u21.clone().multiplyScalar(u21.dot(s2.velocity));\n\n        const v1_perp_u12 = s1.velocity.clone().sub(v1_along_u12);\n        const v2_perp_u21 = s2.velocity.clone().sub(v2_along_u21);\n\n        // calculate new velocities along u, assuming elastic collision\n        const m1 = 1/s1.inverseMass;\n        const m2 = 1/s2.inverseMass;\n        const v1_along_u_new = (v1_along_u12.clone().multiplyScalar((m1-m2)/(m1+m2))).addScaledVector(v2_along_u21, (2*m2)/(m1+m2));\n        const v2_along_u_new = (v1_along_u12.clone().multiplyScalar((2*m1)/(m1+m2))).addScaledVector(v2_along_u21, -(m1-m2)/(m1+m2));\n\n        // calculate and set new velocities\n        const v1_new = v1_along_u_new.clone().add(v1_perp_u12);\n        const v2_new = v2_along_u_new.clone().add(v2_perp_u21);\n\n        console.log(\"u: \", u12);\n        console.log(\"v1_new: \", v1_new);\n        console.log(\"v2_new\", v2_new);\n    }\n\n    clearCurrentLoop(): void {\n        clearInterval(this.currentLoopInterval);\n    }\n}\n\n/**\n * checks if the bounding box of two objects intersect\n * @param a the first object\n * @param b the other object\n */\nexport function checkBoundingBoxIntersection(a: Box, b: Box): boolean {\n    // create intervals\n    const a_x_min = a.position.x - a.boundingBox.x/2;\n    const a_x_max = a.position.x + a.boundingBox.x/2;\n    const a_y_min = a.position.y - a.boundingBox.y/2;\n    const a_y_max = a.position.y + a.boundingBox.y/2;\n    const a_z_min = a.position.z - a.boundingBox.z/2;\n    const a_z_max = a.position.z + a.boundingBox.z/2;\n    const b_x_min = b.position.x - b.boundingBox.x/2;\n    const b_x_max = b.position.x + b.boundingBox.x/2;\n    const b_y_min = b.position.y - b.boundingBox.y/2;\n    const b_y_max = b.position.y + b.boundingBox.y/2;\n    const b_z_min = b.position.z - b.boundingBox.z/2;\n    const b_z_max = b.position.z + b.boundingBox.z/2;\n\n    // intersecting if all intervals are intersecting\n    if ((a_x_min < b_x_max && b_x_min < a_x_max) &&\n        (a_y_min < b_y_max && b_y_min < a_y_max) &&\n        (a_z_min < b_z_max && b_z_min < a_z_max)) {\n        return true\n    }\n    return false;\n}\n\nexport function getAllBoundingBoxIntersections(boxes: Box[]) {\n    // for now just sort against x-axis. Slightly better is to update axis based on one with highest variance\n    // worst case is still O(n^2)\n\n    function compareBoundingBoxes(a: Box, b: Box) {\n        const a_min = a.position.x - a.boundingBox.x/2;\n        const b_min = b.position.x - b.boundingBox.x/2;\n        return a_min - b_min;\n    }\n\n    // sort objects along x-axis\n    const boxesCopy = [...boxes];\n    boxesCopy.sort(compareBoundingBoxes);\n\n    // sweep the array for collisions\n    const intersections = [];\n    for(let i = 0; i < boxesCopy.length - 1; i++) {\n        // test against all possible overlapping boxes following the current one.\n        for(let j = i + 1; j < boxesCopy.length; j++) {\n            // stop testing when AABBs are beyond the current AABB\n            const i_max = boxesCopy[i].position.x + boxesCopy[i].boundingBox.x/2;\n            const j_min = boxesCopy[j].position.x - boxesCopy[j].boundingBox.x/2;\n            if (j_min > i_max) {\n                break;\n            }\n\n            if (checkBoundingBoxIntersection(boxesCopy[i], boxesCopy[j])) {\n                intersections.push({\n                    a: boxesCopy[i],\n                    b: boxesCopy[j]\n                });\n            }\n        }\n    }\n    return intersections;\n}\n\nexport function checkCollision(a: Box, b: Box): boolean {\n    // two convex objects don't collide iff there exists a separating plane between them\n\n    // search for separating plane.\n    // either its contain a face of one polyhedra or it contains an edge of one polyhedra and is parallel to the edge of the other polyhedra.\n\n    const a_facePlanes = getFacePlanes(a);\n    for (let facePlane of a_facePlanes) {\n        if (testSeparatingAxis(a, b, facePlane.normal)) {\n            return false;\n        };\n    }\n    const b_facePlanes = getFacePlanes(b);\n    for (let facePlane of b_facePlanes) {\n        if (testSeparatingAxis(a, b, facePlane.normal)) {\n            return false;\n        }\n    }\n\n    const a_edges = getEdges(a);\n    const b_edges = getEdges(b);\n\n    for (let i = 0; i < a_edges.length; i++) {\n        for (let j = 0; j < b_edges.length; j++) {\n            const edge_i = a_edges[i].b.clone().sub(a_edges[i].a);\n            const edge_j = b_edges[j].b.clone().sub(b_edges[j].a);\n            let m = edge_i.clone().cross(edge_j);\n            if (m.length() !== 0) { // note to self: should use epsilon when checking for zero vector to improve stability\n                if (testSeparatingAxis(a, b, m)) {\n                    return false;\n                }\n            } else {\n                const edge_n = b_edges[j].b.clone().sub(a_edges[i].a);\n                m = edge_i.clone().cross(edge_n);\n                if (m.length() !== 0) {\n                    testSeparatingAxis(a, b, m);\n                } else {\n                    return true; // since edge_i and edge_2 are colinear\n                }\n            }\n        }\n    }\n\n    return true;\n}\n\nexport function getContacts(boundingBoxIntersections: any[]) {\n    const contacts = [];\n    for(let i = 0; i < boundingBoxIntersections.length; i++) {\n        const a = boundingBoxIntersections[i].a;\n        const b = boundingBoxIntersections[i].b;\n\n        // check for collisions and color them\n        if (checkCollision(a, b)) {\n            const contact = getContactData(a, b);\n            contacts.push(contact);\n        }\n    }\n\n    return contacts;\n}\n\n// returns all contacts of two colliding boxes, assuming collision\n/*export function getAllContacts(a: Box, b: Box) {\n    const epsilon = 0.005;  // allowable penetration to be considered a contact\n    const vector_ab = a.position.clone().sub(b.position);\n\n    const a_x = new Vector3(a.width, 0, 0);\n    const a_y = new Vector3(0, a.length, 0);\n    const a_z = new Vector3(0, 0, a.height);\n    a_x.applyQuaternion(a.rotation);\n    a_y.applyQuaternion(a.rotation);\n    a_z.applyQuaternion(a.rotation);\n    const a_vectors = [a_x, a_y, a_z];\n    const contacts = [];\n    for (let i = 0; i < a_vectors.length; i++) {\n        // flip axis to be normal of contacting face\n        let axis = a_vectors[i];\n        if (vector_ab.clone().dot(axis) < 0) { // set axis to normal of the correct face.\n            axis.multiplyScalar(-1);\n        }\n    }\n}*/\n\n// get contact data for two colliding boxes, assuming collision\nexport function getContactData(a: Box, b: Box) {\n    const vector_ab = a.position.clone().sub(b.position);\n    const a_facePlanes = getFacePlanes(a);\n    let smallestOverlap = Infinity;\n    let contact;\n    for (let facePlane of a_facePlanes) {\n        const overlap = separatingAxisPenetration(a, b, facePlane.normal);\n        if (overlap < smallestOverlap) {\n            smallestOverlap = overlap;\n\n            // set contact\n            let axis = facePlane.normal.clone();\n            if (vector_ab.clone().dot(axis) > 0) { // set axis to normal of the correct face.\n                axis.multiplyScalar(-1);\n            }\n            axis.normalize();\n            const vertex = getClosestVertex(a, b, axis);\n            contact = {\n                a: a,\n                b: b,\n                type: \"vertex-face\",\n                contactNormal: axis,\n                penetration: smallestOverlap,\n                contactPoint: vertex\n            };\n        }\n    }\n    const b_facePlanes = getFacePlanes(b);\n    for (let facePlane of b_facePlanes) {\n        const overlap = separatingAxisPenetration(a, b, facePlane.normal);\n        if (overlap < smallestOverlap) {\n            smallestOverlap = overlap;\n\n            // set contact\n            // set contact\n            let axis = facePlane.normal.clone();\n            if (vector_ab.clone().dot(axis) < 0) { // set axis to normal of the correct face.\n                axis.multiplyScalar(-1);\n            }\n            axis.normalize();\n            const vertex = getClosestVertex(b, a, axis);\n            contact = {\n                a: a,\n                b: b,\n                type: \"vertex-face\",\n                contactNormal: axis,\n                penetration: smallestOverlap,\n                contactPoint: vertex\n            };\n        }\n    }\n\n    const a_edges = getEdges(a);\n    const b_edges = getEdges(b);\n\n    for (let i = 0; i < a_edges.length; i++) {\n        for (let j = 0; j < b_edges.length; j++) {\n            const edge_i = a_edges[i].b.clone().sub(a_edges[i].a);\n            const edge_j = b_edges[j].b.clone().sub(b_edges[j].a);\n            let m = edge_i.clone().cross(edge_j);\n            if (m.length() !== 0) { // note to self: should use epsilon when checking for zero vector to improve stability\n                const overlap = separatingAxisPenetration(a, b, m);\n                \n                if (overlap < smallestOverlap) {\n                    smallestOverlap = overlap;\n\n                    // set contact\n                    const edge_i_points = getClosestEdge(b, a, edge_i, m);\n                    const edge_j_points = getClosestEdge(a, b, edge_j, m);\n                    m.normalize();\n                    contact = {\n                        a: a,\n                        b: b,\n                        type: \"edge-edge\",\n                        contactNormal: m,\n                        penetration: smallestOverlap,\n                        edge_a: edge_i_points,\n                        edge_b: edge_j_points\n                    };\n                }\n            } else {\n                const edge_n = b_edges[j].b.clone().sub(a_edges[i].a);\n                m = edge_i.clone().cross(edge_n);\n                if (m.length() !== 0) {\n                    const overlap = separatingAxisPenetration(a, b, m);\n\n                    if (overlap < smallestOverlap) {\n                        smallestOverlap = overlap;\n                    }\n                        \n                    // set contact\n                    const edge_i_points = getClosestEdge(b, a, edge_i, m);\n                    const edge_j_points = getClosestEdge(a, b, edge_j, m);\n                    m.normalize();\n                    contact = {\n                        a: a,\n                        b: b,\n                        type: \"edge-edge\",\n                        contactNormal: m,\n                        penetration: smallestOverlap,\n                        edge_a: edge_i_points,\n                        edge_b: edge_j_points\n                    };\n                } else {\n                    continue;\n                }\n            }\n        }\n    }\n    \n    return contact;\n}\n\nexport function resolveCollision(contactData: any) {\n    const a = contactData.a;\n    const b = contactData.b;\n    if (contactData.type === \"vertex-face\") {\n        const vertex = contactData.contactPoint;\n        const vertexVelocity_a = a.velocity.clone().add(a.getAngularVelocity.cross(vertex.clone().sub(a.position)));\n        const vertexVelocity_b = b.velocity.clone().add(b.getAngularVelocity.cross(vertex.clone().sub(b.position)));\n        const relativeVelocity = contactData.normal.dot(vertexVelocity_a.clone().sub(vertexVelocity_b));\n        if (relativeVelocity < 0) {\n            console.log(\"colliding contact\");\n        } else if (relativeVelocity === 0) {\n            console.log(\"resting contact\");\n        } else {\n            // ignore\n        }\n    } else if (contactData.type === \"edge-edge\") {\n\n    } else {\n        console.error(\"contactData type not recognized.\");\n    }\n}\n\n// returns closest edge of box b\n// edge should be parallel to input edgeVector\nfunction getClosestEdge(a: Box, b: Box, edgeVector: Vector3, separatingAxis: Vector3) {\n    const x = separatingAxis.x;\n    const y = separatingAxis.y;\n    const z = separatingAxis.z;\n    const projectionMatrix = new Matrix3();\n    projectionMatrix.set(\n        x*x, x*y, x*z,\n        x*y, y*y, y*z,\n        x*z, y*z, z*z\n    );\n\n    const a_center = a.position.clone().applyMatrix3(projectionMatrix);\n\n    const b_edges = getEdges(b);\n    const parallel_b_edges = [];\n    for (let b_edge of b_edges) {\n        const b_edgeVector = b_edge.b.clone().sub(b_edge.a);\n        if (b_edgeVector.clone().cross(edgeVector).length() === 0) {\n            parallel_b_edges.push(b_edge);\n        }\n    }\n\n    let closestEdge = parallel_b_edges[0];\n    let closestDistance = closestEdge.a.clone().sub(a_center).length();\n    for (let b_edge of parallel_b_edges) {\n        const d = b_edge.a.clone().sub(a_center).length();\n        if (d < closestDistance) {\n            closestDistance = d;\n            closestEdge = b_edge;\n        }\n    }\n\n    return closestEdge;\n}\n\n// returns closest vertex of box b to face of box a\nfunction getClosestVertex(a: Box, b: Box, lineVector: Vector3): Vector3 {\n    const b_vertices = getVertices(b);\n    let vertex = b_vertices[0];\n\n    const x = lineVector.x;\n    const y = lineVector.y;\n    const z = lineVector.z;\n    const projectionMatrix = new Matrix3();\n    projectionMatrix.set(\n        x*x, x*y, x*z,\n        x*y, y*y, y*z,\n        x*z, y*z, z*z\n    );\n\n    const a_center = a.position.clone().applyMatrix3(projectionMatrix);\n    const b_center = b.position.clone().applyMatrix3(projectionMatrix);\n    let smallestDistanceToA = b_center.clone().sub(a_center).length();\n\n    for (let b_v of b_vertices) {\n        const b_v_projection = b_v.applyMatrix3(projectionMatrix);\n        const d = b_v_projection.clone().sub(a_center).length()\n        if (d < smallestDistanceToA) {\n            smallestDistanceToA = d;\n            vertex = b_v;\n        }\n    }\n\n    return vertex;\n}\n\nfunction separatingAxisPenetration(a: Box, b: Box, lineVector: Vector3): number {\n    const x = lineVector.x;\n    const y = lineVector.y;\n    const z = lineVector.z;\n    const projectionMatrix = new Matrix3();\n    projectionMatrix.set(\n        x*x, x*y, x*z,\n        x*y, y*y, y*z,\n        x*z, y*z, z*z\n    );\n\n    const a_center = a.position.clone().applyMatrix3(projectionMatrix);\n    const b_center = b.position.clone().applyMatrix3(projectionMatrix);\n    const d = b_center.clone().sub(a_center).length();\n\n    const a_vertices = getVertices(a);\n    const b_vertices = getVertices(b);\n\n    let r_a = 0, r_b = 0;\n    for (let a_v of a_vertices) {\n        const a_v_projection = a_v.applyMatrix3(projectionMatrix);\n        const r = a_center.clone().sub(a_v_projection).length()\n        if (r > r_a) {\n            r_a = r;\n        }\n    }\n    for (let b_v of b_vertices) {\n        const b_v_projection = b_v.applyMatrix3(projectionMatrix);\n        const r = b_center.clone().sub(b_v_projection).length()\n        if (r > r_b) {\n            r_b = r;\n        }\n    }\n\n    // returns the overlap. positive indicates overlap, negative indicates separation.\n    return r_a + r_b - d;\n}\n\n/**\n * for symmetrical objects, valid separating axis iff sum the radii (half_widths) of the projected intervals is less than the distance between the centers\n * @param a \n * @param b \n * @param lineVector a unit vector describing the direction of the line\n * @returns true if the lineVector is a separating axis\n */\nexport function testSeparatingAxis(a: Box, b: Box, lineVector: Vector3): boolean {\n    const x = lineVector.x;\n    const y = lineVector.y;\n    const z = lineVector.z;\n    const projectionMatrix = new Matrix3();\n    projectionMatrix.set(\n        x*x, x*y, x*z,\n        x*y, y*y, y*z,\n        x*z, y*z, z*z\n    );\n\n    const a_center = a.position.clone().applyMatrix3(projectionMatrix);\n    const b_center = b.position.clone().applyMatrix3(projectionMatrix);\n    const d = b_center.clone().sub(a_center).length();\n\n    const a_vertices = getVertices(a);\n    const b_vertices = getVertices(b);\n    \n    let r_a = 0, r_b = 0;\n    for (let a_v of a_vertices) {\n        const a_v_projection = a_v.applyMatrix3(projectionMatrix);\n        const r = a_center.clone().sub(a_v_projection).length()\n        if (r > r_a) {\n            r_a = r;\n        }\n    }\n    for (let b_v of b_vertices) {\n        const b_v_projection = b_v.applyMatrix3(projectionMatrix);\n        const r = b_center.clone().sub(b_v_projection).length()\n        if (r > r_b) {\n            r_b = r;\n        }\n    }\n    if (r_a + r_b < d) {\n        return true;\n    }\n\n    return false;\n}\n\nfunction getVertices(box: Box) {\n    const x = box.position.x;\n    const y = box.position.y;\n    const z = box.position.z;\n    const v1 = new Vector3(x - box.width/2, y - box.length/2, z - box.height/2);\n    const v2 = new Vector3(x - box.width/2, y + box.length/2, z - box.height/2);\n    const v3 = new Vector3(x + box.width/2, y + box.length/2, z - box.height/2);\n    const v4 = new Vector3(x + box.width/2, y - box.length/2, z - box.height/2);\n    const v5 = new Vector3(x - box.width/2, y - box.length/2, z + box.height/2);\n    const v6 = new Vector3(x - box.width/2, y + box.length/2, z + box.height/2);\n    const v7 = new Vector3(x + box.width/2, y + box.length/2, z + box.height/2);\n    const v8 = new Vector3(x + box.width/2, y - box.length/2, z + box.height/2);\n    const vertices = [v1, v2, v3, v4, v5, v6, v7, v8];\n\n    // rotate vertices\n    for (let vertex of vertices) {\n        // convert to body space, apply rotation, convert back to world space\n        vertex.sub(box.position);\n        vertex.applyQuaternion(box.rotation);\n        vertex.add(box.position);\n    }\n\n    return vertices;\n}\n\nfunction getEdges(box: Box) {\n    const x = box.position.x;\n    const y = box.position.y;\n    const z = box.position.z;\n    const v1 = new Vector3(x - box.width/2, y - box.length/2, z - box.height/2);\n    const v2 = new Vector3(x - box.width/2, y + box.length/2, z - box.height/2);\n    const v3 = new Vector3(x + box.width/2, y + box.length/2, z - box.height/2);\n    const v4 = new Vector3(x + box.width/2, y - box.length/2, z - box.height/2);\n    const v5 = new Vector3(x - box.width/2, y - box.length/2, z + box.height/2);\n    const v6 = new Vector3(x - box.width/2, y + box.length/2, z + box.height/2);\n    const v7 = new Vector3(x + box.width/2, y + box.length/2, z + box.height/2);\n    const v8 = new Vector3(x + box.width/2, y - box.length/2, z + box.height/2);\n    const vertices = [v1, v2, v3, v4, v5, v6, v7, v8];\n\n    // rotate vertices\n    for (let vertex of vertices) {\n        // convert to body space, apply rotation, convert back to world space\n        vertex.sub(box.position);\n        vertex.applyQuaternion(box.rotation);\n        vertex.add(box.position);\n    }\n\n    const edges = [];\n    edges.push({a: v1, b: v2});\n    edges.push({a: v1, b: v4});\n    edges.push({a: v1, b: v5});\n    edges.push({a: v2, b: v3});\n    edges.push({a: v2, b: v6});\n    edges.push({a: v3, b: v4});\n    edges.push({a: v3, b: v7});\n    edges.push({a: v4, b: v8});\n    edges.push({a: v5, b: v6});\n    edges.push({a: v5, b: v8});\n    edges.push({a: v6, b: v7});\n    edges.push({a: v7, b: v8});\n\n    return edges;\n}\n\nfunction getFacePlanes(box: Box) {\n    const x = box.position.x;\n    const y = box.position.y;\n    const z = box.position.z;\n    const v1 = new Vector3(x - box.width/2, y - box.length/2, z - box.height/2);\n    const v2 = new Vector3(x - box.width/2, y + box.length/2, z - box.height/2);\n    const v3 = new Vector3(x + box.width/2, y + box.length/2, z - box.height/2);\n    const v4 = new Vector3(x + box.width/2, y - box.length/2, z - box.height/2);\n    const v5 = new Vector3(x - box.width/2, y - box.length/2, z + box.height/2);\n    const v6 = new Vector3(x - box.width/2, y + box.length/2, z + box.height/2);\n    const v7 = new Vector3(x + box.width/2, y + box.length/2, z + box.height/2);\n    const v8 = new Vector3(x + box.width/2, y - box.length/2, z + box.height/2);\n    const vertices = [v1, v2, v3, v4, v5, v6, v7, v8];\n\n    // rotate vertices\n    for (let vertex of vertices) {\n        // convert to body space, apply rotation, convert back to world space\n        vertex.sub(box.position);\n        vertex.applyQuaternion(box.rotation);\n        vertex.add(box.position);\n    }\n    const face1 = { normal: ((v2.clone().sub(v1)).cross(v4.clone().sub(v1))).normalize(), point: v1 } // bottom plane\n    const face2 = { normal: ((v8.clone().sub(v5)).cross(v6.clone().sub(v5))).normalize(), point: v5 } // top plane\n    const face3 = { normal: ((v5.clone().sub(v1)).cross(v2.clone().sub(v1))).normalize(), point: v1 } // left plane\n    const face4 = { normal: ((v3.clone().sub(v4)).cross(v8.clone().sub(v4))).normalize(), point: v4 } // top plane\n    const face5 = { normal: ((v4.clone().sub(v1)).cross(v5.clone().sub(v1))).normalize(), point: v1 } // front plane\n    const face6 = { normal: ((v2.clone().sub(v3)).cross(v7.clone().sub(v3))).normalize(), point: v3 } // back plane\n    const facePlanes = [face1, face2, face3, face4, face5, face6];\n    return facePlanes;\n}\n\n/*\nfunction getFaces(box: Box) {\n    const x = box.position.x;\n    const y = box.position.y;\n    const z = box.position.z;\n    const v1 = new Vector3(x - box.width/2, y - box.length/2, z - box.height/2);\n    const v2 = new Vector3(x - box.width/2, y + box.length/2, z - box.height/2);\n    const v3 = new Vector3(x + box.width/2, y + box.length/2, z - box.height/2);\n    const v4 = new Vector3(x + box.width/2, y - box.length/2, z - box.height/2);\n    const v5 = new Vector3(x - box.width/2, y - box.length/2, z + box.height/2);\n    const v6 = new Vector3(x - box.width/2, y + box.length/2, z + box.height/2);\n    const v7 = new Vector3(x + box.width/2, y + box.length/2, z + box.height/2);\n    const v8 = new Vector3(x + box.width/2, y - box.length/2, z + box.height/2);\n    const vertices = [v1, v2, v3, v4, v5, v6, v7, v8];\n\n    // rotate vertices\n    for (let vertex of vertices) {\n        // convert to body space, apply rotation, convert back to world space\n        vertex.sub(box.position);\n        vertex.applyQuaternion(box.rotation);\n        vertex.add(box.position);\n    }\n    \n    const f1 = { edges: [{a: v1, b: v2}, {a: v1, b: v4}, {a: v2, b: v3}, {a: v3, b: v4}] }; // bottom\n    const f2 = { edges: [{a: v5, b: v6}, {a: v5, b: v8}, {a: v6, b: v7}, {a: v7, b: v8}] }; // top\n    const f3 = { edges: [{a: v1, b: v2}, {a: v1, b: v5}, {a: v5, b: v6}, {a: v6, b: v2}] }; // left\n    const f4 = { edges: [{a: v4, b: v8}, {a: v4, b: v3}, {a: v8, b: v7}, {a: v7, b: v3}] }; // right\n    const f5 = { edges: [{a: v1, b: v4}, {a: v1, b: v5}, {a: v5, b: v8}, {a: v8, b: v4}] }; // front\n    const f6 = { edges: [{a: v2, b: v3}, {a: v2, b: v6}, {a: v6, b: v7}, {a: v7, b: v3}] }; // back\n    const faces = [f1, f2, f3, f4, f5, f6];\n    return faces;\n}*/\n\n/*\nexport function getAllBoundingBoxIntersections(boxes: Box[]) {\n    // create and sort intervals along x, y, and z\n    const x_intervals = [];\n    const y_intervals = [];\n    const z_intervals = [];\n    for(let box of boxes) {\n        const x_min = box.position.x - box.boundingBox.x/2;\n        const x_max = box.position.x + box.boundingBox.x/2;\n        x_intervals.push({ type: \"min\", value: x_min, object: box});\n        x_intervals.push({ type: \"max\", value: x_max, object: box});\n\n        \n        const y_min = box.position.y - box.boundingBox.y/2;\n        const y_max = box.position.y + box.boundingBox.y/2;\n        y_intervals.push({ type: \"min\", value: y_min, object: box});\n        y_intervals.push({ type: \"max\", value: y_max, object: box});\n\n        const z_min = box.position.z - box.boundingBox.z/2;\n        const z_max = box.position.z + box.boundingBox.z/2;\n        z_intervals.push({ type: \"min\", value: z_min, object: box});\n        z_intervals.push({ type: \"max\", value: z_max, object: box});\n    }\n    // note to self: switch to insertion sort and use normal merge sort only during the initialization frame\n    x_intervals.sort((a, b) => a.value - b.value);\n    //y_intervals.sort((a, b) => a.value - b.value);\n    //z_intervals.sort((a, b) => a.value - b.value);\n\n    // create a list of active intervals\n    const activeIntervals = [];\n}*/"],"mappings":"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"},"metadata":{},"sourceType":"module"}