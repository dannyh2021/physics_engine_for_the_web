{"ast":null,"code":"import _classCallCheck from\"/Users/danny/Github/physics_engine_for_the_web/frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";import _createClass from\"/Users/danny/Github/physics_engine_for_the_web/frontend/node_modules/@babel/runtime/helpers/esm/createClass.js\";import{Matrix3,Vector3}from\"three\";import*as THREE from\"three\";import{getQuaternionRotatingV1ToV2}from\"./math_library\";export var Plane=/*#__PURE__*/function(){// should be normalized\n// plane not implemented to actually move, this is just set to 0 to help the collision resolution\n// for graphics\nfunction Plane(position,normal,width,length){_classCallCheck(this,Plane);this.position=void 0;this.normal=void 0;this.inverseMass=void 0;this.velocity=void 0;this.width=void 0;this.length=void 0;this.boundingBox=void 0;this.mesh=void 0;this.boundingBoxMesh=void 0;this.position=position;this.normal=normal;this.inverseMass=0;this.velocity=new Vector3(0,0,0);this.width=width;this.length=length;var r=Math.sqrt(width*width+length*length);this.boundingBox=new Vector3(2*r,2*r,2*r);this.createMesh();this.createBoundingBoxMesh();}_createClass(Plane,[{key:\"createMesh\",value:function createMesh(){var planeGeometry=new THREE.PlaneGeometry(this.width,this.length);var material=new THREE.MeshPhongMaterial({color:0xffcb3e});this.mesh=new THREE.Mesh(planeGeometry,material);// set orientation based on normal\nvar rotation=getQuaternionRotatingV1ToV2(new Vector3(0,0,1),this.normal);this.mesh.setRotationFromQuaternion(rotation);this.mesh.position.set(this.position.x,this.position.y,this.position.z);}},{key:\"createBoundingBoxMesh\",value:function createBoundingBoxMesh(){var boxGeometry=new THREE.BoxGeometry(this.boundingBox.x,this.boundingBox.y,this.boundingBox.z);var wireframe=new THREE.WireframeGeometry(boxGeometry);this.boundingBoxMesh=new THREE.LineSegments(wireframe);this.boundingBoxMesh.material=new THREE.LineBasicMaterial({color:0xffffff});}// below are just functions written because they are called by the collision resolution step\n},{key:\"getAngularVelocity\",value:function getAngularVelocity(){var angularVelocity=new Vector3(0,0,0);return angularVelocity;}},{key:\"getInertia\",value:function getInertia(){// set to zero matrix, so that the inverse is also the zero matrix when called by collision resolution function\nvar m=new Matrix3();m.set(0,0,0,0,0,0,0,0,0);return m;}},{key:\"applyImpulse\",value:function applyImpulse(point,impulse){console.log(\"impulse magnitude: \",impulse.length());}}]);return Plane;}();","map":{"version":3,"names":["Matrix3","Vector3","THREE","getQuaternionRotatingV1ToV2","Plane","position","normal","width","length","inverseMass","velocity","boundingBox","mesh","boundingBoxMesh","r","Math","sqrt","createMesh","createBoundingBoxMesh","planeGeometry","PlaneGeometry","material","MeshPhongMaterial","color","Mesh","rotation","setRotationFromQuaternion","set","x","y","z","boxGeometry","BoxGeometry","wireframe","WireframeGeometry","LineSegments","LineBasicMaterial","angularVelocity","m","point","impulse","console","log"],"sources":["/Users/danny/Github/physics_engine_for_the_web/frontend/src/physics_engine/Plane.ts"],"sourcesContent":["import { LineSegments, Matrix3, Mesh, Quaternion, Vector3 } from \"three\";\nimport * as THREE from \"three\";\nimport { convertMatrix3ToMatrix4, getQuaternionRotatingV1ToV2, yRotationMatrix3 } from \"./math_library\";\n\nexport class Plane {\n    public position: Vector3;\n    public normal: Vector3; // should be normalized\n\n    public inverseMass: number;\n    public velocity: Vector3; // plane not implemented to actually move, this is just set to 0 to help the collision resolution\n\n    public width: number;\n    public length: number;\n\n    public boundingBox: Vector3;\n\n    // for graphics\n    public mesh: Mesh;\n    public boundingBoxMesh: LineSegments;\n\n    constructor(position: Vector3, normal: Vector3, width: number, length: number) {\n        this.position = position;\n        this.normal = normal;\n\n        this.inverseMass = 0;\n        this.velocity = new Vector3(0, 0, 0);\n\n        this.width = width;\n        this.length = length;\n\n        const r = Math.sqrt(width*width + length*length);\n        this.boundingBox = new Vector3(2*r, 2*r, 2*r);\n\n        this.createMesh();\n        this.createBoundingBoxMesh();\n    }\n\n    private createMesh(): void {\n        const planeGeometry = new THREE.PlaneGeometry(this.width, this.length);\n        const material = new THREE.MeshPhongMaterial({ color: 0xffcb3e });\n        this.mesh = new THREE.Mesh(planeGeometry, material);\n\n        // set orientation based on normal\n        const rotation = getQuaternionRotatingV1ToV2(new Vector3(0, 0, 1), this.normal);\n        this.mesh.setRotationFromQuaternion(rotation);\n\n        this.mesh.position.set(this.position.x, this.position.y, this.position.z);\n    }\n\n    private createBoundingBoxMesh(): void {\n        const boxGeometry = new THREE.BoxGeometry(this.boundingBox.x, this.boundingBox.y, this.boundingBox.z);\n        const wireframe = new THREE.WireframeGeometry(boxGeometry);\n        this.boundingBoxMesh = new THREE.LineSegments( wireframe );\n        this.boundingBoxMesh.material = new THREE.LineBasicMaterial({ color: 0xffffff });\n    }\n\n    // below are just functions written because they are called by the collision resolution step\n    getAngularVelocity(): Vector3 {\n        const angularVelocity = new Vector3(0, 0, 0);\n        return angularVelocity;\n    }\n\n    getInertia(): Matrix3 {\n        // set to zero matrix, so that the inverse is also the zero matrix when called by collision resolution function\n        const m = new Matrix3();\n        m.set(\n            0, 0, 0,\n            0, 0, 0,\n            0, 0, 0\n        );\n        return m;\n    }\n\n    applyImpulse(point: Vector3, impulse: Vector3) {\n        console.log(\"impulse magnitude: \", impulse.length());\n    }\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}