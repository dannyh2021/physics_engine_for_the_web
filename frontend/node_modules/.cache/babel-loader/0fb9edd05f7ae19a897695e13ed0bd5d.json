{"ast":null,"code":"import { Matrix3, Vector3 } from \"three\";\nimport * as THREE from \"three\";\nimport { getQuaternionRotatingV1ToV2 } from \"./math_library\";\nexport class Plane {\n  // should be normalized\n  // plane not implemented to actually move, this is just set to 0 to help the collision resolution\n  // for graphics\n  constructor(position, normal, width, length) {\n    this.position = void 0;\n    this.normal = void 0;\n    this.inversMass = void 0;\n    this.velocity = void 0;\n    this.width = void 0;\n    this.length = void 0;\n    this.boundingBox = void 0;\n    this.mesh = void 0;\n    this.boundingBoxMesh = void 0;\n    this.position = position;\n    this.normal = normal;\n    this.inversMass = 0;\n    this.velocity = new Vector3(0, 0, 0);\n    this.width = width;\n    this.length = length;\n    const r = Math.sqrt(width * width + length * length);\n    this.boundingBox = new Vector3(2 * r, 2 * r, 2 * r);\n    this.createMesh();\n    this.createBoundingBoxMesh();\n  }\n\n  createMesh() {\n    const planeGeometry = new THREE.PlaneGeometry(this.width, this.length);\n    const material = new THREE.MeshPhongMaterial({\n      color: 0xffcb3e\n    });\n    this.mesh = new THREE.Mesh(planeGeometry, material); // set orientation based on normal\n\n    const rotation = getQuaternionRotatingV1ToV2(new Vector3(0, 0, 1), this.normal);\n    this.mesh.setRotationFromQuaternion(rotation);\n    this.mesh.position.set(this.position.x, this.position.y, this.position.z);\n  }\n\n  createBoundingBoxMesh() {\n    const boxGeometry = new THREE.BoxGeometry(this.boundingBox.x, this.boundingBox.y, this.boundingBox.z);\n    const wireframe = new THREE.WireframeGeometry(boxGeometry);\n    this.boundingBoxMesh = new THREE.LineSegments(wireframe);\n    this.boundingBoxMesh.material = new THREE.LineBasicMaterial({\n      color: 0xffffff\n    });\n  } // below are just functions written because they are called by the collision resolution step\n\n\n  getAngularVelocity() {\n    const angularVelocity = new Vector3(0, 0, 0);\n    return angularVelocity;\n  }\n\n  getInertia() {\n    const m = new Matrix3();\n    return m;\n  }\n\n}","map":{"version":3,"names":["Matrix3","Vector3","THREE","getQuaternionRotatingV1ToV2","Plane","constructor","position","normal","width","length","inversMass","velocity","boundingBox","mesh","boundingBoxMesh","r","Math","sqrt","createMesh","createBoundingBoxMesh","planeGeometry","PlaneGeometry","material","MeshPhongMaterial","color","Mesh","rotation","setRotationFromQuaternion","set","x","y","z","boxGeometry","BoxGeometry","wireframe","WireframeGeometry","LineSegments","LineBasicMaterial","getAngularVelocity","angularVelocity","getInertia","m"],"sources":["/Users/danny/Github/physics_engine_for_the_web/frontend/src/physics_engine/Plane.ts"],"sourcesContent":["import { LineSegments, Matrix3, Mesh, Quaternion, Vector3 } from \"three\";\nimport * as THREE from \"three\";\nimport { convertMatrix3ToMatrix4, getQuaternionRotatingV1ToV2, yRotationMatrix3 } from \"./math_library\";\n\nexport class Plane {\n    public position: Vector3;\n    public normal: Vector3; // should be normalized\n\n    public inversMass: number;\n    public velocity: Vector3; // plane not implemented to actually move, this is just set to 0 to help the collision resolution\n\n    public width: number;\n    public length: number;\n\n    public boundingBox: Vector3;\n\n    // for graphics\n    public mesh: Mesh;\n    public boundingBoxMesh: LineSegments;\n\n    constructor(position: Vector3, normal: Vector3, width: number, length: number) {\n        this.position = position;\n        this.normal = normal;\n\n        this.inversMass = 0;\n        this.velocity = new Vector3(0, 0, 0);\n\n        this.width = width;\n        this.length = length;\n\n        const r = Math.sqrt(width*width + length*length);\n        this.boundingBox = new Vector3(2*r, 2*r, 2*r);\n\n        this.createMesh();\n        this.createBoundingBoxMesh();\n    }\n\n    private createMesh(): void {\n        const planeGeometry = new THREE.PlaneGeometry(this.width, this.length);\n        const material = new THREE.MeshPhongMaterial({ color: 0xffcb3e });\n        this.mesh = new THREE.Mesh(planeGeometry, material);\n\n        // set orientation based on normal\n        const rotation = getQuaternionRotatingV1ToV2(new Vector3(0, 0, 1), this.normal);\n        this.mesh.setRotationFromQuaternion(rotation);\n\n        this.mesh.position.set(this.position.x, this.position.y, this.position.z);\n    }\n\n    private createBoundingBoxMesh(): void {\n        const boxGeometry = new THREE.BoxGeometry(this.boundingBox.x, this.boundingBox.y, this.boundingBox.z);\n        const wireframe = new THREE.WireframeGeometry(boxGeometry);\n        this.boundingBoxMesh = new THREE.LineSegments( wireframe );\n        this.boundingBoxMesh.material = new THREE.LineBasicMaterial({ color: 0xffffff });\n    }\n\n    // below are just functions written because they are called by the collision resolution step\n    getAngularVelocity(): Vector3 {\n        const angularVelocity = new Vector3(0, 0, 0);\n        return angularVelocity;\n    }\n\n    getInertia(): Matrix3 {\n        const m = new Matrix3();\n        return m;\n    }\n}"],"mappings":"AAAA,SAAuBA,OAAvB,EAAkDC,OAAlD,QAAiE,OAAjE;AACA,OAAO,KAAKC,KAAZ,MAAuB,OAAvB;AACA,SAAkCC,2BAAlC,QAAuF,gBAAvF;AAEA,OAAO,MAAMC,KAAN,CAAY;EAES;EAGE;EAO1B;EAIAC,WAAW,CAACC,QAAD,EAAoBC,MAApB,EAAqCC,KAArC,EAAoDC,MAApD,EAAoE;IAAA,KAfxEH,QAewE;IAAA,KAdxEC,MAcwE;IAAA,KAZxEG,UAYwE;IAAA,KAXxEC,QAWwE;IAAA,KATxEH,KASwE;IAAA,KARxEC,MAQwE;IAAA,KANxEG,WAMwE;IAAA,KAHxEC,IAGwE;IAAA,KAFxEC,eAEwE;IAC3E,KAAKR,QAAL,GAAgBA,QAAhB;IACA,KAAKC,MAAL,GAAcA,MAAd;IAEA,KAAKG,UAAL,GAAkB,CAAlB;IACA,KAAKC,QAAL,GAAgB,IAAIV,OAAJ,CAAY,CAAZ,EAAe,CAAf,EAAkB,CAAlB,CAAhB;IAEA,KAAKO,KAAL,GAAaA,KAAb;IACA,KAAKC,MAAL,GAAcA,MAAd;IAEA,MAAMM,CAAC,GAAGC,IAAI,CAACC,IAAL,CAAUT,KAAK,GAACA,KAAN,GAAcC,MAAM,GAACA,MAA/B,CAAV;IACA,KAAKG,WAAL,GAAmB,IAAIX,OAAJ,CAAY,IAAEc,CAAd,EAAiB,IAAEA,CAAnB,EAAsB,IAAEA,CAAxB,CAAnB;IAEA,KAAKG,UAAL;IACA,KAAKC,qBAAL;EACH;;EAEOD,UAAU,GAAS;IACvB,MAAME,aAAa,GAAG,IAAIlB,KAAK,CAACmB,aAAV,CAAwB,KAAKb,KAA7B,EAAoC,KAAKC,MAAzC,CAAtB;IACA,MAAMa,QAAQ,GAAG,IAAIpB,KAAK,CAACqB,iBAAV,CAA4B;MAAEC,KAAK,EAAE;IAAT,CAA5B,CAAjB;IACA,KAAKX,IAAL,GAAY,IAAIX,KAAK,CAACuB,IAAV,CAAeL,aAAf,EAA8BE,QAA9B,CAAZ,CAHuB,CAKvB;;IACA,MAAMI,QAAQ,GAAGvB,2BAA2B,CAAC,IAAIF,OAAJ,CAAY,CAAZ,EAAe,CAAf,EAAkB,CAAlB,CAAD,EAAuB,KAAKM,MAA5B,CAA5C;IACA,KAAKM,IAAL,CAAUc,yBAAV,CAAoCD,QAApC;IAEA,KAAKb,IAAL,CAAUP,QAAV,CAAmBsB,GAAnB,CAAuB,KAAKtB,QAAL,CAAcuB,CAArC,EAAwC,KAAKvB,QAAL,CAAcwB,CAAtD,EAAyD,KAAKxB,QAAL,CAAcyB,CAAvE;EACH;;EAEOZ,qBAAqB,GAAS;IAClC,MAAMa,WAAW,GAAG,IAAI9B,KAAK,CAAC+B,WAAV,CAAsB,KAAKrB,WAAL,CAAiBiB,CAAvC,EAA0C,KAAKjB,WAAL,CAAiBkB,CAA3D,EAA8D,KAAKlB,WAAL,CAAiBmB,CAA/E,CAApB;IACA,MAAMG,SAAS,GAAG,IAAIhC,KAAK,CAACiC,iBAAV,CAA4BH,WAA5B,CAAlB;IACA,KAAKlB,eAAL,GAAuB,IAAIZ,KAAK,CAACkC,YAAV,CAAwBF,SAAxB,CAAvB;IACA,KAAKpB,eAAL,CAAqBQ,QAArB,GAAgC,IAAIpB,KAAK,CAACmC,iBAAV,CAA4B;MAAEb,KAAK,EAAE;IAAT,CAA5B,CAAhC;EACH,CAlDc,CAoDf;;;EACAc,kBAAkB,GAAY;IAC1B,MAAMC,eAAe,GAAG,IAAItC,OAAJ,CAAY,CAAZ,EAAe,CAAf,EAAkB,CAAlB,CAAxB;IACA,OAAOsC,eAAP;EACH;;EAEDC,UAAU,GAAY;IAClB,MAAMC,CAAC,GAAG,IAAIzC,OAAJ,EAAV;IACA,OAAOyC,CAAP;EACH;;AA7Dc"},"metadata":{},"sourceType":"module"}