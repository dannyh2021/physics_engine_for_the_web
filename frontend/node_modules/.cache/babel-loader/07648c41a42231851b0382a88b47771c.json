{"ast":null,"code":"import * as THREE from \"three\";\nimport { Matrix3, Vector3 } from \"three\";\nconst DAMPING = 0.999; // should add rotation at some point?\n\nexport class Sphere {\n  // holds the accumulated force to be applied to the next simulation iteration only.\n  // width, length, and height of bounding box\n  // for graphics\n  constructor(position, radius) {\n    this.inverseMass = void 0;\n    this.radius = void 0;\n    this.position = void 0;\n    this.velocity = void 0;\n    this.forceAccum = void 0;\n    this.boundingBox = void 0;\n    this.mesh = void 0;\n    this.boundingBoxMesh = void 0;\n    this.inverseMass = 1 / (4 / 3 * Math.PI * Math.pow(radius, 3));\n    this.radius = radius;\n    this.position = position;\n    this.velocity = new Vector3(0, 0, 0);\n    this.forceAccum = new Vector3(0, 0, 0);\n    this.boundingBox = new Vector3(2 * radius, 2 * radius, 2 * radius); // for graphics\n\n    this.createMesh();\n    this.updateMesh();\n    this.createBoundingBoxMesh();\n    this.updateBoundingBoxMesh();\n  }\n\n  getInertia() {\n    const term = 2 / 5 * (1 / this.inverseMass) * this.radius * this.radius;\n    const inertia = new Matrix3();\n    inertia.set(term, 0, 0, 0, term, 0, 0, 0, term);\n    return inertia;\n  }\n\n  getAngularVelocity() {\n    const angularVelocity = new Vector3(0, 0, 0);\n    return angularVelocity;\n  } // update velocity based on forceAccum and clear forceAccum\n\n\n  integrateForceAccum(duration) {\n    // Don't integrate if mass is infinite or duration <= 0.\n    if (this.inverseMass <= 0 || duration <= 0) {\n      return;\n    }\n\n    this.velocity.addScaledVector(this.forceAccum, duration * this.inverseMass);\n    this.clearAccumulator();\n  }\n\n  integrate(duration) {\n    // Don't integrate if mass is infinite or duration <= 0.\n    if (this.inverseMass <= 0 || duration <= 0) return; // update velocity based on force and then clear forces\n\n    this.velocity.addScaledVector(this.forceAccum, duration * this.inverseMass);\n    this.clearAccumulator(); // update the linear position.\n\n    this.position.addScaledVector(this.velocity, duration); // impose drag.\n    // this.velocity.multiplyScalar(Math.pow(DAMPING, duration));\n    // update the velocity from the acceleration.\n    // this.velocity.addScaledVector(this.acceleration, duration);\n  }\n\n  applyImpulse(point, impulse) {\n    this.velocity.add(impulse.clone().multiplyScalar(this.inverseMass));\n  } // Clears the forces applied to the particle.\n\n\n  clearAccumulator() {\n    this.forceAccum = new Vector3(0, 0, 0);\n  }\n\n  createMesh() {\n    const sphereGeometry = new THREE.SphereGeometry(this.radius);\n    const material = new THREE.MeshPhongMaterial({\n      color: 0x00bcd6\n    });\n    this.mesh = new THREE.Mesh(sphereGeometry, material);\n  } // updates mesh to current position and orientation\n\n\n  updateMesh() {\n    this.mesh.position.set(this.position.x, this.position.y, this.position.z);\n  }\n\n  createBoundingBoxMesh() {\n    const boxGeometry = new THREE.BoxGeometry(this.boundingBox.x, this.boundingBox.y, this.boundingBox.z);\n    const wireframe = new THREE.WireframeGeometry(boxGeometry);\n    this.boundingBoxMesh = new THREE.LineSegments(wireframe);\n    this.boundingBoxMesh.material = new THREE.LineBasicMaterial({\n      color: 0xffffff\n    });\n  }\n\n  updateBoundingBoxMesh() {\n    this.boundingBoxMesh.position.set(this.position.x, this.position.y, this.position.z);\n  }\n\n}","map":{"version":3,"names":["THREE","Matrix3","Vector3","DAMPING","Sphere","constructor","position","radius","inverseMass","velocity","forceAccum","boundingBox","mesh","boundingBoxMesh","Math","PI","pow","createMesh","updateMesh","createBoundingBoxMesh","updateBoundingBoxMesh","getInertia","term","inertia","set","getAngularVelocity","angularVelocity","integrateForceAccum","duration","addScaledVector","clearAccumulator","integrate","applyImpulse","point","impulse","add","clone","multiplyScalar","sphereGeometry","SphereGeometry","material","MeshPhongMaterial","color","Mesh","x","y","z","boxGeometry","BoxGeometry","wireframe","WireframeGeometry","LineSegments","LineBasicMaterial"],"sources":["/Users/danny/Github/physics_engine_for_the_web/frontend/src/physics_engine/Sphere.ts"],"sourcesContent":["import * as THREE from \"three\";\nimport { LineSegments, Matrix3, Mesh, Vector3 } from \"three\";\n\nconst DAMPING = 0.999;\n\n// should add rotation at some point?\nexport class Sphere {\n    public inverseMass: number;\n\n    public radius: number;\n    \n    public position: Vector3;\n    public velocity: Vector3;\n\n    // holds the accumulated force to be applied to the next simulation iteration only.\n    public forceAccum: Vector3;\n\n    public boundingBox: Vector3; // width, length, and height of bounding box\n\n    // for graphics\n    public mesh: Mesh;\n    public boundingBoxMesh: LineSegments;\n\n    constructor(position: Vector3, radius: number) {\n        this.inverseMass = 1 / (4/3*Math.PI*Math.pow(radius, 3));\n        this.radius = radius;\n\n        this.position = position;\n        this.velocity = new Vector3(0, 0, 0);\n\n        this.forceAccum = new Vector3(0, 0, 0);\n\n        this.boundingBox = new Vector3(2*radius, 2*radius, 2*radius);\n\n        // for graphics\n        this.createMesh();\n        this.updateMesh();\n        this.createBoundingBoxMesh();\n        this.updateBoundingBoxMesh();\n    }\n\n    getInertia(): Matrix3 {\n        const term = 2/5 * (1/this.inverseMass) * this.radius * this.radius;\n        const inertia = new Matrix3;\n        inertia.set(\n            term, 0, 0,\n            0, term, 0,\n            0, 0, term\n        );\n        return inertia;\n    }\n\n    getAngularVelocity(): Vector3 {\n        const angularVelocity = new Vector3(0, 0, 0);\n        return angularVelocity;\n    }\n\n    // update velocity based on forceAccum and clear forceAccum\n    integrateForceAccum(duration: number): void {\n        // Don't integrate if mass is infinite or duration <= 0.\n        if (this.inverseMass <= 0 || duration <= 0) {\n            return;\n        }\n\n        this.velocity.addScaledVector(this.forceAccum, duration*this.inverseMass);\n        this.clearAccumulator();\n    }\n\n    integrate(duration: number): void {\n        // Don't integrate if mass is infinite or duration <= 0.\n        if (this.inverseMass <= 0 || duration <= 0)\n            return;\n\n        // update velocity based on force and then clear forces\n        this.velocity.addScaledVector(this.forceAccum, duration*this.inverseMass);\n        this.clearAccumulator();\n\n        // update the linear position.\n        this.position.addScaledVector(this.velocity, duration);\n\n        // impose drag.\n        // this.velocity.multiplyScalar(Math.pow(DAMPING, duration));\n\n        // update the velocity from the acceleration.\n        // this.velocity.addScaledVector(this.acceleration, duration);\n    }\n\n    applyImpulse(point: Vector3, impulse: Vector3) {\n        this.velocity.add(impulse.clone().multiplyScalar(this.inverseMass));\n    }\n\n    // Clears the forces applied to the particle.\n    clearAccumulator(): void {\n        this.forceAccum = new Vector3(0, 0, 0);\n    }\n\n    private createMesh(): void {\n        const sphereGeometry = new THREE.SphereGeometry(this.radius);\n        const material = new THREE.MeshPhongMaterial({ color: 0x00bcd6 });\n        this.mesh = new THREE.Mesh(sphereGeometry, material);\n    }\n\n    // updates mesh to current position and orientation\n    updateMesh(): void {\n        this.mesh.position.set(this.position.x, this.position.y, this.position.z);\n    }\n\n    private createBoundingBoxMesh(): void {\n        const boxGeometry = new THREE.BoxGeometry(this.boundingBox.x, this.boundingBox.y, this.boundingBox.z);\n        const wireframe = new THREE.WireframeGeometry(boxGeometry);\n        this.boundingBoxMesh = new THREE.LineSegments( wireframe );\n        this.boundingBoxMesh.material = new THREE.LineBasicMaterial({ color: 0xffffff });\n    }\n\n    updateBoundingBoxMesh(): void {\n        this.boundingBoxMesh.position.set(this.position.x, this.position.y, this.position.z);\n    }\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}