{"ast":null,"code":"import { Vector3 } from \"three\";\nexport class Sphere {\n  // holds the accumulated force to be applied to the next simulation iteration only.\n  constructor(position, radius) {\n    this.position = void 0;\n    this.velocity = void 0;\n    this.acceleration = void 0;\n    this.forceAccum = void 0;\n    this.radius = void 0;\n    this.inverseMass = void 0;\n    this.position = position;\n    this.velocity = new Vector3(0, 0, -1);\n    this.acceleration = new Vector3(0, 0, 0);\n    this.forceAccum = new Vector3(0, 0, 0);\n    this.radius = radius;\n    this.inverseMass = 1;\n  }\n\n  integrate(duration) {\n    // Don't integrate if mass is infinite or duration <= 0.\n    if (this.inverseMass <= 0 || duration <= 0) return; // Work out the acceleration from the force.\n\n    this.acceleration = this.forceAccum.multiplyScalar(this.inverseMass); // update the linear position.\n\n    this.position.addScaledVector(this.velocity, duration);\n  } // Clears the forces applied to the particle.\n\n\n  clearAccumulator() {\n    this.forceAccum = new Vector3(0, 0, 0);\n  }\n\n  getPosition() {\n    return this.position.clone();\n  }\n\n}","map":{"version":3,"names":["Vector3","Sphere","constructor","position","radius","velocity","acceleration","forceAccum","inverseMass","integrate","duration","multiplyScalar","addScaledVector","clearAccumulator","getPosition","clone"],"sources":["/Users/danny/Github/physics_engine_for_the_web/frontend/src/physics_engine/Sphere.ts"],"sourcesContent":["import * as THREE from \"three\";\nimport { Vector3 } from \"three\";\n\nexport class Sphere {\n    public position: Vector3;\n    public velocity: Vector3;\n    public acceleration: Vector3;\n\n    // holds the accumulated force to be applied to the next simulation iteration only.\n    public forceAccum: Vector3;\n\n    public radius: number;\n    public inverseMass: number;\n\n    constructor(position: Vector3, radius: number) {\n        this.position = position;\n        this.velocity = new Vector3(0, 0, -1);\n        this.acceleration = new Vector3(0, 0, 0);\n\n        this.forceAccum = new Vector3(0, 0, 0);\n\n        this.radius = radius;\n        this.inverseMass = 1;\n    }\n\n    integrate(duration: number): void {\n        // Don't integrate if mass is infinite or duration <= 0.\n        if (this.inverseMass <= 0 || duration <= 0)\n            return;\n\n        // Work out the acceleration from the force.\n        this.acceleration = this.forceAccum.multiplyScalar(this.inverseMass);\n\n        // update the linear position.\n        this.position.addScaledVector(this.velocity, duration);\n    }\n\n    // Clears the forces applied to the particle.\n    clearAccumulator(): void {\n        this.forceAccum = new Vector3(0, 0, 0);\n    }\n\n    getPosition(): Vector3 {\n        return this.position.clone();\n    }\n}"],"mappings":"AACA,SAASA,OAAT,QAAwB,OAAxB;AAEA,OAAO,MAAMC,MAAN,CAAa;EAKhB;EAMAC,WAAW,CAACC,QAAD,EAAoBC,MAApB,EAAoC;IAAA,KAVxCD,QAUwC;IAAA,KATxCE,QASwC;IAAA,KARxCC,YAQwC;IAAA,KALxCC,UAKwC;IAAA,KAHxCH,MAGwC;IAAA,KAFxCI,WAEwC;IAC3C,KAAKL,QAAL,GAAgBA,QAAhB;IACA,KAAKE,QAAL,GAAgB,IAAIL,OAAJ,CAAY,CAAZ,EAAe,CAAf,EAAkB,CAAC,CAAnB,CAAhB;IACA,KAAKM,YAAL,GAAoB,IAAIN,OAAJ,CAAY,CAAZ,EAAe,CAAf,EAAkB,CAAlB,CAApB;IAEA,KAAKO,UAAL,GAAkB,IAAIP,OAAJ,CAAY,CAAZ,EAAe,CAAf,EAAkB,CAAlB,CAAlB;IAEA,KAAKI,MAAL,GAAcA,MAAd;IACA,KAAKI,WAAL,GAAmB,CAAnB;EACH;;EAEDC,SAAS,CAACC,QAAD,EAAyB;IAC9B;IACA,IAAI,KAAKF,WAAL,IAAoB,CAApB,IAAyBE,QAAQ,IAAI,CAAzC,EACI,OAH0B,CAK9B;;IACA,KAAKJ,YAAL,GAAoB,KAAKC,UAAL,CAAgBI,cAAhB,CAA+B,KAAKH,WAApC,CAApB,CAN8B,CAQ9B;;IACA,KAAKL,QAAL,CAAcS,eAAd,CAA8B,KAAKP,QAAnC,EAA6CK,QAA7C;EACH,CAhCe,CAkChB;;;EACAG,gBAAgB,GAAS;IACrB,KAAKN,UAAL,GAAkB,IAAIP,OAAJ,CAAY,CAAZ,EAAe,CAAf,EAAkB,CAAlB,CAAlB;EACH;;EAEDc,WAAW,GAAY;IACnB,OAAO,KAAKX,QAAL,CAAcY,KAAd,EAAP;EACH;;AAzCe"},"metadata":{},"sourceType":"module"}