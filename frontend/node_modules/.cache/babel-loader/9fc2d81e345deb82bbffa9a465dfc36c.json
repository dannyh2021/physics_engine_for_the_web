{"ast":null,"code":"import _createForOfIteratorHelper from\"/Users/danny/Github/physics_engine_for_the_web/frontend/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";import _toConsumableArray from\"/Users/danny/Github/physics_engine_for_the_web/frontend/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";import _classCallCheck from\"/Users/danny/Github/physics_engine_for_the_web/frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";import _createClass from\"/Users/danny/Github/physics_engine_for_the_web/frontend/node_modules/@babel/runtime/helpers/esm/createClass.js\";import{Matrix3,Vector3}from\"three\";import{Sphere}from\"./Sphere\";import{Box}from\"./Box\";import{Plane}from\"./Plane\";export{Sphere}from\"./Sphere\";export{Box}from\"./Box\";export{Plane}from\"./Plane\";export var World=/*#__PURE__*/function(){// 0 is fully inelastic, 1 is fully elastic\n// time step in seconds\nfunction World(){_classCallCheck(this,World);this.objects=void 0;this.coefficient_of_restitution=0.8;this.dt=1/60;this.objects=[];}_createClass(World,[{key:\"addObject\",value:function addObject(obj){this.objects.push(obj);}},{key:\"getAllBoundingBoxIntersections\",value:function getAllBoundingBoxIntersections(){// for now just sort against x-axis. Slightly better is to update axis based on one with highest variance\n// worst case is still O(n^2)\nfunction compareBoundingBoxes(a,b){var a_min=a.position.x-a.boundingBox.x/2;var b_min=b.position.x-b.boundingBox.x/2;return a_min-b_min;}// sort objects along x-axis\nvar objectsCopy=_toConsumableArray(this.objects);objectsCopy.sort(compareBoundingBoxes);// sweep the array for collisions\nvar intersections=[];for(var i=0;i<objectsCopy.length-1;i++){// test against all possible overlapping boxes following the current one.\nfor(var j=i+1;j<objectsCopy.length;j++){// stop testing when AABBs are beyond the current AABB\nvar i_max=objectsCopy[i].position.x+objectsCopy[i].boundingBox.x/2;var j_min=objectsCopy[j].position.x-objectsCopy[j].boundingBox.x/2;if(j_min>i_max){break;}if(checkBoundingBoxIntersection(objectsCopy[i],objectsCopy[j])){intersections.push({a:objectsCopy[i],b:objectsCopy[j]});}}}return intersections;}// applies the forceAccum, detects and resolves collisions, and finally updates the positions of all objects.\n},{key:\"tick\",value:function tick(duration){var _iterator=_createForOfIteratorHelper(this.objects),_step;try{for(_iterator.s();!(_step=_iterator.n()).done;){var object=_step.value;if(object instanceof Plane){continue;}object.integrateForceAccum(duration);}}catch(err){_iterator.e(err);}finally{_iterator.f();}var boundingBoxIntersections=this.getAllBoundingBoxIntersections();var contacts=getAllContacts(boundingBoxIntersections);var _iterator2=_createForOfIteratorHelper(contacts),_step2;try{for(_iterator2.s();!(_step2=_iterator2.n()).done;){var contact=_step2.value;this.resolveCollision(contact);}}catch(err){_iterator2.e(err);}finally{_iterator2.f();}var _iterator3=_createForOfIteratorHelper(this.objects),_step3;try{for(_iterator3.s();!(_step3=_iterator3.n()).done;){var _object=_step3.value;if(_object instanceof Plane){continue;}_object.integrate(duration);}}catch(err){_iterator3.e(err);}finally{_iterator3.f();}}// integrates the forceAccum to update the velocity of each object\n},{key:\"integrateForceAccumObjects\",value:function integrateForceAccumObjects(duration){var _iterator4=_createForOfIteratorHelper(this.objects),_step4;try{for(_iterator4.s();!(_step4=_iterator4.n()).done;){var object=_step4.value;if(object instanceof Plane){continue;}object.integrateForceAccum(duration);}}catch(err){_iterator4.e(err);}finally{_iterator4.f();}}// integrates the velocities to update the position of each object\n},{key:\"integrateObjects\",value:function integrateObjects(duration){var _iterator5=_createForOfIteratorHelper(this.objects),_step5;try{for(_iterator5.s();!(_step5=_iterator5.n()).done;){var object=_step5.value;if(object instanceof Plane){continue;}object.integrate(duration);}}catch(err){_iterator5.e(err);}finally{_iterator5.f();}}},{key:\"resolveCollision\",value:function resolveCollision(contactData){var a=contactData.a;var b=contactData.b;var normal=contactData.contactNormal;if(contactData.type===\"vertex-face\"){console.log(\"resolving vertex-face contact\");var vertex=contactData.contactPoint;var r_a=vertex.clone().sub(a.position);var r_b=vertex.clone().sub(b.position);var vertexVelocity_a=a.velocity.clone().add(a.getAngularVelocity().cross(r_a));var vertexVelocity_b=b.velocity.clone().add(b.getAngularVelocity().cross(r_b));var relativeVelocity=normal.dot(vertexVelocity_a.clone().sub(vertexVelocity_b));if(relativeVelocity<0){console.log(\"colliding contact\");var I_inverse_a=a.getInertia().invert();var I_inverse_b=b.getInertia().invert();var term1=normal.dot(r_a.clone().cross(normal).applyMatrix3(I_inverse_a).cross(r_a));var term2=normal.dot(r_b.clone().cross(normal).applyMatrix3(I_inverse_b).cross(r_b));var j=-(1+coefficient_of_restitution)*relativeVelocity/(a.inverseMass+b.inverseMass+term1+term2);console.log(\"relative Velocity: \",relativeVelocity);var impulse=normal.clone().multiplyScalar(j);var impulse2=normal.clone().multiplyScalar(-j);a.applyImpulse(vertex,impulse);b.applyImpulse(vertex,impulse2);}else if(relativeVelocity===0){console.log(\"resting contact\");}else{// ignore\nconsole.log(\"leaving\");}}else if(contactData.type===\"edge-edge\"){console.log(\"resolving edge-edge contact\");console.log(\"edge_a\",contactData.edge_a);console.log(\"edge_b\",contactData.edge_b);console.log(\"contactNormal: \",contactData.contactNormal);var _vertex=getClosestPointBetweenTwoEdges(contactData.edge_a,contactData.edge_b);var _r_a=_vertex.clone().sub(a.position);var _r_b=_vertex.clone().sub(b.position);var _vertexVelocity_a=a.velocity.clone().add(a.getAngularVelocity().cross(_r_a));var _vertexVelocity_b=b.velocity.clone().add(b.getAngularVelocity().cross(_r_b));var _relativeVelocity=normal.dot(_vertexVelocity_a.clone().sub(_vertexVelocity_b));if(_relativeVelocity<0){console.log(\"colliding contact\");var _I_inverse_a=a.getInertia().invert();var _I_inverse_b=b.getInertia().invert();var _term=normal.dot(_r_a.clone().cross(normal).applyMatrix3(_I_inverse_a).cross(_r_a));var _term2=normal.dot(_r_b.clone().cross(normal).applyMatrix3(_I_inverse_b).cross(_r_b));var _j=-(1+coefficient_of_restitution)*_relativeVelocity/(a.inverseMass+b.inverseMass+_term+_term2);var _impulse=normal.clone().multiplyScalar(_j);var _impulse2=normal.clone().multiplyScalar(-_j);a.applyImpulse(_vertex,_impulse);b.applyImpulse(_vertex,_impulse2);}else if(_relativeVelocity===0){console.log(\"resting contact\");}else{// ignore\nconsole.log(\"leaving\");}}else{console.error(\"contactData type not recognized.\");console.log(\"contact data: \",contactData);}}},{key:\"updateMeshes\",value:function updateMeshes(){var _iterator6=_createForOfIteratorHelper(this.objects),_step6;try{for(_iterator6.s();!(_step6=_iterator6.n()).done;){var object=_step6.value;if(object instanceof Plane){continue;}object.updateMesh();object.updateBoundingBoxMesh();}}catch(err){_iterator6.e(err);}finally{_iterator6.f();}}}]);return World;}();/**\n * checks if the bounding box of two objects intersect\n * @param a the first object\n * @param b the other object\n */export function checkBoundingBoxIntersection(a,b){// create intervals\nvar a_x_min=a.position.x-a.boundingBox.x/2;var a_x_max=a.position.x+a.boundingBox.x/2;var a_y_min=a.position.y-a.boundingBox.y/2;var a_y_max=a.position.y+a.boundingBox.y/2;var a_z_min=a.position.z-a.boundingBox.z/2;var a_z_max=a.position.z+a.boundingBox.z/2;var b_x_min=b.position.x-b.boundingBox.x/2;var b_x_max=b.position.x+b.boundingBox.x/2;var b_y_min=b.position.y-b.boundingBox.y/2;var b_y_max=b.position.y+b.boundingBox.y/2;var b_z_min=b.position.z-b.boundingBox.z/2;var b_z_max=b.position.z+b.boundingBox.z/2;// intersecting if all intervals are intersecting\nif(a_x_min<b_x_max&&b_x_min<a_x_max&&a_y_min<b_y_max&&b_y_min<a_y_max&&a_z_min<b_z_max&&b_z_min<a_z_max){return true;}return false;}// returns true if the two objects are intersecting\nexport function checkCollision(a,b){if(a instanceof Box&&b instanceof Box){return checkCollisionBoxes(a,b);}else if(a instanceof Box&&b instanceof Sphere){return checkCollisionBoxAndSphere(a,b);}else if(a instanceof Box&&b instanceof Plane){return checkCollisionBoxAndPlane(a,b);}else if(a instanceof Sphere&&b instanceof Box){return checkCollisionBoxAndSphere(b,a);}else if(a instanceof Sphere&&b instanceof Sphere){return checkCollisionSpheres(a,b);}else if(a instanceof Sphere&&b instanceof Plane){return checkCollisionSphereAndPlane(a,b);}else if(a instanceof Plane&&b instanceof Box){return checkCollisionBoxAndPlane(b,a);}else if(a instanceof Plane&&b instanceof Sphere){return checkCollisionSphereAndPlane(b,a);}else{console.error(\"checking collision between these types not implemented.\");}}export function checkCollisionBoxes(a,b){// two convex objects don't collide iff there exists a separating plane between them\n// search for separating plane.\n// either its contain a face of one polyhedra or it contains an edge of one polyhedra and is parallel to the edge of the other polyhedra.\nvar a_coordinateAxes=getCoordinateAxes(a);var b_coordinateAxes=getCoordinateAxes(b);// check the 6 face axes\nvar _iterator7=_createForOfIteratorHelper(a_coordinateAxes),_step7;try{for(_iterator7.s();!(_step7=_iterator7.n()).done;){var faceAxis=_step7.value;if(separatingAxisPenetration(a,b,faceAxis)<0){return false;}}}catch(err){_iterator7.e(err);}finally{_iterator7.f();}var _iterator8=_createForOfIteratorHelper(b_coordinateAxes),_step8;try{for(_iterator8.s();!(_step8=_iterator8.n()).done;){var _faceAxis=_step8.value;if(separatingAxisPenetration(a,b,_faceAxis)<0){return false;}}// check the 9 edge-edge axes\n}catch(err){_iterator8.e(err);}finally{_iterator8.f();}var _iterator9=_createForOfIteratorHelper(a_coordinateAxes),_step9;try{for(_iterator9.s();!(_step9=_iterator9.n()).done;){var a_axis=_step9.value;var _iterator10=_createForOfIteratorHelper(b_coordinateAxes),_step10;try{for(_iterator10.s();!(_step10=_iterator10.n()).done;){var b_axis=_step10.value;var m=a_axis.clone().cross(b_axis).normalize();if(m.length()>0){// note to self: should use epsilon when checking for zero vector to  improve stability\nif(separatingAxisPenetration(a,b,m)<0){return false;}}else{// for now, ignore case where the corresponding edges are parallel.\ncontinue;}}}catch(err){_iterator10.e(err);}finally{_iterator10.f();}}}catch(err){_iterator9.e(err);}finally{_iterator9.f();}return true;}export function checkCollisionSpheres(a,b){// two spheres intersect if the distance between their centers is not greater than the sum of their radii\nvar d=a.position.clone().sub(b.position).length();return d<=a.radius+b.radius;}export function checkCollisionSphereAndPlane(sphere,plane){var relativePosition=sphere.position.clone().sub(plane.position);var d=relativePosition.dot(plane.normal);// distance to center of sphere, negative if center is below plane.\nreturn d<=sphere.radius;}export function checkCollisionBoxAndSphere(box,sphere){// convert sphere center to box coordinate space\nvar inverseRotation=box.rotation.clone();var sphereCenter=sphere.position.clone().sub(box.position).applyQuaternion(inverseRotation);// Clamp each coordinate to the box.\nvar closestPoint=sphereCenter.clone();closestPoint.x=Math.max(Math.min(closestPoint.x,box.width/2),-box.width/2);closestPoint.y=Math.max(Math.min(closestPoint.y,box.length/2),-box.length/2);closestPoint.z=Math.max(Math.min(closestPoint.z,box.height/2),-box.height/2);// check if they're in contact\nvar distance=sphereCenter.clone().sub(closestPoint).length();return distance<sphere.radius;}export function checkCollisionBoxAndPlane(box,plane){var vertices=getVertices(box);var _iterator11=_createForOfIteratorHelper(vertices),_step11;try{for(_iterator11.s();!(_step11=_iterator11.n()).done;){var v=_step11.value;var relative_position=v.clone().sub(plane.position);var d=relative_position.dot(plane.normal);if(d<0){return true;}}}catch(err){_iterator11.e(err);}finally{_iterator11.f();}return false;}export function getAllContacts(boundingBoxIntersections){var contacts=[];for(var i=0;i<boundingBoxIntersections.length;i++){var a=boundingBoxIntersections[i].a;var b=boundingBoxIntersections[i].b;// check for collisions and color them\nif(checkCollision(a,b)){var contact=getContactData(a,b);contacts.push(contact);}}return contacts;}export function getContactData(a,b){if(a instanceof Box&&b instanceof Box){return getContactDataBoxes(a,b);}else if(a instanceof Box&&b instanceof Sphere){return getContactDataBoxAndSphere(a,b);}else if(a instanceof Box&&b instanceof Plane){return getContactDataBoxAndPlane(a,b);}else if(a instanceof Sphere&&b instanceof Box){return getContactDataBoxAndSphere(b,a);}else if(a instanceof Sphere&&b instanceof Sphere){return getContactDataSpheres(a,b);}else if(a instanceof Sphere&&b instanceof Plane){return getContactDataSphereAndPlane(a,b);}else if(a instanceof Plane&&b instanceof Box){return getContactDataBoxAndPlane(b,a);}else if(a instanceof Plane&&b instanceof Sphere){return getContactDataSphereAndPlane(b,a);}else{console.error(\"getting contact data between these types not implemented.\");return{a:a,b:b,type:\"none\",contactNormal:new Vector3(0,0,1),penetration:0,contactPoint:new Vector3(0,0,0),edge_a:{a:new Vector3(0,0,0),b:new Vector3(0,0,0)},edge_b:{a:new Vector3(0,0,0),b:new Vector3(0,0,0)}};}}// note: all getContact functions assume the objects already intersect.\n// convention: contact data is of format {a, b, type, contactNormal, penetration, contactPoint, ...} where contactNormal points from b to a\n// get contact data for two colliding boxes, assuming collision\nfunction getContactDataBoxes(a,b){var vector_ab=b.position.clone().sub(a.position);var a_coordinateAxes=getCoordinateAxes(a);var b_coordinateAxes=getCoordinateAxes(b);var smallestOverlap=Infinity;var contact;var _iterator12=_createForOfIteratorHelper(a_coordinateAxes),_step12;try{for(_iterator12.s();!(_step12=_iterator12.n()).done;){var a_axis=_step12.value;var overlap=separatingAxisPenetration(a,b,a_axis);if(overlap<smallestOverlap){smallestOverlap=overlap;// set contact\nvar axis=a_axis.clone();if(vector_ab.dot(axis)<0){// orient axis to normal of the correct face.\naxis.multiplyScalar(-1);}axis.normalize();var vertex=getClosestVertex(a,b,axis);contact={a:b,b:a,type:\"vertex-face\",contactNormal:axis,penetration:smallestOverlap,contactPoint:vertex,edge_a:{a:new Vector3(0,0,0),b:new Vector3(0,0,0)},edge_b:{a:new Vector3(0,0,0),b:new Vector3(0,0,0)}};}}}catch(err){_iterator12.e(err);}finally{_iterator12.f();}var _iterator13=_createForOfIteratorHelper(b_coordinateAxes),_step13;try{for(_iterator13.s();!(_step13=_iterator13.n()).done;){var b_axis=_step13.value;var _overlap=separatingAxisPenetration(a,b,b_axis);if(_overlap<smallestOverlap){smallestOverlap=_overlap;// set contact\nvar _axis=b_axis.clone();if(vector_ab.clone().dot(_axis)>0){// orient axis to normal of the correct face.\n_axis.multiplyScalar(-1);}_axis.normalize();var _vertex2=getClosestVertex(b,a,_axis);contact={a:a,b:b,type:\"vertex-face\",contactNormal:_axis,penetration:smallestOverlap,contactPoint:_vertex2,edge_a:{a:new Vector3(0,0,0),b:new Vector3(0,0,0)},edge_b:{a:new Vector3(0,0,0),b:new Vector3(0,0,0)}};}}}catch(err){_iterator13.e(err);}finally{_iterator13.f();}var _iterator14=_createForOfIteratorHelper(a_coordinateAxes),_step14;try{for(_iterator14.s();!(_step14=_iterator14.n()).done;){var _a_axis=_step14.value;var _iterator15=_createForOfIteratorHelper(b_coordinateAxes),_step15;try{for(_iterator15.s();!(_step15=_iterator15.n()).done;){var _b_axis=_step15.value;var m=_a_axis.clone().cross(_b_axis).normalize();if(m.length()>0.005){// check parallel edges\nvar _overlap2=separatingAxisPenetration(a,b,m);if(_overlap2<smallestOverlap){smallestOverlap=_overlap2;// set contact\nvar _axis2=m.clone();if(vector_ab.clone().dot(_axis2)>0){_axis2.multiplyScalar(-1);}_axis2.normalize();var edge_a=getClosestEdge(b,a,_a_axis,m);var edge_b=getClosestEdge(a,b,_b_axis,m);contact={a:a,b:b,type:\"edge-edge\",contactNormal:_axis2,penetration:smallestOverlap,contactPoint:getClosestPointBetweenTwoEdges(edge_a,edge_b),edge_a:edge_a,edge_b:edge_b};}}else{// for now, ignore case where the corresponding edges are parallel.\ncontinue;}}}catch(err){_iterator15.e(err);}finally{_iterator15.f();}}}catch(err){_iterator14.e(err);}finally{_iterator14.f();}return contact;}function getContactDataBoxAndSphere(box,sphere){// convert sphere center to box coordinate space\nvar inverseRotation=box.rotation.clone();var sphereCenter=sphere.position.clone().sub(box.position).applyQuaternion(inverseRotation);// Clamp each coordinate to the box.\nvar closestPoint=sphereCenter.clone();closestPoint.x=Math.max(Math.min(closestPoint.x,box.width/2),-box.width/2);closestPoint.y=Math.max(Math.min(closestPoint.y,box.length/2),-box.length/2);closestPoint.z=Math.max(Math.min(closestPoint.z,box.height/2),-box.height/2);var distance=sphereCenter.clone().sub(closestPoint).length();var penetration=sphere.radius-distance;// convert back to world space\nclosestPoint.applyQuaternion(box.rotation).add(box.position);var contactPoint=closestPoint;var contactNormal=closestPoint.clone().sub(sphere.position.clone()).normalize();var contact={a:box,b:sphere,type:\"vertex-face\",contactNormal:contactNormal,penetration:penetration,contactPoint:contactPoint,edge_a:{a:new Vector3(0,0,0),b:new Vector3(0,0,0)},edge_b:{a:new Vector3(0,0,0),b:new Vector3(0,0,0)}};return contact;}function getContactDataSpheres(a,b){var v_ab=b.position.clone().sub(a.position);var contactPoint=a.position.clone().add(v_ab.clone().multiplyScalar(a.radius).sub(v_ab.clone().multiplyScalar(b.radius)).multiplyScalar(0.5));var penetration=a.radius-b.radius-v_ab.length();var contactNormal=v_ab.clone().multiplyScalar(-1).normalize();var contact={a:a,b:b,type:\"vertex-face\",contactNormal:contactNormal,penetration:penetration,contactPoint:contactPoint,edge_a:{a:new Vector3(0,0,0),b:new Vector3(0,0,0)},edge_b:{a:new Vector3(0,0,0),b:new Vector3(0,0,0)}};return contact;}function getContactDataBoxAndPlane(box,plane){var vertices=getVertices(box);var contactPoint=vertices[0];var penetration=0;var _iterator16=_createForOfIteratorHelper(vertices),_step16;try{for(_iterator16.s();!(_step16=_iterator16.n()).done;){var v=_step16.value;var relative_position=v.clone().sub(plane.position);var d=relative_position.dot(plane.normal);if(d<penetration){contactPoint=v;penetration=d;}}}catch(err){_iterator16.e(err);}finally{_iterator16.f();}var contact={a:box,b:plane,type:\"vertex-face\",contactNormal:plane.normal.clone(),penetration:penetration,contactPoint:contactPoint,edge_a:{a:new Vector3(0,0,0),b:new Vector3(0,0,0)},edge_b:{a:new Vector3(0,0,0),b:new Vector3(0,0,0)}};return contact;}function getContactDataSphereAndPlane(sphere,plane){var relativePosition=sphere.position.clone().sub(plane.position);var d=relativePosition.dot(plane.normal);// distance to center of sphere, negative if center is below plane.\nvar penetration=sphere.radius-d;var contactPoint=sphere.position.clone().addScaledVector(plane.normal,-sphere.radius);var contact={a:sphere,b:plane,type:\"vertex-face\",contactNormal:plane.normal.clone(),penetration:penetration,contactPoint:contactPoint,edge_a:{a:new Vector3(0,0,0),b:new Vector3(0,0,0)},edge_b:{a:new Vector3(0,0,0),b:new Vector3(0,0,0)}};return contact;}var coefficient_of_restitution=0.8;export function resolveCollision(contactData){var a=contactData.a;var b=contactData.b;var normal=contactData.contactNormal;if(contactData.type===\"vertex-face\"){console.log(\"resolving vertex-face contact\");var vertex=contactData.contactPoint;var r_a=vertex.clone().sub(a.position);var r_b=vertex.clone().sub(b.position);var vertexVelocity_a=a.velocity.clone().add(a.getAngularVelocity().cross(r_a));var vertexVelocity_b=b.velocity.clone().add(b.getAngularVelocity().cross(r_b));var relativeVelocity=normal.dot(vertexVelocity_a.clone().sub(vertexVelocity_b));if(relativeVelocity<0){console.log(\"colliding contact\");var I_inverse_a=a.getInertia().invert();var I_inverse_b=b.getInertia().invert();var term1=normal.dot(r_a.clone().cross(normal).applyMatrix3(I_inverse_a).cross(r_a));var term2=normal.dot(r_b.clone().cross(normal).applyMatrix3(I_inverse_b).cross(r_b));var j=-(1+coefficient_of_restitution)*relativeVelocity/(a.inverseMass+b.inverseMass+term1+term2);console.log(\"relative Velocity: \",relativeVelocity);var impulse=normal.clone().multiplyScalar(j);var impulse2=normal.clone().multiplyScalar(-j);a.applyImpulse(vertex,impulse);b.applyImpulse(vertex,impulse2);}else if(relativeVelocity===0){console.log(\"resting contact\");}else{// ignore\nconsole.log(\"leaving\");}}else if(contactData.type===\"edge-edge\"){console.log(\"resolving edge-edge contact\");console.log(\"edge_a\",contactData.edge_a);console.log(\"edge_b\",contactData.edge_b);console.log(\"contactNormal: \",contactData.contactNormal);var _vertex3=getClosestPointBetweenTwoEdges(contactData.edge_a,contactData.edge_b);var _r_a2=_vertex3.clone().sub(a.position);var _r_b2=_vertex3.clone().sub(b.position);var _vertexVelocity_a2=a.velocity.clone().add(a.getAngularVelocity().cross(_r_a2));var _vertexVelocity_b2=b.velocity.clone().add(b.getAngularVelocity().cross(_r_b2));var _relativeVelocity2=normal.dot(_vertexVelocity_a2.clone().sub(_vertexVelocity_b2));if(_relativeVelocity2<0){console.log(\"colliding contact\");var _I_inverse_a2=a.getInertia().invert();var _I_inverse_b2=b.getInertia().invert();var _term3=normal.dot(_r_a2.clone().cross(normal).applyMatrix3(_I_inverse_a2).cross(_r_a2));var _term4=normal.dot(_r_b2.clone().cross(normal).applyMatrix3(_I_inverse_b2).cross(_r_b2));var _j2=-(1+coefficient_of_restitution)*_relativeVelocity2/(a.inverseMass+b.inverseMass+_term3+_term4);var _impulse3=normal.clone().multiplyScalar(_j2);var _impulse4=normal.clone().multiplyScalar(-_j2);a.applyImpulse(_vertex3,_impulse3);b.applyImpulse(_vertex3,_impulse4);}else if(_relativeVelocity2===0){console.log(\"resting contact\");}else{// ignore\nconsole.log(\"leaving\");}}else{console.error(\"contactData type not recognized.\");console.log(\"contact data: \",contactData);}}// returns closest edge of box b\n// edge should be parallel to input edgeVector\nfunction getClosestEdge(a,b,edgeVector,separatingAxis){var x=separatingAxis.x;var y=separatingAxis.y;var z=separatingAxis.z;var projectionMatrix=new Matrix3();projectionMatrix.set(x*x,x*y,x*z,x*y,y*y,y*z,x*z,y*z,z*z);var a_center=a.position.clone().applyMatrix3(projectionMatrix);var b_edges=getEdges(b);var parallel_b_edges=[];var _iterator17=_createForOfIteratorHelper(b_edges),_step17;try{for(_iterator17.s();!(_step17=_iterator17.n()).done;){var _b_edge=_step17.value;var b_edgeVector=_b_edge.b.clone().sub(_b_edge.a);if(b_edgeVector.clone().cross(edgeVector).length()<0.005){parallel_b_edges.push(_b_edge);}}}catch(err){_iterator17.e(err);}finally{_iterator17.f();}var closestEdge=parallel_b_edges[0];var closestDistance=closestEdge.a.clone().sub(a_center).length();for(var _i=0,_parallel_b_edges=parallel_b_edges;_i<_parallel_b_edges.length;_i++){var b_edge=_parallel_b_edges[_i];var d=b_edge.a.clone().sub(a_center).length();if(d<closestDistance){closestDistance=d;closestEdge=b_edge;}}return closestEdge;}// returns closest vertex of box b to face of box a\nfunction getClosestVertex(a,b,lineVector){var a_vertices=getVertices(a);var b_vertices=getVertices(b);var x=lineVector.x;var y=lineVector.y;var z=lineVector.z;var projectionMatrix=new Matrix3();projectionMatrix.set(x*x,x*y,x*z,x*y,y*y,y*z,x*z,y*z,z*z);var a_center=a.position.clone().applyMatrix3(projectionMatrix);var a_radius=0;var _iterator18=_createForOfIteratorHelper(a_vertices),_step18;try{for(_iterator18.s();!(_step18=_iterator18.n()).done;){var a_v=_step18.value;var a_v_projection=a_v.clone().applyMatrix3(projectionMatrix);var r=a_v_projection.clone().sub(a_center).length();if(r>a_radius){a_radius=r;}}}catch(err){_iterator18.e(err);}finally{_iterator18.f();}var b_center=b.position.clone().applyMatrix3(projectionMatrix);var vertex=b_vertices[0];var smallestDistanceToA=b_center.clone().sub(a_center).length()-a_radius;var _iterator19=_createForOfIteratorHelper(b_vertices),_step19;try{for(_iterator19.s();!(_step19=_iterator19.n()).done;){var b_v=_step19.value;var b_v_projection=b_v.clone().applyMatrix3(projectionMatrix);var d=b_v_projection.clone().sub(a_center).length()-a_radius;if(d<smallestDistanceToA){smallestDistanceToA=d;vertex=b_v;}}}catch(err){_iterator19.e(err);}finally{_iterator19.f();}return vertex;}function separatingAxisPenetration(a,b,lineVector){var x=lineVector.x;var y=lineVector.y;var z=lineVector.z;var projectionMatrix=new Matrix3();projectionMatrix.set(x*x,x*y,x*z,x*y,y*y,y*z,x*z,y*z,z*z);var a_center=a.position.clone().applyMatrix3(projectionMatrix);var b_center=b.position.clone().applyMatrix3(projectionMatrix);var d=b_center.clone().sub(a_center).length();var a_vertices=getVertices(a);var b_vertices=getVertices(b);var r_a=0,r_b=0;var _iterator20=_createForOfIteratorHelper(a_vertices),_step20;try{for(_iterator20.s();!(_step20=_iterator20.n()).done;){var a_v=_step20.value;var a_v_projection=a_v.applyMatrix3(projectionMatrix);var r=a_center.clone().sub(a_v_projection).length();if(r>r_a){r_a=r;}}}catch(err){_iterator20.e(err);}finally{_iterator20.f();}var _iterator21=_createForOfIteratorHelper(b_vertices),_step21;try{for(_iterator21.s();!(_step21=_iterator21.n()).done;){var b_v=_step21.value;var b_v_projection=b_v.applyMatrix3(projectionMatrix);var _r=b_center.clone().sub(b_v_projection).length();if(_r>r_b){r_b=_r;}}// returns the overlap. positive indicates overlap, negative indicates separation.\n}catch(err){_iterator21.e(err);}finally{_iterator21.f();}return r_a+r_b-d;}function getClosestPointBetweenTwoEdges(e1,e2){var p1=e1.a;var p2=e1.b;var p3=e2.a;var p4=e2.b;var v12=p2.clone().sub(p1);var v34=p4.clone().sub(p3);var v13=p3.clone().sub(p1);var s,t;// terms\nvar R_1_squared=v12.dot(v12);var R_2_squared=v34.dot(v34);var D_4321=v12.dot(v34);var D_3121=v12.dot(v13);var D_4331=v13.dot(v34);var denominator=D_4321*D_4321-R_1_squared*R_2_squared;s=(D_4321*D_4331-R_2_squared*D_3121)/denominator;t=(R_1_squared*D_4331-D_4321*D_3121)/denominator;s=Math.max(Math.min(s,1),0);t=Math.max(Math.min(t,1),0);var point_a=e1.a.clone().add(v12.clone().multiplyScalar(s));var point_b=e2.a.clone().add(v34.clone().multiplyScalar(t));return point_a.clone().add(point_b).multiplyScalar(1/2);}function getCoordinateAxes(box){var x=new Vector3(1,0,0),y=new Vector3(0,1,0),z=new Vector3(0,0,1);var axes=[x,y,z];for(var _i2=0,_axes=axes;_i2<_axes.length;_i2++){var axis=_axes[_i2];axis.applyQuaternion(box.rotation);}return axes;}function getVertices(box){var x=box.position.x;var y=box.position.y;var z=box.position.z;var v1=new Vector3(x-box.width/2,y-box.length/2,z-box.height/2);var v2=new Vector3(x-box.width/2,y+box.length/2,z-box.height/2);var v3=new Vector3(x+box.width/2,y+box.length/2,z-box.height/2);var v4=new Vector3(x+box.width/2,y-box.length/2,z-box.height/2);var v5=new Vector3(x-box.width/2,y-box.length/2,z+box.height/2);var v6=new Vector3(x-box.width/2,y+box.length/2,z+box.height/2);var v7=new Vector3(x+box.width/2,y+box.length/2,z+box.height/2);var v8=new Vector3(x+box.width/2,y-box.length/2,z+box.height/2);var vertices=[v1,v2,v3,v4,v5,v6,v7,v8];// rotate vertices\nfor(var _i3=0,_vertices=vertices;_i3<_vertices.length;_i3++){var vertex=_vertices[_i3];// convert to body space, apply rotation, convert back to world space\nvertex.sub(box.position);vertex.applyQuaternion(box.rotation);vertex.add(box.position);}return vertices;}function getEdges(box){var x=box.position.x;var y=box.position.y;var z=box.position.z;var v1=new Vector3(x-box.width/2,y-box.length/2,z-box.height/2);var v2=new Vector3(x-box.width/2,y+box.length/2,z-box.height/2);var v3=new Vector3(x+box.width/2,y+box.length/2,z-box.height/2);var v4=new Vector3(x+box.width/2,y-box.length/2,z-box.height/2);var v5=new Vector3(x-box.width/2,y-box.length/2,z+box.height/2);var v6=new Vector3(x-box.width/2,y+box.length/2,z+box.height/2);var v7=new Vector3(x+box.width/2,y+box.length/2,z+box.height/2);var v8=new Vector3(x+box.width/2,y-box.length/2,z+box.height/2);var vertices=[v1,v2,v3,v4,v5,v6,v7,v8];// rotate vertices\nfor(var _i4=0,_vertices2=vertices;_i4<_vertices2.length;_i4++){var vertex=_vertices2[_i4];// convert to body space, apply rotation, convert back to world space\nvertex.sub(box.position);vertex.applyQuaternion(box.rotation);vertex.add(box.position);}var edges=[];edges.push({a:v1,b:v2});edges.push({a:v1,b:v4});edges.push({a:v1,b:v5});edges.push({a:v2,b:v3});edges.push({a:v2,b:v6});edges.push({a:v3,b:v4});edges.push({a:v3,b:v7});edges.push({a:v4,b:v8});edges.push({a:v5,b:v6});edges.push({a:v5,b:v8});edges.push({a:v6,b:v7});edges.push({a:v7,b:v8});return edges;}export function getAllBoundingBoxIntersections(objects){// for now just sort against x-axis. Slightly better is to update axis based on one with highest variance\n// worst case is still O(n^2)\nfunction compareBoundingBoxes(a,b){var a_min=a.position.x-a.boundingBox.x/2;var b_min=b.position.x-b.boundingBox.x/2;return a_min-b_min;}// sort objects along x-axis\nvar objectsCopy=_toConsumableArray(objects);objectsCopy.sort(compareBoundingBoxes);// sweep the array for collisions\nvar intersections=[];for(var i=0;i<objectsCopy.length-1;i++){// test against all possible overlapping boxes following the current one.\nfor(var j=i+1;j<objectsCopy.length;j++){// stop testing when AABBs are beyond the current AABB\nvar i_max=objectsCopy[i].position.x+objectsCopy[i].boundingBox.x/2;var j_min=objectsCopy[j].position.x-objectsCopy[j].boundingBox.x/2;if(j_min>i_max){break;}if(checkBoundingBoxIntersection(objectsCopy[i],objectsCopy[j])){intersections.push({a:objectsCopy[i],b:objectsCopy[j]});}}}return intersections;}/**\n * for symmetrical objects, valid separating axis iff sum the radii (half_widths) of the projected intervals is less than the distance between the centers\n * @param a \n * @param b \n * @param lineVector a unit vector describing the direction of the line\n * @returns true if the lineVector is a separating axis\n */ /*export function testSeparatingAxis(a: Box, b: Box, lineVector: Vector3): boolean {\n    const x = lineVector.x;\n    const y = lineVector.y;\n    const z = lineVector.z;\n    const projectionMatrix = new Matrix3();\n    projectionMatrix.set(\n        x*x, x*y, x*z,\n        x*y, y*y, y*z,\n        x*z, y*z, z*z\n    );\n\n    const a_center = a.position.clone().applyMatrix3(projectionMatrix);\n    const b_center = b.position.clone().applyMatrix3(projectionMatrix);\n    const d = b_center.clone().sub(a_center).length();\n\n    const a_vertices = getVertices(a);\n    const b_vertices = getVertices(b);\n    \n    let r_a = 0, r_b = 0;\n    for (let a_v of a_vertices) {\n        const a_v_projection = a_v.applyMatrix3(projectionMatrix);\n        const r = a_center.clone().sub(a_v_projection).length()\n        if (r > r_a) {\n            r_a = r;\n        }\n    }\n    for (let b_v of b_vertices) {\n        const b_v_projection = b_v.applyMatrix3(projectionMatrix);\n        const r = b_center.clone().sub(b_v_projection).length()\n        if (r > r_b) {\n            r_b = r;\n        }\n    }\n    if (r_a + r_b < d) {\n        return true;\n    }\n\n    return false;\n}*/ /*\nexport function checkCollisionBoxes(a: Box, b: Box): boolean {\n    // two convex objects don't collide iff there exists a separating plane between them\n\n    // search for separating plane.\n    // either its contain a face of one polyhedra or it contains an edge of one polyhedra and is parallel to the edge of the other polyhedra.\n    \n    const a_facePlanes = getFacePlanes(a);\n    for (let facePlane of a_facePlanes) {\n        if (testSeparatingAxis(a, b, facePlane.normal)) {\n            return false;\n        };\n    }\n    const b_facePlanes = getFacePlanes(b);\n    for (let facePlane of b_facePlanes) {\n        if (testSeparatingAxis(a, b, facePlane.normal)) {\n            return false;\n        }\n    }\n\n    const a_edges = getEdges(a);\n    const b_edges = getEdges(b);\n\n    for (let i = 0; i < a_edges.length; i++) {\n        for (let j = 0; j < b_edges.length; j++) {\n            const edge_i = a_edges[i].b.clone().sub(a_edges[i].a);\n            const edge_j = b_edges[j].b.clone().sub(b_edges[j].a);\n            let m = edge_i.clone().cross(edge_j);\n            if (m.length() !== 0) { // note to self: should use epsilon when checking for zero vector to improve stability\n                if (testSeparatingAxis(a, b, m)) {\n                    return false;\n                }\n            } else {\n                const edge_n = b_edges[j].b.clone().sub(a_edges[i].a);\n                m = edge_i.clone().cross(edge_n);\n                if (m.length() !== 0) {\n                    testSeparatingAxis(a, b, m);\n                } else {\n                    return true; // since edge_i and edge_2 are colinear\n                }\n            }\n        }\n    }\n\n    return true;\n}*/ /*\nfunction getFaces(box: Box) {\n    const x = box.position.x;\n    const y = box.position.y;\n    const z = box.position.z;\n    const v1 = new Vector3(x - box.width/2, y - box.length/2, z - box.height/2);\n    const v2 = new Vector3(x - box.width/2, y + box.length/2, z - box.height/2);\n    const v3 = new Vector3(x + box.width/2, y + box.length/2, z - box.height/2);\n    const v4 = new Vector3(x + box.width/2, y - box.length/2, z - box.height/2);\n    const v5 = new Vector3(x - box.width/2, y - box.length/2, z + box.height/2);\n    const v6 = new Vector3(x - box.width/2, y + box.length/2, z + box.height/2);\n    const v7 = new Vector3(x + box.width/2, y + box.length/2, z + box.height/2);\n    const v8 = new Vector3(x + box.width/2, y - box.length/2, z + box.height/2);\n    const vertices = [v1, v2, v3, v4, v5, v6, v7, v8];\n\n    // rotate vertices\n    for (let vertex of vertices) {\n        // convert to body space, apply rotation, convert back to world space\n        vertex.sub(box.position);\n        vertex.applyQuaternion(box.rotation);\n        vertex.add(box.position);\n    }\n    \n    const f1 = { edges: [{a: v1, b: v2}, {a: v1, b: v4}, {a: v2, b: v3}, {a: v3, b: v4}] }; // bottom\n    const f2 = { edges: [{a: v5, b: v6}, {a: v5, b: v8}, {a: v6, b: v7}, {a: v7, b: v8}] }; // top\n    const f3 = { edges: [{a: v1, b: v2}, {a: v1, b: v5}, {a: v5, b: v6}, {a: v6, b: v2}] }; // left\n    const f4 = { edges: [{a: v4, b: v8}, {a: v4, b: v3}, {a: v8, b: v7}, {a: v7, b: v3}] }; // right\n    const f5 = { edges: [{a: v1, b: v4}, {a: v1, b: v5}, {a: v5, b: v8}, {a: v8, b: v4}] }; // front\n    const f6 = { edges: [{a: v2, b: v3}, {a: v2, b: v6}, {a: v6, b: v7}, {a: v7, b: v3}] }; // back\n    const faces = [f1, f2, f3, f4, f5, f6];\n    return faces;\n}*/ /*\nexport function getAllBoundingBoxIntersections(boxes: Box[]) {\n    // create and sort intervals along x, y, and z\n    const x_intervals = [];\n    const y_intervals = [];\n    const z_intervals = [];\n    for(let box of boxes) {\n        const x_min = box.position.x - box.boundingBox.x/2;\n        const x_max = box.position.x + box.boundingBox.x/2;\n        x_intervals.push({ type: \"min\", value: x_min, object: box});\n        x_intervals.push({ type: \"max\", value: x_max, object: box});\n\n        \n        const y_min = box.position.y - box.boundingBox.y/2;\n        const y_max = box.position.y + box.boundingBox.y/2;\n        y_intervals.push({ type: \"min\", value: y_min, object: box});\n        y_intervals.push({ type: \"max\", value: y_max, object: box});\n\n        const z_min = box.position.z - box.boundingBox.z/2;\n        const z_max = box.position.z + box.boundingBox.z/2;\n        z_intervals.push({ type: \"min\", value: z_min, object: box});\n        z_intervals.push({ type: \"max\", value: z_max, object: box});\n    }\n    // note to self: switch to insertion sort and use normal merge sort only during the initialization frame\n    x_intervals.sort((a, b) => a.value - b.value);\n    //y_intervals.sort((a, b) => a.value - b.value);\n    //z_intervals.sort((a, b) => a.value - b.value);\n\n    // create a list of active intervals\n    const activeIntervals = [];\n}*/ /*\nexport class World2 {\n    private objects: any[] = [];\n    private currentLoopInterval: any = null;\n\n    private characterForce: Vector3;\n\n    constructor() {\n        this.objects = [];\n\n        this.characterForce = new Vector3(0, 0, 0);\n    }\n\n    startLoop(): void {\n        const currentInstance = this;\n\n        // stop current loop if it exits\n        this.stopCurrentLoop();\n\n        let lastTimeCalled = performance.now();\n        let fps = 0;\n        let times: any[] = [];\n\n        function step() {\n            // calculate fps\n            const now = performance.now();\n            while (times.length > 0 && times[0] <= now - 1000) {\n                times.shift();\n            }\n            times.push(now);\n            fps = times.length;\n            // console.log(\"fps: \", fps);\n\n            for (let i = 0; i < currentInstance.objects.length; i++) {\n                currentInstance.objects[i].integrate(dt);\n            }\n        }\n\n        this.currentLoopInterval = setInterval(step, dt * 1000);\n    }\n\n    // Stops current loop if it exists.\n    stopCurrentLoop(): void {\n        if (this.currentLoopInterval) {\n            clearInterval(this.currentLoopInterval);\n        }\n    }\n\n    addObject(obj: any): void {\n        this.objects.push(obj);\n    }\n\n    getObjects(): any[] {\n        return this.objects;\n    }\n\n    updateCharacterForce(f: Vector3) {\n        this.characterForce = f;\n    }\n\n    detectCollisions(): void {\n\n    }\n\n    checkCollisionSpheres(s1: Sphere, s2: Sphere) {\n        const d = (s1.position.clone().sub(s2.position)).length(); // distance between centers\n\n        // collision if distance between spheres is smaller than sub of radiuses\n        if (d < (s1.radius + s2.radius)) {\n            return true;\n        }\n        return false;\n    }\n\n    resolveCollisionSpheres(s1: Sphere, s2: Sphere) {\n        // find unit vectors from s1 to s2 and s2 to s1\n        const u12 = (s2.position.clone().sub(s1.position)).normalize();\n        const u21 = u12.clone().multiplyScalar(-1);\n\n        // find components of v1 and v2 along and perpendicular to u\n        const v1_along_u12 = u12.clone().multiplyScalar(u12.dot(s1.velocity));\n        const v2_along_u21 = u21.clone().multiplyScalar(u21.dot(s2.velocity));\n\n        const v1_perp_u12 = s1.velocity.clone().sub(v1_along_u12);\n        const v2_perp_u21 = s2.velocity.clone().sub(v2_along_u21);\n\n        // calculate new velocities along u, assuming elastic collision\n        const m1 = 1/s1.inverseMass;\n        const m2 = 1/s2.inverseMass;\n        const v1_along_u_new = (v1_along_u12.clone().multiplyScalar((m1-m2)/(m1+m2))).addScaledVector(v2_along_u21, (2*m2)/(m1+m2));\n        const v2_along_u_new = (v1_along_u12.clone().multiplyScalar((2*m1)/(m1+m2))).addScaledVector(v2_along_u21, -(m1-m2)/(m1+m2));\n\n        // calculate and set new velocities\n        const v1_new = v1_along_u_new.clone().add(v1_perp_u12);\n        const v2_new = v2_along_u_new.clone().add(v2_perp_u21);\n\n        console.log(\"u: \", u12);\n        console.log(\"v1_new: \", v1_new);\n        console.log(\"v2_new\", v2_new);\n    }\n\n    clearCurrentLoop(): void {\n        clearInterval(this.currentLoopInterval);\n    }\n}*/ /*\nfunction getFacePlanes(box: Box) {\n    const x = box.position.x;\n    const y = box.position.y;\n    const z = box.position.z;\n    const v1 = new Vector3(x - box.width/2, y - box.length/2, z - box.height/2);\n    const v2 = new Vector3(x - box.width/2, y + box.length/2, z - box.height/2);\n    const v3 = new Vector3(x + box.width/2, y + box.length/2, z - box.height/2);\n    const v4 = new Vector3(x + box.width/2, y - box.length/2, z - box.height/2);\n    const v5 = new Vector3(x - box.width/2, y - box.length/2, z + box.height/2);\n    const v6 = new Vector3(x - box.width/2, y + box.length/2, z + box.height/2);\n    const v7 = new Vector3(x + box.width/2, y + box.length/2, z + box.height/2);\n    const v8 = new Vector3(x + box.width/2, y - box.length/2, z + box.height/2);\n    const vertices = [v1, v2, v3, v4, v5, v6, v7, v8];\n\n    // rotate vertices\n    for (let vertex of vertices) {\n        // convert to body space, apply rotation, convert back to world space\n        vertex.sub(box.position);\n        vertex.applyQuaternion(box.rotation);\n        vertex.add(box.position);\n    }\n    const face1 = { normal: ((v2.clone().sub(v1)).cross(v4.clone().sub(v1))).normalize(), point: v1 } // bottom plane\n    const face2 = { normal: ((v8.clone().sub(v5)).cross(v6.clone().sub(v5))).normalize(), point: v5 } // top plane\n    const face3 = { normal: ((v5.clone().sub(v1)).cross(v2.clone().sub(v1))).normalize(), point: v1 } // left plane\n    const face4 = { normal: ((v3.clone().sub(v4)).cross(v8.clone().sub(v4))).normalize(), point: v4 } // top plane\n    const face5 = { normal: ((v4.clone().sub(v1)).cross(v5.clone().sub(v1))).normalize(), point: v1 } // front plane\n    const face6 = { normal: ((v2.clone().sub(v3)).cross(v7.clone().sub(v3))).normalize(), point: v3 } // back plane\n    const facePlanes = [face1, face2, face3, face4, face5, face6];\n    return facePlanes;\n}*/","map":{"version":3,"names":["Matrix3","Vector3","Sphere","Box","Plane","World","objects","coefficient_of_restitution","dt","obj","push","compareBoundingBoxes","a","b","a_min","position","x","boundingBox","b_min","objectsCopy","sort","intersections","i","length","j","i_max","j_min","checkBoundingBoxIntersection","duration","object","integrateForceAccum","boundingBoxIntersections","getAllBoundingBoxIntersections","contacts","getAllContacts","contact","resolveCollision","integrate","contactData","normal","contactNormal","type","console","log","vertex","contactPoint","r_a","clone","sub","r_b","vertexVelocity_a","velocity","add","getAngularVelocity","cross","vertexVelocity_b","relativeVelocity","dot","I_inverse_a","getInertia","invert","I_inverse_b","term1","applyMatrix3","term2","inverseMass","impulse","multiplyScalar","impulse2","applyImpulse","edge_a","edge_b","getClosestPointBetweenTwoEdges","error","updateMesh","updateBoundingBoxMesh","a_x_min","a_x_max","a_y_min","y","a_y_max","a_z_min","z","a_z_max","b_x_min","b_x_max","b_y_min","b_y_max","b_z_min","b_z_max","checkCollision","checkCollisionBoxes","checkCollisionBoxAndSphere","checkCollisionBoxAndPlane","checkCollisionSpheres","checkCollisionSphereAndPlane","a_coordinateAxes","getCoordinateAxes","b_coordinateAxes","faceAxis","separatingAxisPenetration","a_axis","b_axis","m","normalize","d","radius","sphere","plane","relativePosition","box","inverseRotation","rotation","sphereCenter","applyQuaternion","closestPoint","Math","max","min","width","height","distance","vertices","getVertices","v","relative_position","getContactData","getContactDataBoxes","getContactDataBoxAndSphere","getContactDataBoxAndPlane","getContactDataSpheres","getContactDataSphereAndPlane","penetration","vector_ab","smallestOverlap","Infinity","overlap","axis","getClosestVertex","getClosestEdge","v_ab","addScaledVector","edgeVector","separatingAxis","projectionMatrix","set","a_center","b_edges","getEdges","parallel_b_edges","b_edge","b_edgeVector","closestEdge","closestDistance","lineVector","a_vertices","b_vertices","a_radius","a_v","a_v_projection","r","b_center","smallestDistanceToA","b_v","b_v_projection","e1","e2","p1","p2","p3","p4","v12","v34","v13","s","t","R_1_squared","R_2_squared","D_4321","D_3121","D_4331","denominator","point_a","point_b","axes","v1","v2","v3","v4","v5","v6","v7","v8","edges"],"sources":["/Users/danny/Github/physics_engine_for_the_web/frontend/src/physics_engine/physics_engine.ts"],"sourcesContent":["import { Matrix3, Vector3 } from \"three\";\nimport * as THREE from \"three\";\nimport { Sphere } from \"./Sphere\";\nimport { Box } from \"./Box\";\nimport { Plane } from \"./Plane\";\n\nexport { Sphere } from \"./Sphere\";\nexport { Box } from \"./Box\";\nexport { Plane } from \"./Plane\";\n\nexport class World {\n    public objects: any[];\n    public coefficient_of_restitution: number = 0.8; // 0 is fully inelastic, 1 is fully elastic\n    public dt: number = 1/60; // time step in seconds\n\n    constructor() {\n        this.objects = [];\n    }\n\n    addObject(obj: any): void {\n        this.objects.push(obj);\n    }\n\n    getAllBoundingBoxIntersections() {\n        // for now just sort against x-axis. Slightly better is to update axis based on one with highest variance\n        // worst case is still O(n^2)\n    \n        function compareBoundingBoxes(a: any, b: any) {\n            const a_min = a.position.x - a.boundingBox.x/2;\n            const b_min = b.position.x - b.boundingBox.x/2;\n            return a_min - b_min;\n        }\n    \n        // sort objects along x-axis\n        const objectsCopy = [...this.objects];\n        objectsCopy.sort(compareBoundingBoxes);\n    \n        // sweep the array for collisions\n        const intersections = [];\n        for(let i = 0; i < objectsCopy.length - 1; i++) {\n            // test against all possible overlapping boxes following the current one.\n            for(let j = i + 1; j < objectsCopy.length; j++) {\n                // stop testing when AABBs are beyond the current AABB\n                const i_max = objectsCopy[i].position.x + objectsCopy[i].boundingBox.x/2;\n                const j_min = objectsCopy[j].position.x - objectsCopy[j].boundingBox.x/2;\n                if (j_min > i_max) {\n                    break;\n                }\n    \n                if (checkBoundingBoxIntersection(objectsCopy[i], objectsCopy[j])) {\n                    intersections.push({\n                        a: objectsCopy[i],\n                        b: objectsCopy[j]\n                    });\n                }\n            }\n        }\n        return intersections;\n    }\n\n    // applies the forceAccum, detects and resolves collisions, and finally updates the positions of all objects.\n    tick(duration: number): void {\n        for (let object of this.objects) {\n            if (object instanceof Plane) {\n                continue;\n            }\n\n            object.integrateForceAccum(duration);\n        }\n\n        const boundingBoxIntersections = this.getAllBoundingBoxIntersections();\n        const contacts = getAllContacts(boundingBoxIntersections);\n        \n        for (let contact of contacts) {\n            this.resolveCollision(contact);\n        }\n\n        for (let object of this.objects) {\n            if (object instanceof Plane) {\n                continue;\n            }\n\n            object.integrate(duration);\n        }\n    }\n\n    // integrates the forceAccum to update the velocity of each object\n    integrateForceAccumObjects(duration: number): void {\n        for(let object of this.objects) {\n            if (object instanceof Plane) {\n                continue;\n            }\n\n            object.integrateForceAccum(duration);\n        }\n    }\n\n    // integrates the velocities to update the position of each object\n    integrateObjects(duration: number): void {\n        for (let object of this.objects) {\n            if (object instanceof Plane) {\n                continue;\n            }\n\n            object.integrate(duration);\n        }\n    }\n\n    resolveCollision(contactData: any) {\n        const a = contactData.a;\n        const b = contactData.b;\n        const normal = contactData.contactNormal;\n        if (contactData.type === \"vertex-face\") {\n            console.log(\"resolving vertex-face contact\");\n            const vertex = contactData.contactPoint;\n            const r_a = vertex.clone().sub(a.position);\n            const r_b = vertex.clone().sub(b.position);\n            const vertexVelocity_a = a.velocity.clone().add(a.getAngularVelocity().cross(r_a));\n            const vertexVelocity_b = b.velocity.clone().add(b.getAngularVelocity().cross(r_b));\n            const relativeVelocity = normal.dot(vertexVelocity_a.clone().sub(vertexVelocity_b));\n            if (relativeVelocity < 0) {\n                console.log(\"colliding contact\");\n                \n                const I_inverse_a = a.getInertia().invert();\n                const I_inverse_b = b.getInertia().invert();\n    \n                const term1 = normal.dot(r_a.clone().cross(normal).applyMatrix3(I_inverse_a).cross(r_a));\n                const term2 = normal.dot(r_b.clone().cross(normal).applyMatrix3(I_inverse_b).cross(r_b));\n    \n                const j = -(1 + coefficient_of_restitution) * relativeVelocity / (a.inverseMass + b.inverseMass + term1 + term2);\n                console.log(\"relative Velocity: \", relativeVelocity);\n    \n                const impulse = normal.clone().multiplyScalar(j);\n                const impulse2 = normal.clone().multiplyScalar(-j);\n                a.applyImpulse(vertex, impulse);\n                b.applyImpulse(vertex, impulse2);\n            } else if (relativeVelocity === 0) {\n                console.log(\"resting contact\");\n            } else {\n                // ignore\n                console.log(\"leaving\");\n            }\n        } else if (contactData.type === \"edge-edge\") {\n            console.log(\"resolving edge-edge contact\");\n            console.log(\"edge_a\", contactData.edge_a);\n            console.log(\"edge_b\", contactData.edge_b);\n            console.log(\"contactNormal: \", contactData.contactNormal);\n    \n            const vertex = getClosestPointBetweenTwoEdges(contactData.edge_a, contactData.edge_b);\n            const r_a = vertex.clone().sub(a.position);\n            const r_b = vertex.clone().sub(b.position);\n            const vertexVelocity_a = a.velocity.clone().add(a.getAngularVelocity().cross(r_a));\n            const vertexVelocity_b = b.velocity.clone().add(b.getAngularVelocity().cross(r_b));\n            const relativeVelocity = normal.dot(vertexVelocity_a.clone().sub(vertexVelocity_b));\n            if (relativeVelocity < 0) {\n                console.log(\"colliding contact\");\n                \n                const I_inverse_a = a.getInertia().invert();\n                let I_inverse_b = b.getInertia().invert();\n    \n                const term1 = normal.dot(r_a.clone().cross(normal).applyMatrix3(I_inverse_a).cross(r_a));\n                const term2 = normal.dot(r_b.clone().cross(normal).applyMatrix3(I_inverse_b).cross(r_b));\n    \n                const j = -(1 + coefficient_of_restitution) * relativeVelocity / (a.inverseMass + b.inverseMass + term1 + term2);\n    \n                const impulse = normal.clone().multiplyScalar(j);\n                const impulse2 = normal.clone().multiplyScalar(-j);\n                a.applyImpulse(vertex, impulse);\n                b.applyImpulse(vertex, impulse2);\n            } else if (relativeVelocity === 0) {\n                console.log(\"resting contact\");\n            } else {\n                // ignore\n                console.log(\"leaving\");\n            }\n        } else {\n            console.error(\"contactData type not recognized.\");\n            console.log(\"contact data: \", contactData);\n        }\n    }\n\n    updateMeshes(): void {\n        for (let object of this.objects) {\n            if (object instanceof Plane) {\n                continue;\n            }\n\n            object.updateMesh();\n            object.updateBoundingBoxMesh();\n        }\n    }\n}\n\n/**\n * checks if the bounding box of two objects intersect\n * @param a the first object\n * @param b the other object\n */\nexport function checkBoundingBoxIntersection(a: any, b: any): boolean {\n    // create intervals\n    const a_x_min = a.position.x - a.boundingBox.x/2;\n    const a_x_max = a.position.x + a.boundingBox.x/2;\n    const a_y_min = a.position.y - a.boundingBox.y/2;\n    const a_y_max = a.position.y + a.boundingBox.y/2;\n    const a_z_min = a.position.z - a.boundingBox.z/2;\n    const a_z_max = a.position.z + a.boundingBox.z/2;\n    const b_x_min = b.position.x - b.boundingBox.x/2;\n    const b_x_max = b.position.x + b.boundingBox.x/2;\n    const b_y_min = b.position.y - b.boundingBox.y/2;\n    const b_y_max = b.position.y + b.boundingBox.y/2;\n    const b_z_min = b.position.z - b.boundingBox.z/2;\n    const b_z_max = b.position.z + b.boundingBox.z/2;\n\n    // intersecting if all intervals are intersecting\n    if ((a_x_min < b_x_max && b_x_min < a_x_max) &&\n        (a_y_min < b_y_max && b_y_min < a_y_max) &&\n        (a_z_min < b_z_max && b_z_min < a_z_max)) {\n        return true\n    }\n    return false;\n}\n\n// returns true if the two objects are intersecting\nexport function checkCollision(a: any, b: any): boolean {\n    if (a instanceof Box && b instanceof Box) {\n        return checkCollisionBoxes(a, b);\n    } else if (a instanceof Box && b instanceof Sphere) {\n        return checkCollisionBoxAndSphere(a, b);\n    } else if (a instanceof Box && b instanceof Plane) {\n        return checkCollisionBoxAndPlane(a, b);\n    } else if (a instanceof Sphere && b instanceof Box) {\n        return checkCollisionBoxAndSphere(b, a);\n    } else if (a instanceof Sphere && b instanceof Sphere) {\n        return checkCollisionSpheres(a, b);\n    } else if (a instanceof Sphere && b instanceof Plane) {\n        return checkCollisionSphereAndPlane(a, b);\n    } else if (a instanceof Plane && b instanceof Box) {\n        return checkCollisionBoxAndPlane(b, a);\n    } else if (a instanceof Plane && b instanceof Sphere) {\n        return checkCollisionSphereAndPlane(b, a);\n    } else {\n        console.error(\"checking collision between these types not implemented.\");\n    }\n}\n\nexport function checkCollisionBoxes(a: Box, b: Box): boolean {\n    // two convex objects don't collide iff there exists a separating plane between them\n\n    // search for separating plane.\n    // either its contain a face of one polyhedra or it contains an edge of one polyhedra and is parallel to the edge of the other polyhedra.\n\n    const a_coordinateAxes = getCoordinateAxes(a);\n    const b_coordinateAxes = getCoordinateAxes(b);\n\n    // check the 6 face axes\n    for (let faceAxis of a_coordinateAxes) {\n        if (separatingAxisPenetration(a, b, faceAxis) < 0) {\n            return false;\n        }\n    }\n    for (let faceAxis of b_coordinateAxes) {\n        if (separatingAxisPenetration(a, b, faceAxis) < 0) {\n            return false;\n        }\n    }\n\n    // check the 9 edge-edge axes\n    for (let a_axis of a_coordinateAxes) {\n        for (let b_axis of b_coordinateAxes) {\n            let m = a_axis.clone().cross(b_axis).normalize();\n            if (m.length() > 0) { // note to self: should use epsilon when checking for zero vector to  improve stability\n                if (separatingAxisPenetration(a, b, m) < 0) {\n                    return false;\n                }\n            } else {\n                // for now, ignore case where the corresponding edges are parallel.\n                continue;\n            }\n        }\n    }\n\n    return true;\n}\n\nexport function checkCollisionSpheres(a: Sphere, b: Sphere): boolean {\n    // two spheres intersect if the distance between their centers is not greater than the sum of their radii\n    const d = a.position.clone().sub(b.position).length();\n    return d <= a.radius + b.radius;\n}\n\nexport function checkCollisionSphereAndPlane(sphere: Sphere, plane: Plane) {\n    const relativePosition = sphere.position.clone().sub(plane.position);\n    const d = relativePosition.dot(plane.normal); // distance to center of sphere, negative if center is below plane.\n    return d <= sphere.radius;\n}\n\nexport function checkCollisionBoxAndSphere(box: Box, sphere: Sphere): boolean {\n    // convert sphere center to box coordinate space\n    const inverseRotation = box.rotation.clone();\n    let sphereCenter = sphere.position.clone().sub(box.position).applyQuaternion(inverseRotation);\n\n    // Clamp each coordinate to the box.\n    const closestPoint = sphereCenter.clone();\n    closestPoint.x = Math.max(Math.min(closestPoint.x, box.width/2), -box.width/2);\n    closestPoint.y = Math.max(Math.min(closestPoint.y, box.length/2), -box.length/2);\n    closestPoint.z = Math.max(Math.min(closestPoint.z, box.height/2), -box.height/2);\n\n    // check if they're in contact\n    const distance = sphereCenter.clone().sub(closestPoint).length();\n    return distance < sphere.radius;\n}\n\nexport function checkCollisionBoxAndPlane(box: Box, plane: Plane): boolean {\n    const vertices = getVertices(box);\n    for (let v of vertices) {\n        const relative_position = v.clone().sub(plane.position);\n        const d = relative_position.dot(plane.normal);\n        if (d < 0) {\n            return true;\n        }\n    }\n    return false;\n}\n\nexport function getAllContacts(boundingBoxIntersections: any[]) {\n    const contacts = [];\n    for(let i = 0; i < boundingBoxIntersections.length; i++) {\n        const a = boundingBoxIntersections[i].a;\n        const b = boundingBoxIntersections[i].b;\n\n        // check for collisions and color them\n        if (checkCollision(a, b)) {\n            const contact = getContactData(a, b);\n            contacts.push(contact);\n        }\n    }\n\n    return contacts;\n}\n\nexport function getContactData(a: any, b: any) {\n    if (a instanceof Box && b instanceof Box) {\n        return getContactDataBoxes(a, b);\n    } else if (a instanceof Box && b instanceof Sphere) {\n        return getContactDataBoxAndSphere(a, b);\n    } else if (a instanceof Box && b instanceof Plane) {\n        return getContactDataBoxAndPlane(a, b);\n    } else if (a instanceof Sphere && b instanceof Box) {\n        return getContactDataBoxAndSphere(b, a);\n    } else if (a instanceof Sphere && b instanceof Sphere) {\n        return getContactDataSpheres(a, b);\n    } else if (a instanceof Sphere && b instanceof Plane) {\n        return getContactDataSphereAndPlane(a, b);\n    } else if (a instanceof Plane && b instanceof Box) {\n        return getContactDataBoxAndPlane(b, a);\n    } else if (a instanceof Plane && b instanceof Sphere) {\n        return getContactDataSphereAndPlane(b, a);\n    } else {\n        console.error(\"getting contact data between these types not implemented.\");\n        return {\n            a: a,\n            b: b,\n            type: \"none\",\n            contactNormal: new Vector3(0, 0, 1),\n            penetration: 0,\n            contactPoint: new Vector3(0, 0, 0),\n            edge_a: { a: new Vector3(0, 0, 0), b: new Vector3(0, 0, 0) },\n            edge_b: { a: new Vector3(0, 0, 0), b: new Vector3(0, 0, 0) }\n        };\n    }\n}\n\n// note: all getContact functions assume the objects already intersect.\n\n// convention: contact data is of format {a, b, type, contactNormal, penetration, contactPoint, ...} where contactNormal points from b to a\n// get contact data for two colliding boxes, assuming collision\nfunction getContactDataBoxes(a: Box, b: Box) {\n    const vector_ab = b.position.clone().sub(a.position);\n    const a_coordinateAxes = getCoordinateAxes(a);\n    const b_coordinateAxes = getCoordinateAxes(b);\n    let smallestOverlap = Infinity;\n    let contact;\n\n    for (let a_axis of a_coordinateAxes) {\n        const overlap = separatingAxisPenetration(a, b, a_axis);\n        if (overlap < smallestOverlap) {\n            smallestOverlap = overlap;\n\n            // set contact\n            const axis = a_axis.clone();\n            if (vector_ab.dot(axis) < 0) { // orient axis to normal of the correct face.\n                axis.multiplyScalar(-1);\n            }\n            axis.normalize();\n            const vertex = getClosestVertex(a, b, axis);\n            contact = {\n                a: b,\n                b: a,\n                type: \"vertex-face\",\n                contactNormal: axis,\n                penetration: smallestOverlap,\n                contactPoint: vertex,\n                edge_a: { a: new Vector3(0, 0, 0), b: new Vector3(0, 0, 0) },\n                edge_b: { a: new Vector3(0, 0, 0), b: new Vector3(0, 0, 0) }\n            };\n        }\n    }\n    for (let b_axis of b_coordinateAxes) {\n        const overlap = separatingAxisPenetration(a, b, b_axis);\n        if (overlap < smallestOverlap) {\n            smallestOverlap = overlap;\n\n            // set contact\n            const axis = b_axis.clone();\n            if (vector_ab.clone().dot(axis) > 0) { // orient axis to normal of the correct face.\n                axis.multiplyScalar(-1);\n            }\n            axis.normalize();\n            const vertex = getClosestVertex(b, a, axis);\n            contact = {\n                a: a,\n                b: b, \n                type: \"vertex-face\",\n                contactNormal: axis,\n                penetration: smallestOverlap,\n                contactPoint: vertex,\n                edge_a: { a: new Vector3(0, 0, 0), b: new Vector3(0, 0, 0) },\n                edge_b: { a: new Vector3(0, 0, 0), b: new Vector3(0, 0, 0) }\n            };\n        }\n    }\n\n    for (let a_axis of a_coordinateAxes) {\n        for (let b_axis of b_coordinateAxes) {\n            let m = a_axis.clone().cross(b_axis).normalize();\n            if (m.length() > 0.005) { // check parallel edges\n                const overlap = separatingAxisPenetration(a, b, m);\n\n                if (overlap < smallestOverlap) {\n                    smallestOverlap = overlap;\n\n                    // set contact\n                    const axis = m.clone();\n                    if (vector_ab.clone().dot(axis) > 0) {\n                        axis.multiplyScalar(-1);\n                    }\n                    axis.normalize();\n                    const edge_a = getClosestEdge(b, a, a_axis, m);\n                    const edge_b = getClosestEdge(a, b, b_axis, m);\n                    contact = {\n                        a: a,\n                        b: b,\n                        type: \"edge-edge\",\n                        contactNormal: axis,\n                        penetration: smallestOverlap,\n                        contactPoint: getClosestPointBetweenTwoEdges(edge_a, edge_b),\n                        edge_a: edge_a,\n                        edge_b: edge_b\n                    };\n                }\n            } else {\n                // for now, ignore case where the corresponding edges are parallel.\n                continue;\n            }\n        }\n    }\n    \n    return contact;\n}\n\nfunction getContactDataBoxAndSphere(box: Box, sphere: Sphere) {\n    // convert sphere center to box coordinate space\n    const inverseRotation = box.rotation.clone();\n    let sphereCenter = sphere.position.clone().sub(box.position).applyQuaternion(inverseRotation);\n\n    // Clamp each coordinate to the box.\n    let closestPoint = sphereCenter.clone();\n    closestPoint.x = Math.max(Math.min(closestPoint.x, box.width/2), -box.width/2);\n    closestPoint.y = Math.max(Math.min(closestPoint.y, box.length/2), -box.length/2);\n    closestPoint.z = Math.max(Math.min(closestPoint.z, box.height/2), -box.height/2);\n\n    const distance = sphereCenter.clone().sub(closestPoint).length();\n    const penetration = sphere.radius - distance;\n\n    // convert back to world space\n    closestPoint.applyQuaternion(box.rotation).add(box.position);\n\n    const contactPoint = closestPoint;\n    const contactNormal = closestPoint.clone().sub(sphere.position.clone()).normalize();\n\n    const contact = {\n        a: box,\n        b: sphere,\n        type: \"vertex-face\",\n        contactNormal: contactNormal,\n        penetration: penetration,\n        contactPoint: contactPoint,\n        edge_a: { a: new Vector3(0, 0, 0), b: new Vector3(0, 0, 0) },\n        edge_b: { a: new Vector3(0, 0, 0), b: new Vector3(0, 0, 0) }\n    }\n    return contact;\n}\n\nfunction getContactDataSpheres(a: Sphere, b: Sphere) {\n    const v_ab = b.position.clone().sub(a.position);\n    const contactPoint = a.position.clone().add(v_ab.clone().multiplyScalar(a.radius).sub(v_ab.clone().multiplyScalar(b.radius)).multiplyScalar(0.5));\n    const penetration = a.radius - b.radius - v_ab.length()\n    const contactNormal = v_ab.clone().multiplyScalar(-1).normalize();\n    const contact = {\n        a: a,\n        b: b,\n        type: \"vertex-face\",\n        contactNormal: contactNormal,\n        penetration: penetration,\n        contactPoint: contactPoint,\n        edge_a: { a: new Vector3(0, 0, 0), b: new Vector3(0, 0, 0) },\n        edge_b: { a: new Vector3(0, 0, 0), b: new Vector3(0, 0, 0) }\n    }\n    return contact;\n}\n\nfunction getContactDataBoxAndPlane(box: Box, plane: Plane) {\n    const vertices = getVertices(box);\n    let contactPoint = vertices[0];\n    let penetration = 0;\n    \n    for (let v of vertices) {\n        const relative_position = v.clone().sub(plane.position);\n        const d = relative_position.dot(plane.normal);\n        if (d < penetration) {\n            contactPoint = v;\n            penetration = d;\n        }\n    }\n\n    const contact = {\n        a: box,\n        b: plane,\n        type: \"vertex-face\",\n        contactNormal: plane.normal.clone(),\n        penetration: penetration,\n        contactPoint: contactPoint,\n        edge_a: { a: new Vector3(0, 0, 0), b: new Vector3(0, 0, 0) },\n        edge_b: { a: new Vector3(0, 0, 0), b: new Vector3(0, 0, 0) }\n    };\n    return contact;\n}\n\nfunction getContactDataSphereAndPlane(sphere: Sphere, plane: Plane) {\n    const relativePosition = sphere.position.clone().sub(plane.position);\n    const d = relativePosition.dot(plane.normal); // distance to center of sphere, negative if center is below plane.\n    const penetration = sphere.radius - d;\n\n    const contactPoint = sphere.position.clone().addScaledVector(plane.normal, -sphere.radius);\n\n    const contact = {\n        a: sphere,\n        b: plane,\n        type: \"vertex-face\",\n        contactNormal: plane.normal.clone(),\n        penetration: penetration,\n        contactPoint: contactPoint,\n        edge_a: { a: new Vector3(0, 0, 0), b: new Vector3(0, 0, 0) },\n        edge_b: { a: new Vector3(0, 0, 0), b: new Vector3(0, 0, 0) }\n    };\n    return contact;\n}\n\nconst coefficient_of_restitution = 0.8;\nexport function resolveCollision(contactData: any) {\n    const a = contactData.a;\n    const b = contactData.b;\n    const normal = contactData.contactNormal;\n    if (contactData.type === \"vertex-face\") {\n        console.log(\"resolving vertex-face contact\");\n        const vertex = contactData.contactPoint;\n        const r_a = vertex.clone().sub(a.position);\n        const r_b = vertex.clone().sub(b.position);\n        const vertexVelocity_a = a.velocity.clone().add(a.getAngularVelocity().cross(r_a));\n        const vertexVelocity_b = b.velocity.clone().add(b.getAngularVelocity().cross(r_b));\n        const relativeVelocity = normal.dot(vertexVelocity_a.clone().sub(vertexVelocity_b));\n        if (relativeVelocity < 0) {\n            console.log(\"colliding contact\");\n            \n            const I_inverse_a = a.getInertia().invert();\n            const I_inverse_b = b.getInertia().invert();\n\n            const term1 = normal.dot(r_a.clone().cross(normal).applyMatrix3(I_inverse_a).cross(r_a));\n            const term2 = normal.dot(r_b.clone().cross(normal).applyMatrix3(I_inverse_b).cross(r_b));\n\n            const j = -(1 + coefficient_of_restitution) * relativeVelocity / (a.inverseMass + b.inverseMass + term1 + term2);\n            console.log(\"relative Velocity: \", relativeVelocity);\n\n            const impulse = normal.clone().multiplyScalar(j);\n            const impulse2 = normal.clone().multiplyScalar(-j);\n            a.applyImpulse(vertex, impulse);\n            b.applyImpulse(vertex, impulse2);\n        } else if (relativeVelocity === 0) {\n            console.log(\"resting contact\");\n        } else {\n            // ignore\n            console.log(\"leaving\");\n        }\n    } else if (contactData.type === \"edge-edge\") {\n        console.log(\"resolving edge-edge contact\");\n        console.log(\"edge_a\", contactData.edge_a);\n        console.log(\"edge_b\", contactData.edge_b);\n        console.log(\"contactNormal: \", contactData.contactNormal);\n\n        const vertex = getClosestPointBetweenTwoEdges(contactData.edge_a, contactData.edge_b);\n        const r_a = vertex.clone().sub(a.position);\n        const r_b = vertex.clone().sub(b.position);\n        const vertexVelocity_a = a.velocity.clone().add(a.getAngularVelocity().cross(r_a));\n        const vertexVelocity_b = b.velocity.clone().add(b.getAngularVelocity().cross(r_b));\n        const relativeVelocity = normal.dot(vertexVelocity_a.clone().sub(vertexVelocity_b));\n        if (relativeVelocity < 0) {\n            console.log(\"colliding contact\");\n            \n            const I_inverse_a = a.getInertia().invert();\n            let I_inverse_b = b.getInertia().invert();\n\n            const term1 = normal.dot(r_a.clone().cross(normal).applyMatrix3(I_inverse_a).cross(r_a));\n            const term2 = normal.dot(r_b.clone().cross(normal).applyMatrix3(I_inverse_b).cross(r_b));\n\n            const j = -(1 + coefficient_of_restitution) * relativeVelocity / (a.inverseMass + b.inverseMass + term1 + term2);\n\n            const impulse = normal.clone().multiplyScalar(j);\n            const impulse2 = normal.clone().multiplyScalar(-j);\n            a.applyImpulse(vertex, impulse);\n            b.applyImpulse(vertex, impulse2);\n        } else if (relativeVelocity === 0) {\n            console.log(\"resting contact\");\n        } else {\n            // ignore\n            console.log(\"leaving\");\n        }\n    } else {\n        console.error(\"contactData type not recognized.\");\n        console.log(\"contact data: \", contactData);\n    }\n}\n\n// returns closest edge of box b\n// edge should be parallel to input edgeVector\nfunction getClosestEdge(a: Box, b: Box, edgeVector: Vector3, separatingAxis: Vector3) {\n    const x = separatingAxis.x;\n    const y = separatingAxis.y;\n    const z = separatingAxis.z;\n    const projectionMatrix = new Matrix3();\n    projectionMatrix.set(\n        x*x, x*y, x*z,\n        x*y, y*y, y*z,\n        x*z, y*z, z*z\n    );\n\n    const a_center = a.position.clone().applyMatrix3(projectionMatrix);\n\n    const b_edges = getEdges(b);\n    const parallel_b_edges = [];\n    for (let b_edge of b_edges) {\n        const b_edgeVector = b_edge.b.clone().sub(b_edge.a);\n        if (b_edgeVector.clone().cross(edgeVector).length() < 0.005) {\n            parallel_b_edges.push(b_edge);\n        }\n    }\n\n    let closestEdge = parallel_b_edges[0];\n    let closestDistance = closestEdge.a.clone().sub(a_center).length();\n    for (let b_edge of parallel_b_edges) {\n        const d = b_edge.a.clone().sub(a_center).length();\n        if (d < closestDistance) {\n            closestDistance = d;\n            closestEdge = b_edge;\n        }\n    }\n\n    return closestEdge;\n}\n\n// returns closest vertex of box b to face of box a\nfunction getClosestVertex(a: Box, b: Box, lineVector: Vector3): Vector3 {\n    const a_vertices = getVertices(a);\n    const b_vertices = getVertices(b);\n\n    const x = lineVector.x;\n    const y = lineVector.y;\n    const z = lineVector.z;\n    const projectionMatrix = new Matrix3();\n    projectionMatrix.set(\n        x*x, x*y, x*z,\n        x*y, y*y, y*z,\n        x*z, y*z, z*z\n    );\n\n    const a_center = a.position.clone().applyMatrix3(projectionMatrix);\n\n    let a_radius = 0;\n\n    for (let a_v of a_vertices) {\n        const a_v_projection = a_v.clone().applyMatrix3(projectionMatrix);\n        const r = a_v_projection.clone().sub(a_center).length();\n        if (r > a_radius) {\n            a_radius = r;\n        }\n    }\n\n    const b_center = b.position.clone().applyMatrix3(projectionMatrix);\n    let vertex = b_vertices[0];\n    let smallestDistanceToA = b_center.clone().sub(a_center).length() - a_radius;\n\n    for (let b_v of b_vertices) {\n        const b_v_projection = b_v.clone().applyMatrix3(projectionMatrix);\n        const d = b_v_projection.clone().sub(a_center).length() - a_radius;\n        if (d < smallestDistanceToA) {\n            smallestDistanceToA = d;\n            vertex = b_v;\n        }\n    }\n\n    return vertex;\n}\n\nfunction separatingAxisPenetration(a: Box, b: Box, lineVector: Vector3): number {\n    const x = lineVector.x;\n    const y = lineVector.y;\n    const z = lineVector.z;\n    const projectionMatrix = new Matrix3();\n    projectionMatrix.set(\n        x*x, x*y, x*z,\n        x*y, y*y, y*z,\n        x*z, y*z, z*z\n    );\n\n    const a_center = a.position.clone().applyMatrix3(projectionMatrix);\n    const b_center = b.position.clone().applyMatrix3(projectionMatrix);\n    const d = b_center.clone().sub(a_center).length();\n\n    const a_vertices = getVertices(a);\n    const b_vertices = getVertices(b);\n\n    let r_a = 0, r_b = 0;\n    for (let a_v of a_vertices) {\n        const a_v_projection = a_v.applyMatrix3(projectionMatrix);\n        const r = a_center.clone().sub(a_v_projection).length()\n        if (r > r_a) {\n            r_a = r;\n        }\n    }\n    for (let b_v of b_vertices) {\n        const b_v_projection = b_v.applyMatrix3(projectionMatrix);\n        const r = b_center.clone().sub(b_v_projection).length()\n        if (r > r_b) {\n            r_b = r;\n        }\n    }\n\n    // returns the overlap. positive indicates overlap, negative indicates separation.\n    return r_a + r_b - d;\n}\n\nfunction getClosestPointBetweenTwoEdges(e1: any, e2: any) {\n    const p1 = e1.a;\n    const p2 = e1.b;\n    const p3 = e2.a;\n    const p4 = e2.b;\n\n    const v12 = p2.clone().sub(p1);\n    const v34 = p4.clone().sub(p3);\n    const v13 = p3.clone().sub(p1);\n\n    let s, t;\n\n    // terms\n    const R_1_squared = v12.dot(v12);\n    const R_2_squared = v34.dot(v34);\n    const D_4321 = v12.dot(v34);\n    const D_3121 = v12.dot(v13);\n    const D_4331 = v13.dot(v34);\n    const denominator = D_4321*D_4321 - R_1_squared*R_2_squared;\n\n    s = (D_4321*D_4331 - R_2_squared*D_3121) / denominator;\n    t = (R_1_squared*D_4331 - D_4321*D_3121) / denominator;\n\n    s = Math.max(Math.min(s, 1), 0);\n    t = Math.max(Math.min(t, 1), 0);\n\n    const point_a = e1.a.clone().add(v12.clone().multiplyScalar(s));\n    const point_b = e2.a.clone().add(v34.clone().multiplyScalar(t));\n\n    return point_a.clone().add(point_b).multiplyScalar(1/2);\n}\n\nfunction getCoordinateAxes(box: Box) {\n    const x = new Vector3(1, 0, 0), y = new Vector3(0, 1, 0), z = new Vector3(0, 0, 1);\n\n    const axes = [x, y, z];\n\n    for (let axis of axes) {\n        axis.applyQuaternion(box.rotation);\n    }\n    return axes;\n}\n\nfunction getVertices(box: Box) {\n    const x = box.position.x;\n    const y = box.position.y;\n    const z = box.position.z;\n    const v1 = new Vector3(x - box.width/2, y - box.length/2, z - box.height/2);\n    const v2 = new Vector3(x - box.width/2, y + box.length/2, z - box.height/2);\n    const v3 = new Vector3(x + box.width/2, y + box.length/2, z - box.height/2);\n    const v4 = new Vector3(x + box.width/2, y - box.length/2, z - box.height/2);\n    const v5 = new Vector3(x - box.width/2, y - box.length/2, z + box.height/2);\n    const v6 = new Vector3(x - box.width/2, y + box.length/2, z + box.height/2);\n    const v7 = new Vector3(x + box.width/2, y + box.length/2, z + box.height/2);\n    const v8 = new Vector3(x + box.width/2, y - box.length/2, z + box.height/2);\n    const vertices = [v1, v2, v3, v4, v5, v6, v7, v8];\n\n    // rotate vertices\n    for (let vertex of vertices) {\n        // convert to body space, apply rotation, convert back to world space\n        vertex.sub(box.position);\n        vertex.applyQuaternion(box.rotation);\n        vertex.add(box.position);\n    }\n\n    return vertices;\n}\n\nfunction getEdges(box: Box) {\n    const x = box.position.x;\n    const y = box.position.y;\n    const z = box.position.z;\n    const v1 = new Vector3(x - box.width/2, y - box.length/2, z - box.height/2);\n    const v2 = new Vector3(x - box.width/2, y + box.length/2, z - box.height/2);\n    const v3 = new Vector3(x + box.width/2, y + box.length/2, z - box.height/2);\n    const v4 = new Vector3(x + box.width/2, y - box.length/2, z - box.height/2);\n    const v5 = new Vector3(x - box.width/2, y - box.length/2, z + box.height/2);\n    const v6 = new Vector3(x - box.width/2, y + box.length/2, z + box.height/2);\n    const v7 = new Vector3(x + box.width/2, y + box.length/2, z + box.height/2);\n    const v8 = new Vector3(x + box.width/2, y - box.length/2, z + box.height/2);\n    const vertices = [v1, v2, v3, v4, v5, v6, v7, v8];\n\n    // rotate vertices\n    for (let vertex of vertices) {\n        // convert to body space, apply rotation, convert back to world space\n        vertex.sub(box.position);\n        vertex.applyQuaternion(box.rotation);\n        vertex.add(box.position);\n    }\n\n    const edges = [];\n    edges.push({a: v1, b: v2});\n    edges.push({a: v1, b: v4});\n    edges.push({a: v1, b: v5});\n    edges.push({a: v2, b: v3});\n    edges.push({a: v2, b: v6});\n    edges.push({a: v3, b: v4});\n    edges.push({a: v3, b: v7});\n    edges.push({a: v4, b: v8});\n    edges.push({a: v5, b: v6});\n    edges.push({a: v5, b: v8});\n    edges.push({a: v6, b: v7});\n    edges.push({a: v7, b: v8});\n\n    return edges;\n}\n\nexport function getAllBoundingBoxIntersections(objects: any[]) {\n    // for now just sort against x-axis. Slightly better is to update axis based on one with highest variance\n    // worst case is still O(n^2)\n\n    function compareBoundingBoxes(a: any, b: any) {\n        const a_min = a.position.x - a.boundingBox.x/2;\n        const b_min = b.position.x - b.boundingBox.x/2;\n        return a_min - b_min;\n    }\n\n    // sort objects along x-axis\n    const objectsCopy = [...objects];\n    objectsCopy.sort(compareBoundingBoxes);\n\n    // sweep the array for collisions\n    const intersections = [];\n    for(let i = 0; i < objectsCopy.length - 1; i++) {\n        // test against all possible overlapping boxes following the current one.\n        for(let j = i + 1; j < objectsCopy.length; j++) {\n            // stop testing when AABBs are beyond the current AABB\n            const i_max = objectsCopy[i].position.x + objectsCopy[i].boundingBox.x/2;\n            const j_min = objectsCopy[j].position.x - objectsCopy[j].boundingBox.x/2;\n            if (j_min > i_max) {\n                break;\n            }\n\n            if (checkBoundingBoxIntersection(objectsCopy[i], objectsCopy[j])) {\n                intersections.push({\n                    a: objectsCopy[i],\n                    b: objectsCopy[j]\n                });\n            }\n        }\n    }\n    return intersections;\n}\n\n/**\n * for symmetrical objects, valid separating axis iff sum the radii (half_widths) of the projected intervals is less than the distance between the centers\n * @param a \n * @param b \n * @param lineVector a unit vector describing the direction of the line\n * @returns true if the lineVector is a separating axis\n */\n/*export function testSeparatingAxis(a: Box, b: Box, lineVector: Vector3): boolean {\n    const x = lineVector.x;\n    const y = lineVector.y;\n    const z = lineVector.z;\n    const projectionMatrix = new Matrix3();\n    projectionMatrix.set(\n        x*x, x*y, x*z,\n        x*y, y*y, y*z,\n        x*z, y*z, z*z\n    );\n\n    const a_center = a.position.clone().applyMatrix3(projectionMatrix);\n    const b_center = b.position.clone().applyMatrix3(projectionMatrix);\n    const d = b_center.clone().sub(a_center).length();\n\n    const a_vertices = getVertices(a);\n    const b_vertices = getVertices(b);\n    \n    let r_a = 0, r_b = 0;\n    for (let a_v of a_vertices) {\n        const a_v_projection = a_v.applyMatrix3(projectionMatrix);\n        const r = a_center.clone().sub(a_v_projection).length()\n        if (r > r_a) {\n            r_a = r;\n        }\n    }\n    for (let b_v of b_vertices) {\n        const b_v_projection = b_v.applyMatrix3(projectionMatrix);\n        const r = b_center.clone().sub(b_v_projection).length()\n        if (r > r_b) {\n            r_b = r;\n        }\n    }\n    if (r_a + r_b < d) {\n        return true;\n    }\n\n    return false;\n}*/\n\n/*\nexport function checkCollisionBoxes(a: Box, b: Box): boolean {\n    // two convex objects don't collide iff there exists a separating plane between them\n\n    // search for separating plane.\n    // either its contain a face of one polyhedra or it contains an edge of one polyhedra and is parallel to the edge of the other polyhedra.\n    \n    const a_facePlanes = getFacePlanes(a);\n    for (let facePlane of a_facePlanes) {\n        if (testSeparatingAxis(a, b, facePlane.normal)) {\n            return false;\n        };\n    }\n    const b_facePlanes = getFacePlanes(b);\n    for (let facePlane of b_facePlanes) {\n        if (testSeparatingAxis(a, b, facePlane.normal)) {\n            return false;\n        }\n    }\n\n    const a_edges = getEdges(a);\n    const b_edges = getEdges(b);\n\n    for (let i = 0; i < a_edges.length; i++) {\n        for (let j = 0; j < b_edges.length; j++) {\n            const edge_i = a_edges[i].b.clone().sub(a_edges[i].a);\n            const edge_j = b_edges[j].b.clone().sub(b_edges[j].a);\n            let m = edge_i.clone().cross(edge_j);\n            if (m.length() !== 0) { // note to self: should use epsilon when checking for zero vector to improve stability\n                if (testSeparatingAxis(a, b, m)) {\n                    return false;\n                }\n            } else {\n                const edge_n = b_edges[j].b.clone().sub(a_edges[i].a);\n                m = edge_i.clone().cross(edge_n);\n                if (m.length() !== 0) {\n                    testSeparatingAxis(a, b, m);\n                } else {\n                    return true; // since edge_i and edge_2 are colinear\n                }\n            }\n        }\n    }\n\n    return true;\n}*/\n\n/*\nfunction getFaces(box: Box) {\n    const x = box.position.x;\n    const y = box.position.y;\n    const z = box.position.z;\n    const v1 = new Vector3(x - box.width/2, y - box.length/2, z - box.height/2);\n    const v2 = new Vector3(x - box.width/2, y + box.length/2, z - box.height/2);\n    const v3 = new Vector3(x + box.width/2, y + box.length/2, z - box.height/2);\n    const v4 = new Vector3(x + box.width/2, y - box.length/2, z - box.height/2);\n    const v5 = new Vector3(x - box.width/2, y - box.length/2, z + box.height/2);\n    const v6 = new Vector3(x - box.width/2, y + box.length/2, z + box.height/2);\n    const v7 = new Vector3(x + box.width/2, y + box.length/2, z + box.height/2);\n    const v8 = new Vector3(x + box.width/2, y - box.length/2, z + box.height/2);\n    const vertices = [v1, v2, v3, v4, v5, v6, v7, v8];\n\n    // rotate vertices\n    for (let vertex of vertices) {\n        // convert to body space, apply rotation, convert back to world space\n        vertex.sub(box.position);\n        vertex.applyQuaternion(box.rotation);\n        vertex.add(box.position);\n    }\n    \n    const f1 = { edges: [{a: v1, b: v2}, {a: v1, b: v4}, {a: v2, b: v3}, {a: v3, b: v4}] }; // bottom\n    const f2 = { edges: [{a: v5, b: v6}, {a: v5, b: v8}, {a: v6, b: v7}, {a: v7, b: v8}] }; // top\n    const f3 = { edges: [{a: v1, b: v2}, {a: v1, b: v5}, {a: v5, b: v6}, {a: v6, b: v2}] }; // left\n    const f4 = { edges: [{a: v4, b: v8}, {a: v4, b: v3}, {a: v8, b: v7}, {a: v7, b: v3}] }; // right\n    const f5 = { edges: [{a: v1, b: v4}, {a: v1, b: v5}, {a: v5, b: v8}, {a: v8, b: v4}] }; // front\n    const f6 = { edges: [{a: v2, b: v3}, {a: v2, b: v6}, {a: v6, b: v7}, {a: v7, b: v3}] }; // back\n    const faces = [f1, f2, f3, f4, f5, f6];\n    return faces;\n}*/\n\n/*\nexport function getAllBoundingBoxIntersections(boxes: Box[]) {\n    // create and sort intervals along x, y, and z\n    const x_intervals = [];\n    const y_intervals = [];\n    const z_intervals = [];\n    for(let box of boxes) {\n        const x_min = box.position.x - box.boundingBox.x/2;\n        const x_max = box.position.x + box.boundingBox.x/2;\n        x_intervals.push({ type: \"min\", value: x_min, object: box});\n        x_intervals.push({ type: \"max\", value: x_max, object: box});\n\n        \n        const y_min = box.position.y - box.boundingBox.y/2;\n        const y_max = box.position.y + box.boundingBox.y/2;\n        y_intervals.push({ type: \"min\", value: y_min, object: box});\n        y_intervals.push({ type: \"max\", value: y_max, object: box});\n\n        const z_min = box.position.z - box.boundingBox.z/2;\n        const z_max = box.position.z + box.boundingBox.z/2;\n        z_intervals.push({ type: \"min\", value: z_min, object: box});\n        z_intervals.push({ type: \"max\", value: z_max, object: box});\n    }\n    // note to self: switch to insertion sort and use normal merge sort only during the initialization frame\n    x_intervals.sort((a, b) => a.value - b.value);\n    //y_intervals.sort((a, b) => a.value - b.value);\n    //z_intervals.sort((a, b) => a.value - b.value);\n\n    // create a list of active intervals\n    const activeIntervals = [];\n}*/\n\n/*\nexport class World2 {\n    private objects: any[] = [];\n    private currentLoopInterval: any = null;\n\n    private characterForce: Vector3;\n\n    constructor() {\n        this.objects = [];\n\n        this.characterForce = new Vector3(0, 0, 0);\n    }\n\n    startLoop(): void {\n        const currentInstance = this;\n\n        // stop current loop if it exits\n        this.stopCurrentLoop();\n\n        let lastTimeCalled = performance.now();\n        let fps = 0;\n        let times: any[] = [];\n\n        function step() {\n            // calculate fps\n            const now = performance.now();\n            while (times.length > 0 && times[0] <= now - 1000) {\n                times.shift();\n            }\n            times.push(now);\n            fps = times.length;\n            // console.log(\"fps: \", fps);\n\n            for (let i = 0; i < currentInstance.objects.length; i++) {\n                currentInstance.objects[i].integrate(dt);\n            }\n        }\n\n        this.currentLoopInterval = setInterval(step, dt * 1000);\n    }\n\n    // Stops current loop if it exists.\n    stopCurrentLoop(): void {\n        if (this.currentLoopInterval) {\n            clearInterval(this.currentLoopInterval);\n        }\n    }\n\n    addObject(obj: any): void {\n        this.objects.push(obj);\n    }\n\n    getObjects(): any[] {\n        return this.objects;\n    }\n\n    updateCharacterForce(f: Vector3) {\n        this.characterForce = f;\n    }\n\n    detectCollisions(): void {\n\n    }\n\n    checkCollisionSpheres(s1: Sphere, s2: Sphere) {\n        const d = (s1.position.clone().sub(s2.position)).length(); // distance between centers\n\n        // collision if distance between spheres is smaller than sub of radiuses\n        if (d < (s1.radius + s2.radius)) {\n            return true;\n        }\n        return false;\n    }\n\n    resolveCollisionSpheres(s1: Sphere, s2: Sphere) {\n        // find unit vectors from s1 to s2 and s2 to s1\n        const u12 = (s2.position.clone().sub(s1.position)).normalize();\n        const u21 = u12.clone().multiplyScalar(-1);\n\n        // find components of v1 and v2 along and perpendicular to u\n        const v1_along_u12 = u12.clone().multiplyScalar(u12.dot(s1.velocity));\n        const v2_along_u21 = u21.clone().multiplyScalar(u21.dot(s2.velocity));\n\n        const v1_perp_u12 = s1.velocity.clone().sub(v1_along_u12);\n        const v2_perp_u21 = s2.velocity.clone().sub(v2_along_u21);\n\n        // calculate new velocities along u, assuming elastic collision\n        const m1 = 1/s1.inverseMass;\n        const m2 = 1/s2.inverseMass;\n        const v1_along_u_new = (v1_along_u12.clone().multiplyScalar((m1-m2)/(m1+m2))).addScaledVector(v2_along_u21, (2*m2)/(m1+m2));\n        const v2_along_u_new = (v1_along_u12.clone().multiplyScalar((2*m1)/(m1+m2))).addScaledVector(v2_along_u21, -(m1-m2)/(m1+m2));\n\n        // calculate and set new velocities\n        const v1_new = v1_along_u_new.clone().add(v1_perp_u12);\n        const v2_new = v2_along_u_new.clone().add(v2_perp_u21);\n\n        console.log(\"u: \", u12);\n        console.log(\"v1_new: \", v1_new);\n        console.log(\"v2_new\", v2_new);\n    }\n\n    clearCurrentLoop(): void {\n        clearInterval(this.currentLoopInterval);\n    }\n}*/\n\n/*\nfunction getFacePlanes(box: Box) {\n    const x = box.position.x;\n    const y = box.position.y;\n    const z = box.position.z;\n    const v1 = new Vector3(x - box.width/2, y - box.length/2, z - box.height/2);\n    const v2 = new Vector3(x - box.width/2, y + box.length/2, z - box.height/2);\n    const v3 = new Vector3(x + box.width/2, y + box.length/2, z - box.height/2);\n    const v4 = new Vector3(x + box.width/2, y - box.length/2, z - box.height/2);\n    const v5 = new Vector3(x - box.width/2, y - box.length/2, z + box.height/2);\n    const v6 = new Vector3(x - box.width/2, y + box.length/2, z + box.height/2);\n    const v7 = new Vector3(x + box.width/2, y + box.length/2, z + box.height/2);\n    const v8 = new Vector3(x + box.width/2, y - box.length/2, z + box.height/2);\n    const vertices = [v1, v2, v3, v4, v5, v6, v7, v8];\n\n    // rotate vertices\n    for (let vertex of vertices) {\n        // convert to body space, apply rotation, convert back to world space\n        vertex.sub(box.position);\n        vertex.applyQuaternion(box.rotation);\n        vertex.add(box.position);\n    }\n    const face1 = { normal: ((v2.clone().sub(v1)).cross(v4.clone().sub(v1))).normalize(), point: v1 } // bottom plane\n    const face2 = { normal: ((v8.clone().sub(v5)).cross(v6.clone().sub(v5))).normalize(), point: v5 } // top plane\n    const face3 = { normal: ((v5.clone().sub(v1)).cross(v2.clone().sub(v1))).normalize(), point: v1 } // left plane\n    const face4 = { normal: ((v3.clone().sub(v4)).cross(v8.clone().sub(v4))).normalize(), point: v4 } // top plane\n    const face5 = { normal: ((v4.clone().sub(v1)).cross(v5.clone().sub(v1))).normalize(), point: v1 } // front plane\n    const face6 = { normal: ((v2.clone().sub(v3)).cross(v7.clone().sub(v3))).normalize(), point: v3 } // back plane\n    const facePlanes = [face1, face2, face3, face4, face5, face6];\n    return facePlanes;\n}*/"],"mappings":"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A,G,CAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,G,CAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,G,CAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,G,CAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA"},"metadata":{},"sourceType":"module"}