{"ast":null,"code":"import * as THREE from \"three\";\nimport { Vector3, Matrix3, Quaternion } from \"three\";\nimport { convertQuaternionToMatrix, addQuaternions, scaleQuaternion } from \"./math_library\";\nexport class Box {\n  // inertia tensor in body space\n  // public momentum: Vector3;\n  // the orientation\n  // holds the accumulated force to be applied to the next simulation iteration only.\n  // width, length, and height of the bounding box\n  // for graphics\n  constructor(position, width, length, height) {\n    this.inverseMass = void 0;\n    this.width = void 0;\n    this.length = void 0;\n    this.height = void 0;\n    this.inertia_body = void 0;\n    this.position = void 0;\n    this.velocity = void 0;\n    this.rotation = void 0;\n    this.angularMomentum = void 0;\n    this.forceAccum = void 0;\n    this.boundingBox = void 0;\n    this.mesh = void 0;\n    this.boundingBoxMesh = void 0;\n    this.inverseMass = 1 / (width * length * height);\n    this.width = width;\n    this.length = length;\n    this.height = height;\n    this.inertia_body = new Matrix3();\n    this.setInertia();\n    this.position = position;\n    this.velocity = new Vector3(0, 0, 0); // this.momentum = (new Vector3(1, 0, 0)).multiplyScalar(1/this.inverseMass);\n\n    this.rotation = new Quaternion(0, 0, 0, 1);\n    this.angularMomentum = new Vector3(0, 0, 0).applyMatrix3(this.getInertia());\n    this.forceAccum = new Vector3(0, 0, 0);\n    this.setBoundingBox(); // for graphics\n\n    this.createMesh();\n    this.updateMesh();\n    this.createBoundingBoxMesh();\n    this.updateBoundingBoxMesh();\n  }\n\n  setInertia() {\n    const mass = 1 / this.inverseMass;\n    const I_xx = 1 / 12 * mass * (this.length * this.length + this.height * this.height);\n    const I_yy = 1 / 12 * mass * (this.width * this.width + this.height * this.height);\n    const I_zz = 1 / 12 * mass * (this.width * this.width + this.length * this.length);\n    this.inertia_body.set(I_xx, 0, 0, 0, I_yy, 0, 0, 0, I_zz);\n  }\n\n  getInertia() {\n    const rotationMatrix = convertQuaternionToMatrix(this.rotation);\n    const inertia = rotationMatrix.clone().multiply(this.inertia_body).multiply(rotationMatrix.clone().transpose());\n    return inertia;\n  }\n\n  getI_inverse() {\n    const I_body_inverse = this.inertia_body.clone().invert();\n    const rotationMatrix = convertQuaternionToMatrix(this.rotation);\n    const I_inverse = rotationMatrix.clone().multiply(I_body_inverse).multiply(rotationMatrix.clone().transpose());\n    return I_inverse;\n  }\n\n  getAngularVelocity() {\n    const I_inverse = this.getInertia().invert();\n    const angularVelocity = this.angularMomentum.clone().applyMatrix3(I_inverse);\n    return angularVelocity;\n  } // update velocity based on forceAccum and clear forceAccum\n\n\n  integrateForceAccum(duration) {\n    // Don't integrate if mass is infinite or duration <= 0.\n    if (this.inverseMass <= 0 || duration <= 0) {\n      return;\n    }\n  }\n\n  integrate(duration) {\n    // Don't integrate if mass is infinite or duration <= 0.\n    if (this.inverseMass <= 0 || duration <= 0) {\n      return;\n    } // update velocity based on force and then clear forces\n\n\n    this.velocity.addScaledVector(this.forceAccum, duration * this.inverseMass);\n    this.clearAccumulator(); // update position\n\n    this.position.addScaledVector(this.velocity, duration); // this.position.addScaledVector(this.momentum, this.inverseMass * duration);\n    // update rotation\n\n    const angularVelocity = this.getAngularVelocity(); // ddt_q = (1/2) * w(t) * q(t)\n\n    const ddt_Rotation = new Quaternion(angularVelocity.x / 2, angularVelocity.y / 2, angularVelocity.z / 2, 0).multiply(this.rotation);\n    this.rotation = addQuaternions(this.rotation, scaleQuaternion(ddt_Rotation, duration));\n    this.rotation.normalize();\n  } // Clears the forces applied to the particle.\n\n\n  clearAccumulator() {\n    this.forceAccum = new Vector3(0, 0, 0);\n  }\n\n  applyImpulse(point, impulse) {\n    // const linearComponent = this.position.clone().sub(point).normalize().dot(impulse);\n    // const linearImpulse = this.position.clone().sub(point).normalize().multiplyScalar(linearComponent);\n    // this.velocity.addScaledVector(linearImpulse, this.inverseMass);\n    this.velocity.addScaledVector(impulse, this.inverseMass);\n    const r = point.clone().sub(this.position);\n    /*\n    const angularUnitVector = impulse.clone().cross(this.position.sub(point)).cross(r).normalize();\n    const angularImpulse = angularUnitVector.clone().multiplyScalar(impulse.dot(angularUnitVector));*/\n    // this.angularMomentum.add(r.clone().cross(angularImpulse));\n\n    this.angularMomentum.add(r.clone().cross(impulse));\n  } // for now, set to big enough bounding box so that we don't need to update it.\n\n\n  setBoundingBox() {\n    const radius = Math.sqrt(this.width / 2 * (this.width / 2) + this.length / 2 * (this.length / 2) + this.height / 2 * (this.height / 2));\n    this.boundingBox = new Vector3(radius * 2, radius * 2, radius * 2);\n  }\n\n  createMesh() {\n    const boxGeometry = new THREE.BoxGeometry(this.width, this.length, this.height);\n    const material = new THREE.MeshPhongMaterial({\n      color: 0x00bcd6\n    });\n    this.mesh = new THREE.Mesh(boxGeometry, material);\n  } // updates mesh to current position and orientation\n\n\n  updateMesh() {\n    this.mesh.position.set(this.position.x, this.position.y, this.position.z);\n    this.mesh.setRotationFromQuaternion(this.rotation);\n  }\n\n  createBoundingBoxMesh() {\n    const boxGeometry = new THREE.BoxGeometry(this.boundingBox.x, this.boundingBox.y, this.boundingBox.z);\n    const wireframe = new THREE.WireframeGeometry(boxGeometry);\n    this.boundingBoxMesh = new THREE.LineSegments(wireframe);\n    this.boundingBoxMesh.material = new THREE.LineBasicMaterial({\n      color: 0xffffff\n    });\n  }\n\n  updateBoundingBoxMesh() {\n    this.boundingBoxMesh.position.set(this.position.x, this.position.y, this.position.z);\n  }\n\n}","map":{"version":3,"names":["THREE","Vector3","Matrix3","Quaternion","convertQuaternionToMatrix","addQuaternions","scaleQuaternion","Box","constructor","position","width","length","height","inverseMass","inertia_body","velocity","rotation","angularMomentum","forceAccum","boundingBox","mesh","boundingBoxMesh","setInertia","applyMatrix3","getInertia","setBoundingBox","createMesh","updateMesh","createBoundingBoxMesh","updateBoundingBoxMesh","mass","I_xx","I_yy","I_zz","set","rotationMatrix","inertia","clone","multiply","transpose","getI_inverse","I_body_inverse","invert","I_inverse","getAngularVelocity","angularVelocity","integrateForceAccum","duration","integrate","addScaledVector","clearAccumulator","ddt_Rotation","x","y","z","normalize","applyImpulse","point","impulse","r","sub","add","cross","radius","Math","sqrt","boxGeometry","BoxGeometry","material","MeshPhongMaterial","color","Mesh","setRotationFromQuaternion","wireframe","WireframeGeometry","LineSegments","LineBasicMaterial"],"sources":["/Users/danny/Github/physics_engine_for_the_web/frontend/src/physics_engine/Box.ts"],"sourcesContent":["import * as THREE from \"three\";\nimport { Vector3, Matrix3, Quaternion, Mesh, LineSegments } from \"three\";\nimport { getVectorCrossMatrix, addMatrices, convertQuaternionToMatrix, addQuaternions, scaleQuaternion, getEulerAngles, printEulerAngles } from \"./math_library\";\n\nexport class Box {\n    public inverseMass: number;\n\n    public width: number;\n    public length: number;\n    public height: number;\n\n    public inertia_body: Matrix3; // inertia tensor in body space\n\n    public position: Vector3;\n    public velocity: Vector3;\n    // public momentum: Vector3;\n\n    public rotation: Quaternion // the orientation\n    public angularMomentum: Vector3;\n\n    // holds the accumulated force to be applied to the next simulation iteration only.\n    public forceAccum: Vector3;\n\n    public boundingBox: Vector3 // width, length, and height of the bounding box\n\n    // for graphics\n    public mesh: Mesh;\n    public boundingBoxMesh: LineSegments;\n\n    constructor(position: Vector3, width: number, length: number, height: number) {\n        this.inverseMass = 1 / (width * length * height);\n\n        this.width = width;\n        this.length = length;\n        this.height = height;\n\n        this.inertia_body = new Matrix3();\n        this.setInertia();\n        \n        this.position = position;\n        this.velocity = new Vector3(0, 0, 0);\n        // this.momentum = (new Vector3(1, 0, 0)).multiplyScalar(1/this.inverseMass);\n\n        this.rotation = new Quaternion(0, 0, 0, 1);\n        this.angularMomentum = new Vector3(0, 0, 0).applyMatrix3(this.getInertia());\n\n        this.forceAccum = new Vector3(0, 0, 0);\n\n        this.setBoundingBox();\n\n        // for graphics\n        this.createMesh();\n        this.updateMesh();\n        this.createBoundingBoxMesh();\n        this.updateBoundingBoxMesh();\n    }\n\n    private setInertia(): void {\n        const mass = 1 / this.inverseMass;\n        const I_xx = (1/12) * mass * (this.length*this.length + this.height*this.height);\n        const I_yy = (1/12) * mass * (this.width*this.width + this.height*this.height);\n        const I_zz = (1/12) * mass * (this.width*this.width + this.length*this.length);\n\n        this.inertia_body.set(\n            I_xx, 0, 0,\n            0, I_yy, 0,\n            0, 0, I_zz\n        );\n    }\n\n    getInertia(): Matrix3 {\n        const rotationMatrix = convertQuaternionToMatrix(this.rotation);\n        const inertia = rotationMatrix.clone().multiply(this.inertia_body).multiply(rotationMatrix.clone().transpose());\n        return inertia;\n    }\n\n    getI_inverse(): Matrix3 {\n        const I_body_inverse = this.inertia_body.clone().invert();\n        const rotationMatrix = convertQuaternionToMatrix(this.rotation);\n        const I_inverse = rotationMatrix.clone().multiply(I_body_inverse).multiply(rotationMatrix.clone().transpose());\n        return I_inverse;\n    }\n\n    getAngularVelocity(): Vector3 {\n        const I_inverse = this.getInertia().invert();\n        const angularVelocity = this.angularMomentum.clone().applyMatrix3(I_inverse);\n        return angularVelocity;\n    }\n\n    // update velocity based on forceAccum and clear forceAccum\n    integrateForceAccum(duration: number): void {\n        // Don't integrate if mass is infinite or duration <= 0.\n        if (this.inverseMass <= 0 || duration <= 0) {\n            return;\n        }\n    }\n\n    integrate(duration: number): void {\n        // Don't integrate if mass is infinite or duration <= 0.\n        if (this.inverseMass <= 0 || duration <= 0) {\n            return;\n        }\n\n        // update velocity based on force and then clear forces\n        this.velocity.addScaledVector(this.forceAccum, duration*this.inverseMass);\n        this.clearAccumulator();\n\n        // update position\n        this.position.addScaledVector(this.velocity, duration);\n\n        // this.position.addScaledVector(this.momentum, this.inverseMass * duration);\n\n        // update rotation\n        const angularVelocity = this.getAngularVelocity();\n\n        // ddt_q = (1/2) * w(t) * q(t)\n        const ddt_Rotation = (new Quaternion(angularVelocity.x/2, angularVelocity.y/2, angularVelocity.z/2, 0)).multiply(this.rotation);\n        this.rotation = addQuaternions(this.rotation, scaleQuaternion(ddt_Rotation, duration));\n        this.rotation.normalize();\n    }\n\n    // Clears the forces applied to the particle.\n    clearAccumulator(): void {\n        this.forceAccum = new Vector3(0, 0, 0);\n    }\n\n    applyImpulse(point: Vector3, impulse: Vector3) {\n        // const linearComponent = this.position.clone().sub(point).normalize().dot(impulse);\n        // const linearImpulse = this.position.clone().sub(point).normalize().multiplyScalar(linearComponent);\n        // this.velocity.addScaledVector(linearImpulse, this.inverseMass);\n        this.velocity.addScaledVector(impulse, this.inverseMass);\n        \n\n\n        const r = point.clone().sub(this.position);\n        /*\n        const angularUnitVector = impulse.clone().cross(this.position.sub(point)).cross(r).normalize();\n        const angularImpulse = angularUnitVector.clone().multiplyScalar(impulse.dot(angularUnitVector));*/\n        // this.angularMomentum.add(r.clone().cross(angularImpulse));\n        this.angularMomentum.add(r.clone().cross(impulse));\n    }\n\n    // for now, set to big enough bounding box so that we don't need to update it.\n    private setBoundingBox(): void {\n        const radius = Math.sqrt((this.width/2)*(this.width/2) + (this.length/2)*(this.length/2) + (this.height/2)*(this.height/2));\n        this.boundingBox = new Vector3(radius * 2, radius * 2, radius * 2);\n    };\n\n    private createMesh(): void {\n        const boxGeometry = new THREE.BoxGeometry(this.width, this.length, this.height);\n        const material = new THREE.MeshPhongMaterial({ color: 0x00bcd6 });\n        this.mesh = new THREE.Mesh(boxGeometry, material);\n    }\n\n    // updates mesh to current position and orientation\n    updateMesh(): void {\n        this.mesh.position.set(this.position.x, this.position.y, this.position.z);\n        this.mesh.setRotationFromQuaternion(this.rotation);\n    }\n\n    private createBoundingBoxMesh(): void {\n        const boxGeometry = new THREE.BoxGeometry(this.boundingBox.x, this.boundingBox.y, this.boundingBox.z);\n        const wireframe = new THREE.WireframeGeometry(boxGeometry);\n        this.boundingBoxMesh = new THREE.LineSegments( wireframe );\n        this.boundingBoxMesh.material = new THREE.LineBasicMaterial({ color: 0xffffff });\n    }\n\n    updateBoundingBoxMesh(): void {\n        this.boundingBoxMesh.position.set(this.position.x, this.position.y, this.position.z);\n    }\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}